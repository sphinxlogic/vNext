<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Microsoft.Cci.CodeModel</name>
  </assembly>
  <members>
    <member name="T:Microsoft.Cci.Contracts.IContractMethods">
      <summary>
            A collection of methods that can be called in a way that provides tools with information about contracts.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IContractMethods.Assert">
      <summary>
            A reference to a method that is called to indicate that the condition supplied as its argument should hold at the point of call.
            A static verification tool would have to prove that this condition will be true for all executions that can reach the call.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IContractMethods.Assume">
      <summary>
            A reference to a method that is called to indicate that the condition supplied as its argument should hold at the point of call.
            A static verification tool may assume that this condition will be true for all executions that can reach the call.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IContractMethods.EndContract">
      <summary>
            A reference to a method that is called to indicate that any preceding code should be interpreted as part of the method contract.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IContractMethods.Exists">
      <summary>
            A reference to a generic method that is called to indicate that there exists a value of the type supplied as its generic argument for
            which the predicate supplied as its argument would return true if called with this value its argument.
            A static verification tool would have to prove that this condition will be true for all executions that can reach the call.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IContractMethods.Ensures">
      <summary>
            A reference to a method that is called to indicate that the condition supplied as its argument should hold at method exit.
            A static verification tool would have to prove that this condition will be true for all executions that can reach the call.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IContractMethods.Forall">
      <summary>
            A reference to a generic method that is called to indicate that the predicate supplied as its argument should return true if called on
            any value of the type supplied as the generic argument.
            A static verification tool would have to prove that this condition will be true for all executions that can reach the call.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IContractMethods.Invariant">
      <summary>
            A reference to a method that is called to indicate that the condition supplied as its argument is an
            object invariant for the type in which the method call is found. The exact meaning of when an object
            invariant must hold is left up to the individual tools.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IContractMethods.Old">
      <summary>
            A reference to a generic method whose result is the value of its argument expression as it was at the start of the method.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IContractMethods.Requires">
      <summary>
            A reference to a method that is called to indicate that the condition supplied as its argument should hold at method entry.
            A static verification tool would have to prove that this condition will be true for all executions that can reach the call.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IContractMethods.Result">
      <summary>
            A reference to a method whose result is the value that is returned from the method whose contract contains a call to Result.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IContractMethods.StartContract">
      <summary>
            A reference to a method that is called to indicate that any preceding code should be executed before contract checking happens.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.Contracts.IContractProvider">
      <summary>
            An object that associates contracts, such as preconditions and postconditions, with methods, types and loops. 
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.IContractProvider.GetLoopContractFor(System.Object)">
      <summary>
            Returns the loop contract, if any, that has been associated with the given object. Returns null if no association exits.
            </summary>
      <param name="loop">An object that might have been associated with a loop contract. This can be any kind of object.</param>
    </member>
    <member name="M:Microsoft.Cci.Contracts.IContractProvider.GetMethodContractFor(System.Object)">
      <summary>
            Returns the method contract, if any, that has been associated with the given object. Returns null if no association exits.
            </summary>
      <param name="method">An object that might have been associated with a method contract. This can be any kind of object.</param>
    </member>
    <member name="M:Microsoft.Cci.Contracts.IContractProvider.GetTriggersFor(System.Object)">
      <summary>
            Returns the triggers, if any, that have been associated with the given object. Returns null if no association exits.
            </summary>
      <param name="quantifier">An object that might have been associated with triggers. This can be any kind of object.</param>
    </member>
    <member name="M:Microsoft.Cci.Contracts.IContractProvider.GetTypeContractFor(System.Object)">
      <summary>
            Returns the type contract, if any, that has been associated with the given object. Returns null if no association exits.
            </summary>
      <param name="type">An object that might have been associated with a type contract. This can be any kind of object.</param>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IContractProvider.ContractMethods">
      <summary>
            A collection of methods that can be called in a way that provides tools with information about contracts.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IContractProvider.Unit">
      <summary>
            The unit that this is a contract provider for. Intentional design:
            no provider works on more than one unit.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.Contracts.ContractMethods">
      <summary>
            A collection of methods that can be called in a way that provides tools with information about contracts.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.ContractMethods.#ctor(Microsoft.Cci.IMetadataHost)">
      <summary>
            Allocates a collection of methods that can be called in a way that provides tools with information about contracts.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ContractMethods.Assert">
      <summary>
            A reference to a method that is called to indicate that the condition supplied as its argument should hold at the point of call.
            A static verification tool would have to prove that this condition will be true for all executions that can reach the call.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ContractMethods.Assume">
      <summary>
            A reference to a method that is called to indicate that the condition supplied as its argument should hold at the point of call.
            A static verification tool would have to prove that this condition will be true for all executions that can reach the call.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ContractMethods.EndContract">
      <summary>
            A reference to a method that is called to indicate that any preceding code should be interpreted as part of the method contract.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ContractMethods.Ensures">
      <summary>
            A reference to a method that is called to indicate that the condition supplied as its argument should hold at method entry.
            A static verification tool would have to prove that this condition will be true for all executions that can reach the call.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ContractMethods.Exists">
      <summary>
            A reference to a generic method that is called to indicate that there exists a value of the type supplied as its generic argument for
            which the predicate supplied as its argument would return true if called with this value its argument.
            A static verification tool would have to prove that this condition will be true for all executions that can reach the call.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ContractMethods.Forall">
      <summary>
            A reference to a generic method that is called to indicate that the predicate supplied as its argument should return true if called on
            any value of the type supplied as the generic argument.
            A static verification tool would have to prove that this condition will be true for all executions that can reach the call.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ContractMethods.Invariant">
      <summary>
            A reference to a method that is called to indicate that the condition supplied as its argument is an
            object invariant for the type in which the method call is found. The exact meaning of when an object
            invariant must hold is left up to the individual tools.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ContractMethods.Old">
      <summary>
            A reference to a generic method whose result is the value of its argument expression as it was at the start of the method.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ContractMethods.Requires">
      <summary>
            A reference to a method that is called to indicate that the condition supplied as its argument should hold at method entry.
            A static verification tool would have to prove that this condition will be true for all executions that can reach the call.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ContractMethods.Result">
      <summary>
            A reference to a method whose result is the value that is returned from the method whose contract contains a call to Result.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ContractMethods.StartContract">
      <summary>
            A reference to a method that is called to indicate that any preceding code should be executed before contract checking happens.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.Contracts.IContractElement">
      <summary>
            A common supertype for contracts like preconditions, postconditions,
            object invariants, and loop invariants.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.IContractElement.Dispatch(Microsoft.Cci.Contracts.ICodeAndContractVisitor)">
      <summary>
            Calls the visitor.Visit(T) method where T is the most derived object model node interface type implemented by the concrete type
            of the object implementing IContractElement.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IContractElement.Condition">
      <summary>
            The condition associated with this particular contract element.
            
            For  a loop invariant, the condition that must be true at the start of every iteration of a loop.
            For a precondition, it is the condition that must be true for a caller to call the associated
            method.
            For a postcondition, it is the condition that must be true at the end of the method that is
            associated with this instance.
            For an object invariant, well, it is complicated. In general it is a condition that must be
            true at the end of a public constructor and is both a pre- and postcondition for public methods
            on the type with which the object invariant is associated.
            
            The meaning of the condition is dependent on the type of contract. For instance, mostly this
            will be a boolean-valued expression. But it could also be used for loop variant functions in
            which case this would be an expression which represents a natural number.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IContractElement.Description">
      <summary>
            An optional expression that is associated with this particular contract element. Generally, it would
            be a message that was written at the same time as the contract and is meant to be used as a description
            when the contract fails.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IContractElement.OriginalSource">
      <summary>
            The original source representation of the contract element.
            </summary>
      <remarks>
            Normally this would be extracted directly from the source file.
            The expectation is that one would translate the Condition into
            a source string in a source language appropriate for
            the particular tool environment, e.g., when doing static analysis,
            in the language the client code uses, not the language the contract
            was written.
            </remarks>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IContractElement.IsModel">
      <summary>
            True iff any member mentioned in the Condition is a "model member", i.e.,
            its definition has the [ContractModel] attribute on it.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.Contracts.ILoopContract">
      <summary>
            A collection of collections of objects that describe a loop.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ILoopContract.Invariants">
      <summary>
            A possibly empty list of loop invariants.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ILoopContract.Writes">
      <summary>
            A possibly empty list of expressions that each represents a set of memory locations that may be written to by the loop.
            Is null when no writes clause was specified.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ILoopContract.Variants">
      <summary>
            A possibly empty list of loop variants.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.Contracts.ILoopInvariant">
      <summary>
            A condition that must be true at the start of every iteration of a loop.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.Contracts.IMethodContract">
      <summary>
            A collection of collections of objects that augment the type signature of a method with additional information
            that describe the contract between calling method and called method.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IMethodContract.Allocates">
      <summary>
            A possibly empty list of expressions that each represents a set of memory locations that are newly allocated by a call to the method.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IMethodContract.Frees">
      <summary>
            A possibly empty list of expressions that each represents a set of memory locations that are freed by a call to the method.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IMethodContract.ModifiedVariables">
      <summary>
            A possibly empty list of addressable expressions (variables) that are modified by the called method.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IMethodContract.MustInline">
      <summary>
            The method body constitutes its contract. Callers must substitute the body in line with the call site.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IMethodContract.Postconditions">
      <summary>
            A possibly empty list of postconditions that are established by the called method.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IMethodContract.Preconditions">
      <summary>
            A possibly empty list of preconditions that must be established by the calling method.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IMethodContract.Reads">
      <summary>
            A possibly empty list of expressions that each represents a set of memory locations that may be read by the called method.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IMethodContract.ThrownExceptions">
      <summary>
            A possibly empty list of exceptions that may be thrown (or passed on) by the called method.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IMethodContract.Writes">
      <summary>
            A possibly empty list of expressions that each represents a set of memory locations that may be written to by the called method.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IMethodContract.Variants">
      <summary>
            A possibly empty list of expressions that each represents a measure that goes down on every method call invoked by the called method.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IMethodContract.IsPure">
      <summary>
            True if the method has no observable side-effect on program state and hence this method is safe to use in a contract,
            which may or may not be executed, depending on how the program has been compiled.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.Contracts.IPrecondition">
      <summary>
            A condition that must be true at the start of a method, possibly bundled with an exception that will be thrown if the condition does not hold.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IPrecondition.AlwaysCheckedAtRuntime">
      <summary>
            The precondition is always checked at runtime, even in release builds.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IPrecondition.ExceptionToThrow">
      <summary>
            One of three things:
            1. Null. If null, the runtime behavior of the associated method is undefined when Condition is not true.
            2. An exception: the value of type Exception that will be thrown if Condition is not true at the start of the method that is associated with this instance.
            3. A method call to a void method. The method is called if Condition is not true at the start of the method that is associated with this instance.
               The method is assumed to throw and never terminate normally, but there is no check for this.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.Contracts.IPostcondition">
      <summary>
            A condition that must be true at the end of a method.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.Contracts.IThrownException">
      <summary>
            An exception that can be thrown by the associated method, along with a possibly empty list of postconditions that are true when that happens.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IThrownException.ExceptionType">
      <summary>
            The exception that can be thrown by the associated method.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.IThrownException.Postcondition">
      <summary>
            The postcondition that holds if the associated method throws this exception.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.Contracts.ITypeContract">
      <summary>
            A collection of collections of objects that augment the signature of a type with additional information
            that describe invariants, model variables and functions, as well as axioms.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ITypeContract.ContractFields">
      <summary>
            A possibly empty list of contract fields. Contract fields can only be used inside contracts and are not available at runtime.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ITypeContract.ContractMethods">
      <summary>
            A possibly empty list of contract methods. Contract methods have no bodies and can only be used inside contracts. The meaning of a contract
            method is specified by the axioms of the associated type. Contract methods are not available at runtime.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ITypeContract.Invariants">
      <summary>
            A possibly empty list of type invariants.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.Contracts.ITypeInvariant">
      <summary>
            A condition that must be true after an object has been constructed and that is by default a part of the precondition and postcondition of every public method of the associated type.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ITypeInvariant.IsAxiom">
      <summary>
            An axiom is a type invariant whose truth is assumed rather than derived. Commonly used to make statements about the meaning of contract methods.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.ITypeInvariant.Name">
      <summary>
            The name of the invariant. Used in error diagnostics. May be null.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.Contracts.IContractProviderCallback">
      <summary>
            An object implements this interface so that it can be notified
            by a contract extractor when a contract has been extracted. The
            notification consists of a method's residual body (which includes
            its operations) after the portion representing the contracts has
            been extracted.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.IContractProviderCallback.ProvideResidualMethodBody(Microsoft.Cci.IMethodDefinition,Microsoft.Cci.IBlockStatement)">
      <summary>
            When a contract is extracted, the extractor calls this method
            (if a callback object has been registered) with the part of the
            method body that is left over after the contract has been removed.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.Contracts.MethodContractAndMethodBody">
      <summary>
            Since this project isn't using the 3.5 platform, just needed a quick
            2-tuple.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.MethodContractAndMethodBody.#ctor(Microsoft.Cci.Contracts.IMethodContract,Microsoft.Cci.IBlockStatement)">
      <summary>
            Constructs a pair from the arguments.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.MethodContractAndMethodBody.MethodContract">
      <summary>
            Returns the method contract of the pair.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.MethodContractAndMethodBody.BlockStatement">
      <summary>
            Returns the method body of the pair.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.Contracts.IContractExtractor">
      <summary>
            A contract provider that, when asked for a method contract, extracts
            it from the method and uses a callback to notify clients with
            the remaining method body.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.IContractExtractor.RegisterContractProviderCallback(Microsoft.Cci.Contracts.IContractProviderCallback)">
      <summary>
            When a contract is extracted from a method, all registered callbacks will be notified.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.IContractExtractor.SplitMethodBodyIntoContractAndCode(Microsoft.Cci.ISourceMethodBody)">
      <summary>
            For a client (e.g., a decompiler or a binary rewriter) that has a source method body and wants to have its
            contract extracted. In addition to being returned, the contract is added to the contract provider.
            The residual method body is returned in the second element of the pair and is *not* retained
            by the contract provider.
            REVIEW: When this method is called, should the callback be called? Should it take an extra argument
            that identifies the caller and the event won't be triggered for that client?
            </summary>
    </member>
    <member name="T:Microsoft.Cci.Contracts.IContractAwareHost">
      <summary>
            A host that automatically attaches a contract extractor to each unit that it loads.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.IContractAwareHost.GetContractExtractor(Microsoft.Cci.UnitIdentity)">
      <summary>
            If the unit with the specified identity has been loaded with this host,
            then it will have attached a contract extractor to that unit.
            This method returns that contract extractor.
            If the unit has not been loaded by this host, then null is returned.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IAddressableExpression">
      <summary>
            An expression that denotes a value that has an address in memory, such as a local variable, parameter, field, array element, pointer target, or method.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IExpression">
      <summary>
            An expression results in a value of some type.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.IExpression.Dispatch(Microsoft.Cci.ICodeVisitor)">
      <summary>
            Calls the visitor.Visit(T) method where T is the most derived object model node interface type implemented by the concrete type
            of the object implementing IStatement. The dispatch method does not invoke Dispatch on any child objects. If child traversal
            is desired, the implementations of the Visit methods should do the subsequent dispatching.
            </summary>
      <requires>visitor != null</requires>
    </member>
    <member name="P:Microsoft.Cci.IExpression.Type">
      <summary>
            The type of value the expression will evaluate to, as determined at compile time.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;ITypeReference&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IAddressableExpression.Definition">
      <summary>
            The local variable, parameter, field, array element, pointer target or method that this expression denotes.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IAddressableExpression.Instance">
      <summary>
            The instance to be used if this.Definition is an instance field/method or array indexer.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IAssignment">
      <summary>
            An expression that assigns the value of the source (right) operand to the location represented by the target (left) operand.
            The expression result is the value of the source expression.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IAssignment.Source">
      <summary>
            The expression representing the value to assign. 
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IAssignment.Target">
      <summary>
            The expression representing the target to assign to.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;ITargetExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.IBlockStatement">
      <summary>
            A delimited collection of statements to execute in a new (nested) scope.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IStatement">
      <summary>
            An executable statement.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.IStatement.Dispatch(Microsoft.Cci.ICodeVisitor)">
      <summary>
            Calls the visitor.Visit(T) method where T is the most derived object model node interface type implemented by the concrete type
            of the object implementing IStatement. The dispatch method does not invoke Dispatch on any child objects. If child traversal
            is desired, the implementations of the Visit methods should do the subsequent dispatching.
            </summary>
      <requires>visitor != null</requires>
    </member>
    <member name="P:Microsoft.Cci.IBlockStatement.Statements">
      <summary>
            The statements making up the block.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IBlockStatement.UseCheckedArithmetic">
      <summary>
            True if, by default, all arithmetic expressions in the block must be checked for overflow. This setting is inherited by nested blocks and
            can be overridden by nested blocks and expressions.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ICompileTimeConstant">
      <summary>
            An expression that does not change its value at runtime and can be evaluated at compile time.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ICompileTimeConstant.Value">
      <summary>
            The compile time value of the expression. Can be null.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ICreateArray">
      <summary>
            An expression that creates an array instance.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ICreateArray.ElementType">
      <summary>
            The element type of the array.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;ITypeReference&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.ICreateArray.Initializers">
      <summary>
            The initial values of the array elements. May be empty.
            This must be a flat list of the initial values. Its length
            must be the product of the size of each dimension.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IExpression&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.ICreateArray.LowerBounds">
      <summary>
            The index value of the first element in each dimension.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;int&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.ICreateArray.Rank">
      <summary>
            The number of dimensions of the array.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;uint&gt;() &gt; 0</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.ICreateArray.Sizes">
      <summary>
            The number of elements allowed in each dimension.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IExpression&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.IGotoStatement">
      <summary>
            Represents a goto statement.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IGotoStatement.TargetStatement">
      <summary>
            The statement at which the program execution is to continue.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;ILabeledStatement&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.IMethodCall">
      <summary>
            An expression that invokes a method.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IMethodCall.Arguments">
      <summary>
            The arguments to pass to the method, after they have been converted to match the parameters of the resolved method.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IExpression&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IMethodCall.IsVirtualCall">
      <summary>
            True if the method to call is determined at run time, based on the runtime type of ThisArgument.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IMethodCall.IsStaticCall">
      <summary>
            True if the method to call is static (has no this parameter).
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IMethodCall.IsTailCall">
      <summary>
            True if this method call terminates the calling method. It indicates that the calling method's stack frame is not required
            and can be removed before executing the call.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IMethodCall.MethodToCall">
      <summary>
            The method to call.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IMethodReference&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IMethodCall.ThisArgument">
      <summary>
            The expression that results in the value that must be passed as the value of the this argument of the resolved method.
            </summary>
      <getter>
        <requires>!this.IsStaticCall</requires>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.ISwitchCase">
      <summary>
            An object representing a switch case.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ISwitchCase.Body">
      <summary>
            The statements representing this switch case.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ISwitchCase.Expression">
      <summary>
            A compile time constant of the same type as the switch expression.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ISwitchCase.IsDefault">
      <summary>
            True if this case will be branched to for all values where no other case is applicable. Only one of these is legal per switch statement.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ISwitchStatement">
      <summary>
            An object that represents a switch statement. Branches to one of a list of cases based on the value of a single expression.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ISwitchStatement.Cases">
      <summary>
            The switch cases.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ISwitchStatement.Expression">
      <summary>
            The expression to evaluate in order to determine with switch case to branch to.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ILabeledStatement">
      <summary>
            An object that represents a labeled statement or a stand-alone label.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ILabeledStatement.Label">
      <summary>
            The label.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IName&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.ILabeledStatement.Statement">
      <summary>
            The associated statement. Contains an empty statement if this is a stand-alone label.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IStatement&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.ITargetExpression">
      <summary>
            An expression that can be the target of an assignment statement or that can be passed an argument to an out parameter.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ITargetExpression.Alignment">
      <summary>
            If Definition is a field and the field is not aligned with natural size of its type, this property specifies the actual alignment.
            For example, if the field is byte aligned, then the result of this property is 1. Likewise, 2 for word (16-bit) alignment and 4 for
            double word (32-bit alignment). 
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ITargetExpression.Definition">
      <summary>
            The local variable, parameter, field, property, array element or pointer target that this expression denotes.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ITargetExpression.Instance">
      <summary>
            The instance to be used if this.Definition is an instance field/property or array indexer.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ITargetExpression.IsUnaligned">
      <summary>
            True if the definition is a field and the field is not aligned with the natural size of its type.
            For example if the field type is Int32 and the field is aligned on an Int16 boundary.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ITargetExpression.IsVolatile">
      <summary>
            The bound Definition is a volatile field and its contents may not be cached.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ExpressionHelper">
      <summary>
            Class conraining helper routines for Expressions
            </summary>
    </member>
    <member name="M:Microsoft.Cci.ExpressionHelper.IsIntegerInRangeOf(Microsoft.Cci.ICompileTimeConstant,Microsoft.Cci.ITypeReference)">
      <summary>
            Returns true if the constant is an integral value that falls in the range of the target type. 
            The target type does have to be an integral type. If it is not, this method always returns false.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.ExpressionHelper.IsIntegralNonzero(Microsoft.Cci.IExpression)">
      <summary>
            True if the given expression is a compile time constant with a value that is a boxed integer of type byte, int, long, sbyte, short, uint, ulong or ushort
            that is not equal to 0.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.ExpressionHelper.IsIntegralNonzero(Microsoft.Cci.ICompileTimeConstant)">
      <summary>
            True if the value is a boxed zero of type byte, int, long, sbyte, short, uint, ulong, ushort or bool that is not equal to 0.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.ExpressionHelper.IsIntegralOne(Microsoft.Cci.IExpression)">
      <summary>
            True if the given expression is a compile time constant with a value that is a boxed 1 of type byte, int, long, sbyte, short, uint, ulong, ushort or bool.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.ExpressionHelper.IsIntegralOne(Microsoft.Cci.ICompileTimeConstant)">
      <summary>
            True if the value is a boxed 1 of type byte, int, long, sbyte, short, uint, ulong, ushort or bool.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.ExpressionHelper.IsIntegralZero(Microsoft.Cci.IExpression)">
      <summary>
            True if the given expression is a compile time constant with a value that is a boxed zero of type byte, int, long, sbyte, short, uint, ulong, ushort or bool.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.ExpressionHelper.IsIntegralZero(Microsoft.Cci.ICompileTimeConstant)">
      <summary>
            True if the value is a boxed zero of type byte, int, long, sbyte, short, uint, ulong, ushort or bool.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.ExpressionHelper.IsNullLiteral(Microsoft.Cci.IExpression)">
      <summary>
            True if the given expression is a compile time literal with a null value.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.ExpressionHelper.IsZeroIntPtr(Microsoft.Cci.IExpression)">
      <summary>
            True if the given expression is a compile time constant with a value that is equal to IntPtr.Zero or UIntPtr.Zero.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IAddition">
      <summary>
            An expression that adds the value of the left operand to the value of the right operand.
            Both operands must be primitive numeric types.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IBinaryOperation">
      <summary>
            A binary operation performed on a left and right operand.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IBinaryOperation.LeftOperand">
      <summary>
            The left operand.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IBinaryOperation.RightOperand">
      <summary>
            The right operand.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IAddition.CheckOverflow">
      <summary>
            The addition must be performed with a check for arithmetic overflow and the operands must be integers.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IAddition.TreatOperandsAsUnsignedIntegers">
      <summary>
            If true the operands must be integers and are treated as being unsigned for the purpose of the addition. This only makes a difference if CheckOverflow is true as well.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IAddressOf">
      <summary>
            An expression that takes the address of a target expression.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IAddressOf.Expression">
      <summary>
            An expression that represents an addressable location in memory.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IAddressableExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IAddressOf.ObjectControlsMutability">
      <summary>
            If true, the address can only be used in operations where defining type of the addressed
            object has control over whether or not the object is mutated. For example, a value type that
            exposes no public fields or mutator methods cannot be changed using this address.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IAddressDereference">
      <summary>
            An expression that deferences an address (pointer).
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IAddressDereference.Address">
      <summary>
            The address to dereference.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IAddressDereference.Alignment">
      <summary>
            If the addres to dereference is not aligned with the size of the target type, this property specifies the actual alignment.
            For example, a value of 1 specifies that the pointer is byte aligned, whereas the target type may be word sized.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IAddressDereference.IsUnaligned">
      <summary>
            True if the address is not aligned to the natural size of the target type. If true, the actual alignment of the
            address is specified by this.Alignment.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IAddressDereference.IsVolatile">
      <summary>
            The location at Address is volatile and its contents may not be cached.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IAnonymousDelegate">
      <summary>
            An expression that evaluates to an instance of a delegate type where the body of the method called by the delegate is specified by the expression.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IAnonymousDelegate.Body">
      <summary>
            A block of statements providing the implementation of the anonymous method that is called by the delegate that is the result of this expression.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IAnonymousDelegate.Parameters">
      <summary>
            The parameters this anonymous method.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IAnonymousDelegate.ReturnType">
      <summary>
            The return type of the delegate.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IAnonymousDelegate.Type">
      <summary>
            The type of delegate that this expression results in.
            </summary>
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IExpression.get_Type" inheritedFromTypeName="IExpression">Contract.Result&lt;ITypeReference&gt;() != null</ensures>
        <ensures inheritedFrom="M:Microsoft.Cci.ISignature.get_Type" inheritedFromTypeName="ISignature">Contract.Result&lt;ITypeReference&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.IArrayIndexer">
      <summary>
            An expression that represents an array element access.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IArrayIndexer.IndexedObject">
      <summary>
            An expression that results in value of an array type.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IArrayIndexer.Indices">
      <summary>
            The array indices.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IExpression&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.IBitwiseAnd">
      <summary>
            An expression that computes the bitwise and of the left and right operands. 
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IBitwiseOr">
      <summary>
            An expression that computes the bitwise or of the left and right operands. 
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IBlockExpression">
      <summary>
            An expression that introduces a new block scope and that references local variables
            that are defined and initialized by embedded statements when control reaches the expression.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IBlockExpression.BlockStatement">
      <summary>
            A block of statements that typically introduce local variables to hold sub expressions.
            The scope of these declarations coincides with the block expression. 
            The statements are executed before evaluation of Expression occurs.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IBlockStatement&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IBlockExpression.Expression">
      <summary>
            The expression that computes the result of the entire block expression.
            This expression can contain references to the local variables that are declared inside BlockStatement.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.IBoundExpression">
      <summary>
            An expression that binds to a local variable, parameter or field.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IBoundExpression.Alignment">
      <summary>
            If Definition is a field and the field is not aligned with natural size of its type, this property specifies the actual alignment.
            For example, if the field is byte aligned, then the result of this property is 1. Likewise, 2 for word (16-bit) alignment and 4 for
            double word (32-bit alignment). 
            </summary>
      <getter>
        <requires>this.IsUnaligned</requires>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IBoundExpression.Definition">
      <summary>
            The local variable, parameter or field that this expression binds to.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;object&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IBoundExpression.Instance">
      <summary>
            If the expression binds to an instance field then this property is not null and contains the instance.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IBoundExpression.IsUnaligned">
      <summary>
            True if the definition is a field and the field is not aligned with the natural size of its type.
            For example if the field type is Int32 and the field is aligned on an Int16 boundary.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IBoundExpression.IsVolatile">
      <summary>
            The bound Definition is a volatile field and its contents may not be cached.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ICastIfPossible">
      <summary>
            An expression that casts the value to the given type, resulting in a null value if the cast does not succeed.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ICastIfPossible.ValueToCast">
      <summary>
            The value to cast if possible.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ICastIfPossible.TargetType">
      <summary>
            The type to which the value must be cast. If the value is not of this type, the expression results in a null value of this type.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ICheckIfInstance">
      <summary>
            An expression that results in true if the given operand is an instance of the given type.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ICheckIfInstance.Operand">
      <summary>
            The value to check.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ICheckIfInstance.TypeToCheck">
      <summary>
            The type to which the value must belong for this expression to evaluate as true.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IConversion">
      <summary>
            Converts a value to a given type using a primitive type conversion for which an IL instruction exsists.
            </summary>
      <remarks>User defined conversions are modeled as method calls.</remarks>
    </member>
    <member name="P:Microsoft.Cci.IConversion.ValueToConvert">
      <summary>
            The value to convert. If the type of this value is an enumeration, the target type must have the same size and may not itself be an enumeration.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IConversion.CheckNumericRange">
      <summary>
            If true and ValueToConvert is a number and ResultType is a numeric type, check that ValueToConvert falls within the range of ResultType and throw an exception if not.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IConversion.TypeAfterConversion">
      <summary>
            The type to which the value is to be converted. If the type of this value is an enumeration, the source type must have the same size and may not itself be an enumeration.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;ITypeReference&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.IConditional">
      <summary>
            An expression that results in one of two values, depending on the value of a condition.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IConditional.Condition">
      <summary>
            The condition that determines which subexpression to evaluate.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IConditional.ResultIfTrue">
      <summary>
            The expression to evaluate as the value of the overall expression if the condition is true.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IConditional.ResultIfFalse">
      <summary>
            The expression to evaluate as the value of the overall expression if the condition is false.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.ICreateDelegateInstance">
      <summary>
            Creates an instance of the delegate type return by this.Type, using the method specified by this.MethodToCallViaDelegate.
            If the method is an instance method, then this.Instance specifies the expression that results in the instance on which the 
            method will be called.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ICreateDelegateInstance.Instance">
      <summary>
            An expression that evaluates to the instance (if any) on which this.MethodToCallViaDelegate must be called (via the delegate).
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ICreateDelegateInstance.IsVirtualDelegate">
      <summary>
            True if the delegate encapsulates a virtual method.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ICreateDelegateInstance.MethodToCallViaDelegate">
      <summary>
            The method that is to be be called when the delegate instance is invoked.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IMethodReference&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.ICreateObjectInstance">
      <summary>
            An expression that invokes an object constructor.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ICreateObjectInstance.Arguments">
      <summary>
            The arguments to pass to the constructor.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IExpression&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.ICreateObjectInstance.MethodToCall">
      <summary>
            The contructor method to call.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IMethodReference&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.IDefaultValue">
      <summary>
            An expression that results in the default value of a given type.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IDefaultValue.DefaultValueType">
      <summary>
            The type whose default value is the result of this expression.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IDivision">
      <summary>
            An expression that divides the value of the left operand by the value of the right operand. 
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IDivision.TreatOperandsAsUnsignedIntegers">
      <summary>
            If true the operands must be integers and are treated as being unsigned for the purpose of the division.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IDupValue">
      <summary>
            An expression that results in the value on top of the implicit operand stack.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IEquality">
      <summary>
            An expression that results in true if both operands represent the same value or object.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IExclusiveOr">
      <summary>
            An expression that computes the bitwise exclusive or of the left and right operands. 
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IGetTypeOfTypedReference">
      <summary>
            An expression that results in an instance of System.Type that represents the compile time type that has been paired with a runtime value via a typed reference.
            This corresponds to the __reftype operator in C#.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IGetTypeOfTypedReference.TypedReference">
      <summary>
            An expression that results in a value of type System.TypedReference.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IGetValueOfTypedReference">
      <summary>
            An expression that converts the typed reference value resulting from evaluating TypedReference to a value of the type specified by TargetType.
            This corresponds to the __refvalue operator in C#.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IGetValueOfTypedReference.TypedReference">
      <summary>
            An expression that results in a value of type System.TypedReference.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IGetValueOfTypedReference.TargetType">
      <summary>
            The type to which the value part of the typed reference must be converted.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;ITypeReference&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.IGreaterThan">
      <summary>
            An expression that results in true if the value of the left operand is greater than the value of the right operand.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IGreaterThan.IsUnsignedOrUnordered">
      <summary>
            If the operands are integers, use unsigned comparison. If the operands are floating point numbers, return true if the operands are unordered.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IGreaterThanOrEqual">
      <summary>
            An expression that results in true if the value of the left operand is greater than or equal to the value of the right operand.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IGreaterThanOrEqual.IsUnsignedOrUnordered">
      <summary>
            If the operands are integers, use unsigned comparison. If the operands are floating point numbers, return true if the operands are unordered.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ILeftShift">
      <summary>
            An expression that results in the value of the left operand, shifted left by the number of bits specified by the value of the right operand.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ILessThan">
      <summary>
            An expression that results in true if the value of the left operand is less than the value of the right operand.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ILessThan.IsUnsignedOrUnordered">
      <summary>
            If the operands are integers, use unsigned comparison. If the operands are floating point numbers, return true if the operands are unordered.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ILessThanOrEqual">
      <summary>
            An expression that results in true if the value of the left operand is less than or equal to the value of the right operand.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ILessThanOrEqual.IsUnsignedOrUnordered">
      <summary>
            If the operands are integers, use unsigned comparison. If the operands are floating point numbers, return true if the operands are unordered.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ILogicalNot">
      <summary>
            An expression that results in the logical negation of the boolean value of the given operand.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IUnaryOperation">
      <summary>
            An operation performed on a single operand.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IUnaryOperation.Operand">
      <summary>
            The value on which the operation is performed.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.IMakeTypedReference">
      <summary>
            An expression that creates a typed reference (a pair consisting of a reference to a runtime value and a compile time type).
            This is similar to what happens when a value type is boxed, except that the boxed value can be an object and
            the runtime type of the boxed value can be a subtype of the compile time type that is associated with the boxed valued.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IMakeTypedReference.Operand">
      <summary>
            The value to box in a typed reference.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IModulus">
      <summary>
            An expression that results in the remainder of dividing value the left operand by the value of the right operand. 
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IModulus.TreatOperandsAsUnsignedIntegers">
      <summary>
            If true the operands must be integers and are treated as being unsigned for the purpose of the modulus.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IMultiplication">
      <summary>
            An expression that multiplies the value of the left operand by the value of the right operand. 
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IMultiplication.CheckOverflow">
      <summary>
            The multiplication must be performed with a check for arithmetic overflow and the operands must be integers.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IMultiplication.TreatOperandsAsUnsignedIntegers">
      <summary>
            If true the operands must be integers and are treated as being unsigned for the purpose of the multiplication. This only makes a difference if CheckOverflow is true as well.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.INamedArgument">
      <summary>
            An expression that represents a (name, value) pair and that is typically used in method calls, custom attributes and object initializers.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.INamedArgument.ArgumentName">
      <summary>
            The name of the parameter or property or field that corresponds to the argument.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.INamedArgument.ArgumentValue">
      <summary>
            The value of the argument.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.INamedArgument.ResolvedDefinition">
      <summary>
            Returns either null or the parameter or property or field that corresponds to this argument.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.INotEquality">
      <summary>
            An expression that results in false if both operands represent the same value or object.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IOldValue">
      <summary>
            An expression that represents the value that a target expression had at the start of the method that has a postcondition that includes this expression.
            This node must be replaced before converting the Code Model to IL.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IOldValue.Expression">
      <summary>
            The expression whose value at the start of method execution is referred to in the method postcondition.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.IOnesComplement">
      <summary>
            An expression that results in the bitwise not (1's complement) of the operand.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IOutArgument">
      <summary>
            An expression that must match an out parameter of a method. The method assigns a value to the target Expression.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IOutArgument.Expression">
      <summary>
            The target that is assigned to as a result of the method call.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IPointerCall">
      <summary>
            An expression that calls a method indirectly via a function pointer.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IPointerCall.Arguments">
      <summary>
            The arguments to pass to the method, after they have been converted to match the parameters of the method.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;IExpression&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IPointerCall.IsTailCall">
      <summary>
            True if this method call terminates the calling method. It indicates that the calling method's stack frame is not required
            and can be removed before executing the call.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IPointerCall.Pointer">
      <summary>
            An expression that results at runtime in a function pointer that points to the actual method to call.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
        <ensures>Contract.Result&lt;IExpression&gt;().Type is IFunctionPointer</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.IPopValue">
      <summary>
            An expression that results in the value on top of the implicit operand stack and that also pops that value from the stack.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IRefArgument">
      <summary>
            An expression that must match a ref parameter of a method. 
            The value, before the call, of the addressable Expression is passed to the method and the method may assign a new value to the 
            addressable Expression during the call.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IRefArgument.Expression">
      <summary>
            The target that is assigned to as a result of the method call, but whose value is also passed to the method at the start of the call.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IAddressableExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.IReturnValue">
      <summary>
            An expression that refers to the return value of a method.
            This node must be replaced before converting the Code Model to IL.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IRightShift">
      <summary>
            An expression that results in the value of the left operand, shifted right by the number of bits specified by the value of the right operand, duplicating the sign bit.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IRuntimeArgumentHandleExpression">
      <summary>
            An expression that denotes the runtime argument handle of a method that accepts extra arguments. 
            This expression corresponds to __arglist in C# and results in a value that can be used as the argument to the constructor for System.ArgIterator.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ISizeOf">
      <summary>
            An expression that computes the memory size of instances of a given type at runtime.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ISizeOf.TypeToSize">
      <summary>
            The type to size.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IStackArrayCreate">
      <summary>
            An expression that allocates an array on the call stack.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IStackArrayCreate.ElementType">
      <summary>
            The type of the elements of the stack array. This type must be unmanaged (contain no pointers to objects on the heap managed by the garbage collector).
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IStackArrayCreate.Size">
      <summary>
            The size (number of bytes) of the stack array.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ISubtraction">
      <summary>
            An expression that subtracts the value of the right operand from the value of the left operand. 
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ISubtraction.CheckOverflow">
      <summary>
            The subtraction must be performed with a check for arithmetic overflow and the operands must be integers.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ISubtraction.TreatOperandsAsUnsignedIntegers">
      <summary>
            If true the operands must be integers and are treated as being unsigned for the purpose of the subtraction. This only makes a difference if CheckOverflow is true as well.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ITargetSliceExpression">
      <summary>
            Wraps an expression that represents a storage location that can be assigned to or whose address can be computed and passed as a parameter.
            Furthermore, this storage location must a string. Also wraps expressions supplying the starting position and length of a substring of the target string.
            An assignment of a string to a slice results in a new string where the slice has been replaced with given string.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ITargetSliceExpression.StartOfSlice">
      <summary>
            An expression that represents the index of the first character of a string slice.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ITargetSliceExpression.LengthOfSlice">
      <summary>
            An expression that represents the length of the slice.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IThisReference">
      <summary>
            An expression that binds to the current object instance.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ITokenOf">
      <summary>
            An expression that results in an instance of RuntimeFieldHandle, RuntimeMethodHandle or RuntimeTypeHandle.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ITokenOf.Definition">
      <summary>
            An instance of IFieldReference, IMethodReference or ITypeReference.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ITypeOf">
      <summary>
            An expression that results in a System.Type instance.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ITypeOf.TypeToGet">
      <summary>
            The type that will be represented by the System.Type instance.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IUnaryNegation">
      <summary>
            An expression that results in the arithmetic negation of the given operand.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IUnaryNegation.CheckOverflow">
      <summary>
            The negation must be performed with a check for arithmetic overflow and the operand must be an integer.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IUnaryPlus">
      <summary>
            An expression that results in the arithmetic value of the given operand.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IVectorLength">
      <summary>
            An expression that results in the length of a vector (zero-based one-dimensional array).
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IVectorLength.Vector">
      <summary>
            An expression that results in a value of a vector (zero-based one-dimensional array) type.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ISourceMethodBody">
      <summary>
            A metadata (IL) representation along with a source level representation of the body of a method or of a property/event accessor.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ISourceMethodBody.Block">
      <summary>
            The collection of statements making up the body.
            This is produced by either language parser or through decompilation of the Instructions.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ISourceToILConverter">
      <summary>
            An object that can visit a source method body Block and produce the corresponding IL.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.ISourceToILConverter.ConvertToIL(Microsoft.Cci.IBlockStatement)">
      <summary>
            Traverses the given block of statements in the context of the given method to produce a list of
            IL operations, exception information blocks (the locations of handlers, filters and finallies) and any private helper
            types (for example closure classes) that represent the semantics of the given block of statements.
            The results of the traversal can be retrieved via the GetOperations, GetOperationExceptionInformation
            and GetPrivateHelperTypes methods.
            It is assumed that any implementation of this interface will already have a reference to the method the body is
            contained in before this method is called.
            </summary>
      <param name="body">A block of statements that are to be converted to IL.</param>
    </member>
    <member name="M:Microsoft.Cci.ISourceToILConverter.GetLocalVariables">
      <summary>
            Returns all of the local variables (including compiler generated temporary variables) that are local to the block
            of statements translated by this converter.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.ISourceToILConverter.GetOperations">
      <summary>
            Returns the IL operations that correspond to the statements that have been converted to IL by this converter.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.ISourceToILConverter.GetOperationExceptionInformation">
      <summary>
            Returns zero or more exception exception information blocks (information about handlers, filters and finally blocks)
            that correspond to try-catch-finally constructs that appear in the statements that have been converted to IL by this converter.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.ISourceToILConverter.GetPrivateHelperTypes">
      <summary>
            Returns zero or more types that are used to keep track of information needed to implement
            the statements that have been converted to IL by this converter. For example, any closure classes
            needed to compile anonymous delegate expressions (lambdas) will be returned by this method.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ISourceToILConverter.MaximumStackSizeNeeded">
      <summary>
            The maximum number of stack slots that will be needed by an interpreter of the IL produced by this converter.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IAssertStatement">
      <summary>
            A statement that asserts that a condition must always be true when execution reaches it. For example the assert statement of Spec#
            or a call to System.Diagnostics.Debug.Assert in C#.
            This node must be replaced before converting the Code Model to IL.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IAssertStatement.Condition">
      <summary>
            A condition that must be true when execution reaches this statement.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IAssertStatement.Description">
      <summary>
            An optional expression that is associated with the assertion. Generally, it would
            be a message that was written at the same time as the contract and is meant to be used as a description
            when the contract fails.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IAssertStatement.OriginalSource">
      <summary>
            The original source representation of the assertion.
            </summary>
      <remarks>
            Normally this would be extracted directly from the source file.
            The expectation is that one would translate the Condition into
            a source string in a source language appropriate for
            the particular tool environment, e.g., when doing static analysis,
            in the language the client code uses, not the language the contract
            was written.
            </remarks>
    </member>
    <member name="P:Microsoft.Cci.IAssertStatement.HasBeenVerified">
      <summary>
            True if a static verification tool has determined that the condition will always be true when execution reaches this statement.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IAssumeStatement">
      <summary>
            A statement that assumes that a condition will always be true when execution reaches it. For example the assume statement of Spec#.
            This node must be replaced before converting the Code Model to IL.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IAssumeStatement.Condition">
      <summary>
            A condition that will be true when execution reaches this statement.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IAssumeStatement.Description">
      <summary>
            An optional expression that is associated with the assumption. Generally, it would
            be a message that was written at the same time as the contract and is meant to be used as a description
            when the contract fails.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IAssumeStatement.OriginalSource">
      <summary>
            The original source representation of the assumption.
            </summary>
      <remarks>
            Normally this would be extracted directly from the source file.
            The expectation is that one would translate the Condition into
            a source string in a source language appropriate for
            the particular tool environment, e.g., when doing static analysis,
            in the language the client code uses, not the language the contract
            was written.
            </remarks>
    </member>
    <member name="T:Microsoft.Cci.IBreakStatement">
      <summary>
            Terminates execution of the innermost loop statement or switch case containing this statement directly or indirectly.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ICatchClause">
      <summary>
            Represents a catch clause of a try-catch statement or a try-catch-finally statement. 
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ICatchClause.Body">
      <summary>
            The statements within the catch clause.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IBlockStatement&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.ICatchClause.ExceptionContainer">
      <summary>
            The local that contains the exception instance when executing the catch clause body.
            If there is no such local, Dummy.LocalVariable is returned.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;ILocalDefinition&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.ICatchClause.ExceptionType">
      <summary>
            The type of the exception to handle.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;ITypeReference&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.ICatchClause.FilterCondition">
      <summary>
            A condition that must evaluate to true if the catch clause is to be executed. 
            May be null, in which case any exception of ExceptionType will cause the handler to execute.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IConditionalStatement">
      <summary>
            An object that represents a statement consisting of two sub statements and a condition that governs which one of the two gets executed. Most languages refer to this as an "if statement".
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IConditionalStatement.Condition">
      <summary>
            The expression to evaluate as true or false.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IConditionalStatement.TrueBranch">
      <summary>
            Statement to execute if the conditional expression evaluates to true. 
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IStatement&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IConditionalStatement.FalseBranch">
      <summary>
            Statement to execute if the conditional expression evaluates to false. 
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IStatement&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.IContinueStatement">
      <summary>
            Terminates execution of the loop body containing this statement directly or indirectly and continues on to the loop exit condition test.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ICopyMemoryStatement">
      <summary>
            Represents the cpblk IL instruction, which copies a block of memory from one address to another.
            The behavior of this instruction is undefined if the source block overlaps the target block.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ICopyMemoryStatement.TargetAddress">
      <summary>
            A pointer to the block of memory that is overwritten with the contents of block at SourceAddress.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.ICopyMemoryStatement.SourceAddress">
      <summary>
            A pointer to the block of memory whose contents is to be copied to the block of memory at TargetAddress.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.ICopyMemoryStatement.NumberOfBytesToCopy">
      <summary>
            The number of bytes to copy from SourceAddress to TargetAddress.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.IDebuggerBreakStatement">
      <summary>
            Signals a breakpoint to an attached debugger.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IDoUntilStatement">
      <summary>
            Do statements until condition. Tests the condition after the body. Exits when the condition is true.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IDoUntilStatement.Body">
      <summary>
            The body of the loop.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IDoUntilStatement.Condition">
      <summary>
            The condition to evaluate as false or true.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IEmptyStatement">
      <summary>
            An empty statement.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IEmptyStatement.IsSentinel">
      <summary>
            True if this statement is a sentinel that should never be reachable.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IExpressionStatement">
      <summary>
            An object that represents a statement that consists of a single expression.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IExpressionStatement.Expression">
      <summary>
            The expression.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IFillMemoryStatement">
      <summary>
            Represents the initblk IL instruction, which fills a block of memory with repeated copies of a given fill value.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IFillMemoryStatement.TargetAddress">
      <summary>
            A pointer to the block of memory that is overwritten with the repeated value of FillValue.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IFillMemoryStatement.FillValue">
      <summary>
            An expression resulting in an unsigned 8-bite value that will be used to fill the block at TargetAddress.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.IFillMemoryStatement.NumberOfBytesToFill">
      <summary>
            The number of bytes to fill with FillValue.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.IForEachStatement">
      <summary>
            Represents a foreach statement. Executes the loop body for each element of a collection.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IForEachStatement.Body">
      <summary>
            The body of the loop.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IForEachStatement.Collection">
      <summary>
            An epxression resulting in an enumerable collection of values (an object implementing System.Collections.IEnumerable).
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IForEachStatement.Variable">
      <summary>
            The foreach loop variable that holds the current element from the collection.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IForStatement">
      <summary>
            Represents a for statement, or a loop through a block of statements, using a test expression as a condition for continuing to loop.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IForStatement.Body">
      <summary>
            The statements making up the body of the loop.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IForStatement.Condition">
      <summary>
            The expression to evaluate as true or false, which determines if the loop is to continue.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IForStatement.IncrementStatements">
      <summary>
            Statements that are called after each loop cycle, typically to increment a counter.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IForStatement.InitStatements">
      <summary>
            The loop initialization statements.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IGotoSwitchCaseStatement">
      <summary>
            Represents a "goto case x;" or "goto default" statement in C#.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IGotoSwitchCaseStatement.TargetCase">
      <summary>
            The switch statement case clause to which this statement transfers control to.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ILocalDeclarationStatement">
      <summary>
            An object that represents the declaration of a local variable or constant, with optional initializer.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ILocalDeclarationStatement.InitialValue">
      <summary>
            The initial value of the local variable. This may be null.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ILocalDeclarationStatement.LocalVariable">
      <summary>
            The local variable or constant declared by this statement.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;ILocalDefinition&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.ILockStatement">
      <summary>
            Represents matched monitor enter and exit calls, together with a try-finally to ensure that the exit call always happens.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ILockStatement.Body">
      <summary>
            The statement to execute inside the try body after the monitor has been entered.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ILockStatement.Guard">
      <summary>
            The monitor object (which gets locked when the monitor is entered and unlocked in the finally clause).
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IPushStatement">
      <summary>
            Pushes a value onto an implicit operand stack.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IPushStatement.ValueToPush">
      <summary>
            A value that is to be pushed onto the implicit operand stack.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.IResourceUseStatement">
      <summary>
            Represents a using statement block (of one or more IDisposable resources).
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IResourceUseStatement.Body">
      <summary>
            The body of the resource use statement.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IResourceUseStatement.ResourceAcquisitions">
      <summary>
            Either an IExpression statement whose expression of type IDisposable, or an ILocalDeclarationStatement whose variable is initialized and of type IDisposable.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IRethrowStatement">
      <summary>
            Represents a statement that can only appear inside a catch clause or a filter clause and which rethrows the exception that caused the clause to be invoked.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IReturnStatement">
      <summary>
            Represents a return statement.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IReturnStatement.Expression">
      <summary>
            The return value, if any.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IThrowStatement">
      <summary>
            Represents a statement that throws an exception.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IThrowStatement.Exception">
      <summary>
            The exception to throw.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ITryCatchFinallyStatement">
      <summary>
            Represents a try block with any number of catch clauses, any number of filter clauses and, optionally, a finally or fault block.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ITryCatchFinallyStatement.CatchClauses">
      <summary>
            The catch clauses.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IEnumerable&lt;ICatchClause&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.ITryCatchFinallyStatement.FinallyBody">
      <summary>
            The body of the finally clause, if any. May be null.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ITryCatchFinallyStatement.FaultBody">
      <summary>
            The body of the fault clause, if any. May be null.
            There is no C# equivalent of a fault clause. It is just like a finally clause, but is only invoked if an exception occurred.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.ITryCatchFinallyStatement.TryBody">
      <summary>
            The body of the try clause.
            </summary>
      <getter>
        <ensures>Contract.Result&lt;IBlockStatement&gt;() != null</ensures>
      </getter>
    </member>
    <member name="T:Microsoft.Cci.IWhileDoStatement">
      <summary>
            While condition do statements. Tests the condition before the body. Exits when the condition is true.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IWhileDoStatement.Body">
      <summary>
            The body of the loop.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IWhileDoStatement.Condition">
      <summary>
            The condition to evaluate as false or true.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IYieldBreakStatement">
      <summary>
            Terminates the iteration of values produced by the iterator method containing this statement.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.IYieldReturnStatement">
      <summary>
            Yields the next value in the stream produced by the iterator method containing this statement.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.IYieldReturnStatement.Expression">
      <summary>
            The value to yield.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.ICodeVisitor">
      <summary>
            Implemented by classes that visit nodes of object graphs via a double dispatch mechanism, usually performing some computation of a subset of the nodes in the graph.
            Contains a specialized Visit routine for each standard type of object defined in the code model. 
            </summary>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddition)">
      <summary>
            Performs some computation with the given addition.
            </summary>
      <requires>addition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddressableExpression)">
      <summary>
            Performs some computation with the given addressable expression.
            </summary>
      <requires>addressableExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddressDereference)">
      <summary>
            Performs some computation with the given address dereference expression.
            </summary>
      <requires>addressDereference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddressOf)">
      <summary>
            Performs some computation with the given AddressOf expression.
            </summary>
      <requires>addressOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAnonymousDelegate)">
      <summary>
            Performs some computation with the given anonymous delegate expression.
            </summary>
      <requires>anonymousDelegate != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IArrayIndexer)">
      <summary>
            Performs some computation with the given array indexer expression.
            </summary>
      <requires>arrayIndexer != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAssertStatement)">
      <summary>
            Performs some computation with the given assert statement.
            </summary>
      <requires>assertStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAssignment)">
      <summary>
            Performs some computation with the given assignment expression.
            </summary>
      <requires>assignment != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAssumeStatement)">
      <summary>
            Performs some computation with the given assume statement.
            </summary>
      <requires>assumeStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBitwiseAnd)">
      <summary>
            Performs some computation with the given bitwise and expression.
            </summary>
      <requires>bitwiseAnd != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBitwiseOr)">
      <summary>
            Performs some computation with the given bitwise or expression.
            </summary>
      <requires>bitwiseOr != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBlockExpression)">
      <summary>
            Performs some computation with the given block expression.
            </summary>
      <requires>blockExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBlockStatement)">
      <summary>
            Performs some computation with the given statement block.
            </summary>
      <requires>block != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBreakStatement)">
      <summary>
            Performs some computation with the given break statement.
            </summary>
      <requires>breakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBoundExpression)">
      <summary>
            Performs some computation with the given bound expression.
            </summary>
      <requires>boundExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICastIfPossible)">
      <summary>
            Performs some computation with the cast-if-possible expression.
            </summary>
      <requires>castIfPossible != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICatchClause)">
      <summary>
            Performs some computation with the given catch clause.
            </summary>
      <requires>catchClause != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICheckIfInstance)">
      <summary>
            Performs some computation with the given check-if-instance expression.
            </summary>
      <requires>checkIfInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICompileTimeConstant)">
      <summary>
            Performs some computation with the given compile time constant.
            </summary>
      <requires>constant != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IConversion)">
      <summary>
            Performs some computation with the given conversion expression.
            </summary>
      <requires>conversion != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IConditional)">
      <summary>
            Performs some computation with the given conditional expression.
            </summary>
      <requires>conditional != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IConditionalStatement)">
      <summary>
            Performs some computation with the given conditional statement.
            </summary>
      <requires>conditionalStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IContinueStatement)">
      <summary>
            Performs some computation with the given continue statement.
            </summary>
      <requires>continueStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICopyMemoryStatement)">
      <summary>
            Performs some computation with the given copy memory statement.
            </summary>
      <requires>copyMemoryStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICreateArray)">
      <summary>
            Performs some computation with the given array creation expression.
            </summary>
      <requires>createArray != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICreateDelegateInstance)">
      <summary>
            Performs some computation with the anonymous object creation expression.
            </summary>
      <requires>createDelegateInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICreateObjectInstance)">
      <summary>
            Performs some computation with the given constructor call expression.
            </summary>
      <requires>createObjectInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDebuggerBreakStatement)">
      <summary>
            Performs some computation with the given debugger break statement.
            </summary>
      <requires>debuggerBreakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDefaultValue)">
      <summary>
            Performs some computation with the given defalut value expression.
            </summary>
      <requires>defaultValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDivision)">
      <summary>
            Performs some computation with the given division expression.
            </summary>
      <requires>division != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDoUntilStatement)">
      <summary>
            Performs some computation with the given do until statement.
            </summary>
      <requires>doUntilStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDupValue)">
      <summary>
            Performs some compuation with the given dup value expression.
            </summary>
      <param name="dupValue" />
      <requires>dupValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IEmptyStatement)">
      <summary>
            Performs some computation with the given empty statement.
            </summary>
      <requires>emptyStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IEquality)">
      <summary>
            Performs some computation with the given equality expression.
            </summary>
      <requires>equality != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IExclusiveOr)">
      <summary>
            Performs some computation with the given exclusive or expression.
            </summary>
      <requires>exclusiveOr != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IExpressionStatement)">
      <summary>
            Performs some computation with the given expression statement.
            </summary>
      <requires>expressionStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IFillMemoryStatement)">
      <summary>
            Performs some computation with the given fill memory statement.
            </summary>
      <requires>fillMemoryStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IForEachStatement)">
      <summary>
            Performs some computation with the given foreach statement.
            </summary>
      <requires>forEachStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IForStatement)">
      <summary>
            Performs some computation with the given for statement.
            </summary>
      <requires>forStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGotoStatement)">
      <summary>
            Performs some computation with the given goto statement.
            </summary>
      <requires>gotoStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGotoSwitchCaseStatement)">
      <summary>
            Performs some computation with the given goto switch case statement.
            </summary>
      <requires>gotoSwitchCaseStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGetTypeOfTypedReference)">
      <summary>
            Performs some computation with the given get type of typed reference expression.
            </summary>
      <requires>getTypeOfTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGetValueOfTypedReference)">
      <summary>
            Performs some computation with the given get value of typed reference expression.
            </summary>
      <requires>getValueOfTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGreaterThan)">
      <summary>
            Performs some computation with the given greater-than expression.
            </summary>
      <requires>greaterThan != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGreaterThanOrEqual)">
      <summary>
            Performs some computation with the given greater-than-or-equal expression.
            </summary>
      <requires>greaterThanOrEqual != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILabeledStatement)">
      <summary>
            Performs some computation with the given labeled statement.
            </summary>
      <requires>labeledStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILeftShift)">
      <summary>
            Performs some computation with the given left shift expression.
            </summary>
      <requires>leftShift != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILessThan)">
      <summary>
            Performs some computation with the given less-than expression.
            </summary>
      <requires>lessThan != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILessThanOrEqual)">
      <summary>
            Performs some computation with the given less-than-or-equal expression.
            </summary>
      <requires>lessThanOrEqual != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILocalDeclarationStatement)">
      <summary>
            Performs some computation with the given local declaration statement.
            </summary>
      <requires>localDeclarationStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILockStatement)">
      <summary>
            Performs some computation with the given lock statement.
            </summary>
      <requires>lockStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILogicalNot)">
      <summary>
            Performs some computation with the given logical not expression.
            </summary>
      <requires>logicalNot != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IMakeTypedReference)">
      <summary>
            Performs some computation with the given make typed reference expression.
            </summary>
      <requires>makeTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IMethodCall)">
      <summary>
            Performs some computation with the given method call.
            </summary>
      <requires>methodCall != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IModulus)">
      <summary>
            Performs some computation with the given modulus expression.
            </summary>
      <requires>modulus != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IMultiplication)">
      <summary>
            Performs some computation with the given multiplication expression.
            </summary>
      <requires>multiplication != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.INamedArgument)">
      <summary>
            Performs some computation with the given named argument expression.
            </summary>
      <requires>namedArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.INotEquality)">
      <summary>
            Performs some computation with the given not equality expression.
            </summary>
      <requires>notEquality != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IOldValue)">
      <summary>
            Performs some computation with the given old value expression.
            </summary>
      <requires>oldValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IOnesComplement)">
      <summary>
            Performs some computation with the given one's complement expression.
            </summary>
      <requires>onesComplement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IOutArgument)">
      <summary>
            Performs some computation with the given out argument expression.
            </summary>
      <requires>outArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IPointerCall)">
      <summary>
            Performs some computation with the given pointer call.
            </summary>
      <requires>pointerCall != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IPopValue)">
      <summary>
            Performs some compuation with the given pop value expression.
            </summary>
      <param name="popValue" />
      <requires>popValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IPushStatement)">
      <summary>
            Performs some computation with the given push statement.
            </summary>
      <requires>pushStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRefArgument)">
      <summary>
            Performs some computation with the given ref argument expression.
            </summary>
      <requires>refArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IResourceUseStatement)">
      <summary>
            Performs some computation with the given resource usage statement.
            </summary>
      <requires>resourceUseStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IReturnValue)">
      <summary>
            Performs some computation with the given return value expression.
            </summary>
      <requires>returnValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRethrowStatement)">
      <summary>
            Performs some computation with the rethrow statement.
            </summary>
      <requires>rethrowStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IReturnStatement)">
      <summary>
            Performs some computation with the return statement.
            </summary>
      <requires>returnStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRightShift)">
      <summary>
            Performs some computation with the given right shift expression.
            </summary>
      <requires>rightShift != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRuntimeArgumentHandleExpression)">
      <summary>
            Performs some computation with the given runtime argument handle expression.
            </summary>
      <requires>runtimeArgumentHandleExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISizeOf)">
      <summary>
            Performs some computation with the given sizeof() expression.
            </summary>
      <requires>sizeOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IStackArrayCreate)">
      <summary>
            Performs some computation with the given stack array create expression.
            </summary>
      <requires>stackArrayCreate != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISubtraction)">
      <summary>
            Performs some computation with the given subtraction expression.
            </summary>
      <requires>subtraction != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISwitchCase)">
      <summary>
            Performs some computation with the given switch case.
            </summary>
      <requires>switchCase != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISwitchStatement)">
      <summary>
            Performs some computation with the given switch statement.
            </summary>
      <requires>switchStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITargetExpression)">
      <summary>
            Performs some computation with the given target expression.
            </summary>
      <requires>targetExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IThisReference)">
      <summary>
            Performs some computation with the given this reference expression.
            </summary>
      <requires>thisReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IThrowStatement)">
      <summary>
            Performs some computation with the throw statement.
            </summary>
      <requires>throwStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITryCatchFinallyStatement)">
      <summary>
            Performs some computation with the try-catch-filter-finally statement.
            </summary>
      <requires>tryCatchFilterFinallyStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITokenOf)">
      <summary>
            Performs some computation with the given tokenof() expression.
            </summary>
      <requires>tokenOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITypeOf)">
      <summary>
            Performs some computation with the given typeof() expression.
            </summary>
      <requires>typeOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IUnaryNegation)">
      <summary>
            Performs some computation with the given unary negation expression.
            </summary>
      <requires>unaryNegation != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IUnaryPlus)">
      <summary>
            Performs some computation with the given unary plus expression.
            </summary>
      <requires>unaryPlus != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IVectorLength)">
      <summary>
            Performs some computation with the given vector length expression.
            </summary>
      <requires>vectorLength != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IWhileDoStatement)">
      <summary>
            Performs some computation with the given while do statement.
            </summary>
      <requires>whileDoStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IYieldBreakStatement)">
      <summary>
            Performs some computation with the given yield break statement.
            </summary>
      <requires>yieldBreakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IYieldReturnStatement)">
      <summary>
            Performs some computation with the given yield return statement.
            </summary>
      <requires>yieldReturnStatement != null</requires>
    </member>
    <member name="T:Microsoft.Cci.CodeVisitor">
      <summary>
            Contains a specialized Visit routine for each standard type of object defined in the code and metadata model. 
            </summary>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.#ctor">
      <summary>
            Contains a specialized Visit routine for each standard type of object defined in the code and metadata model. 
            </summary>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IAddition)">
      <summary>
            Performs some computation with the given addition.
            </summary>
      <param name="addition" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddition)" inheritedFromTypeName="ICodeVisitor">addition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IAddressableExpression)">
      <summary>
            Performs some computation with the given addressable expression.
            </summary>
      <param name="addressableExpression" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddressableExpression)" inheritedFromTypeName="ICodeVisitor">addressableExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IAddressDereference)">
      <summary>
            Performs some computation with the given address dereference expression.
            </summary>
      <param name="addressDereference" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddressDereference)" inheritedFromTypeName="ICodeVisitor">addressDereference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IAddressOf)">
      <summary>
            Performs some computation with the given AddressOf expression.
            </summary>
      <param name="addressOf" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddressOf)" inheritedFromTypeName="ICodeVisitor">addressOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IAnonymousDelegate)">
      <summary>
            Performs some computation with the given anonymous delegate expression.
            </summary>
      <param name="anonymousDelegate" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAnonymousDelegate)" inheritedFromTypeName="ICodeVisitor">anonymousDelegate != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IArrayIndexer)">
      <summary>
            Performs some computation with the given array indexer expression.
            </summary>
      <param name="arrayIndexer" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IArrayIndexer)" inheritedFromTypeName="ICodeVisitor">arrayIndexer != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IAssertStatement)">
      <summary>
            Performs some computation with the given assert statement.
            </summary>
      <param name="assertStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAssertStatement)" inheritedFromTypeName="ICodeVisitor">assertStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IAssignment)">
      <summary>
            Performs some computation with the given assignment expression.
            </summary>
      <param name="assignment" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAssignment)" inheritedFromTypeName="ICodeVisitor">assignment != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IAssumeStatement)">
      <summary>
            Performs some computation with the given assume statement.
            </summary>
      <param name="assumeStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAssumeStatement)" inheritedFromTypeName="ICodeVisitor">assumeStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IBitwiseAnd)">
      <summary>
            Performs some computation with the given bitwise and expression.
            </summary>
      <param name="bitwiseAnd" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBitwiseAnd)" inheritedFromTypeName="ICodeVisitor">bitwiseAnd != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IBinaryOperation)">
      <summary>
            Performs some computation with the given bitwise and expression.
            </summary>
      <param name="binaryOperation" />
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IBitwiseOr)">
      <summary>
            Performs some computation with the given bitwise or expression.
            </summary>
      <param name="bitwiseOr" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBitwiseOr)" inheritedFromTypeName="ICodeVisitor">bitwiseOr != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IBlockExpression)">
      <summary>
            Performs some computation with the given block expression.
            </summary>
      <param name="blockExpression" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBlockExpression)" inheritedFromTypeName="ICodeVisitor">blockExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IBlockStatement)">
      <summary>
            Performs some computation with the given statement block.
            </summary>
      <param name="block" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBlockStatement)" inheritedFromTypeName="ICodeVisitor">block != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IBreakStatement)">
      <summary>
            Performs some computation with the given break statement.
            </summary>
      <param name="breakStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBreakStatement)" inheritedFromTypeName="ICodeVisitor">breakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ICastIfPossible)">
      <summary>
            Performs some computation with the cast-if-possible expression.
            </summary>
      <param name="castIfPossible" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICastIfPossible)" inheritedFromTypeName="ICodeVisitor">castIfPossible != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ICatchClause)">
      <summary>
            Performs some computation with the given catch clause.
            </summary>
      <param name="catchClause" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICatchClause)" inheritedFromTypeName="ICodeVisitor">catchClause != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ICheckIfInstance)">
      <summary>
            Performs some computation with the given check-if-instance expression.
            </summary>
      <param name="checkIfInstance" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICheckIfInstance)" inheritedFromTypeName="ICodeVisitor">checkIfInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ICompileTimeConstant)">
      <summary>
            Performs some computation with the given compile time constant.
            </summary>
      <param name="constant" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICompileTimeConstant)" inheritedFromTypeName="ICodeVisitor">constant != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IConversion)">
      <summary>
            Performs some computation with the given conversion expression.
            </summary>
      <param name="conversion" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IConversion)" inheritedFromTypeName="ICodeVisitor">conversion != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IConditional)">
      <summary>
            Performs some computation with the given conditional expression.
            </summary>
      <param name="conditional" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IConditional)" inheritedFromTypeName="ICodeVisitor">conditional != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IConditionalStatement)">
      <summary>
            Performs some computation with the given conditional statement.
            </summary>
      <param name="conditionalStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IConditionalStatement)" inheritedFromTypeName="ICodeVisitor">conditionalStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IContinueStatement)">
      <summary>
            Performs some computation with the given continue statement.
            </summary>
      <param name="continueStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IContinueStatement)" inheritedFromTypeName="ICodeVisitor">continueStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ICopyMemoryStatement)">
      <summary>
            Performs some computation with the given copy memory statement.
            </summary>
      <param name="copyMemoryStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICopyMemoryStatement)" inheritedFromTypeName="ICodeVisitor">copyMemoryStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ICreateArray)">
      <summary>
            Performs some computation with the given array creation expression.
            </summary>
      <param name="createArray" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICreateArray)" inheritedFromTypeName="ICodeVisitor">createArray != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ICreateObjectInstance)">
      <summary>
            Performs some computation with the given constructor call expression.
            </summary>
      <param name="createObjectInstance" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICreateObjectInstance)" inheritedFromTypeName="ICodeVisitor">createObjectInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ICreateDelegateInstance)">
      <summary>
            Performs some computation with the anonymous object creation expression.
            </summary>
      <param name="createDelegateInstance" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICreateDelegateInstance)" inheritedFromTypeName="ICodeVisitor">createDelegateInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IDefaultValue)">
      <summary>
            Performs some computation with the given defalut value expression.
            </summary>
      <param name="defaultValue" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDefaultValue)" inheritedFromTypeName="ICodeVisitor">defaultValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IDivision)">
      <summary>
            Performs some computation with the given division expression.
            </summary>
      <param name="division" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDivision)" inheritedFromTypeName="ICodeVisitor">division != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IDoUntilStatement)">
      <summary>
            Performs some computation with the given do until statement.
            </summary>
      <param name="doUntilStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDoUntilStatement)" inheritedFromTypeName="ICodeVisitor">doUntilStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IDupValue)">
      <summary>
            Performs some computation with the given dup value expression.
            </summary>
      <param name="dupValue" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDupValue)" inheritedFromTypeName="ICodeVisitor">dupValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IEmptyStatement)">
      <summary>
            Performs some computation with the given empty statement.
            </summary>
      <param name="emptyStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IEmptyStatement)" inheritedFromTypeName="ICodeVisitor">emptyStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IEquality)">
      <summary>
            Performs some computation with the given equality expression.
            </summary>
      <param name="equality" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IEquality)" inheritedFromTypeName="ICodeVisitor">equality != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IExclusiveOr)">
      <summary>
            Performs some computation with the given exclusive or expression.
            </summary>
      <param name="exclusiveOr" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IExclusiveOr)" inheritedFromTypeName="ICodeVisitor">exclusiveOr != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IBoundExpression)">
      <summary>
            Performs some computation with the given bound expression.
            </summary>
      <param name="boundExpression" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBoundExpression)" inheritedFromTypeName="ICodeVisitor">boundExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IDebuggerBreakStatement)">
      <summary>
            Performs some computation with the given debugger break statement.
            </summary>
      <param name="debuggerBreakStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDebuggerBreakStatement)" inheritedFromTypeName="ICodeVisitor">debuggerBreakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IExpression)">
      <summary>
            Performs some computation with the given expression.
            </summary>
      <param name="expression" />
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IExpressionStatement)">
      <summary>
            Performs some computation with the given expression statement.
            </summary>
      <param name="expressionStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IExpressionStatement)" inheritedFromTypeName="ICodeVisitor">expressionStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IFillMemoryStatement)">
      <summary>
            Performs some computation with the given fill memory statement.
            </summary>
      <param name="fillMemoryStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IFillMemoryStatement)" inheritedFromTypeName="ICodeVisitor">fillMemoryStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IForEachStatement)">
      <summary>
            Performs some computation with the given foreach statement.
            </summary>
      <param name="forEachStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IForEachStatement)" inheritedFromTypeName="ICodeVisitor">forEachStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IForStatement)">
      <summary>
            Performs some computation with the given for statement.
            </summary>
      <param name="forStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IForStatement)" inheritedFromTypeName="ICodeVisitor">forStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IGetTypeOfTypedReference)">
      <summary>
            Performs some computation with the given get type of typed reference expression.
            </summary>
      <param name="getTypeOfTypedReference" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGetTypeOfTypedReference)" inheritedFromTypeName="ICodeVisitor">getTypeOfTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IGetValueOfTypedReference)">
      <summary>
            Performs some computation with the given get value of typed reference expression.
            </summary>
      <param name="getValueOfTypedReference" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGetValueOfTypedReference)" inheritedFromTypeName="ICodeVisitor">getValueOfTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IGotoStatement)">
      <summary>
            Performs some computation with the given goto statement.
            </summary>
      <param name="gotoStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGotoStatement)" inheritedFromTypeName="ICodeVisitor">gotoStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IGotoSwitchCaseStatement)">
      <summary>
            Performs some computation with the given goto switch case statement.
            </summary>
      <param name="gotoSwitchCaseStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGotoSwitchCaseStatement)" inheritedFromTypeName="ICodeVisitor">gotoSwitchCaseStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IGreaterThan)">
      <summary>
            Performs some computation with the given greater-than expression.
            </summary>
      <param name="greaterThan" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGreaterThan)" inheritedFromTypeName="ICodeVisitor">greaterThan != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IGreaterThanOrEqual)">
      <summary>
            Performs some computation with the given greater-than-or-equal expression.
            </summary>
      <param name="greaterThanOrEqual" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGreaterThanOrEqual)" inheritedFromTypeName="ICodeVisitor">greaterThanOrEqual != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ILabeledStatement)">
      <summary>
            Performs some computation with the given labeled statement.
            </summary>
      <param name="labeledStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILabeledStatement)" inheritedFromTypeName="ICodeVisitor">labeledStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ILeftShift)">
      <summary>
            Performs some computation with the given left shift expression.
            </summary>
      <param name="leftShift" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILeftShift)" inheritedFromTypeName="ICodeVisitor">leftShift != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ILessThan)">
      <summary>
            Performs some computation with the given less-than expression.
            </summary>
      <param name="lessThan" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILessThan)" inheritedFromTypeName="ICodeVisitor">lessThan != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ILessThanOrEqual)">
      <summary>
            Performs some computation with the given less-than-or-equal expression.
            </summary>
      <param name="lessThanOrEqual" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILessThanOrEqual)" inheritedFromTypeName="ICodeVisitor">lessThanOrEqual != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ILocalDeclarationStatement)">
      <summary>
            Performs some computation with the given local declaration statement.
            </summary>
      <param name="localDeclarationStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILocalDeclarationStatement)" inheritedFromTypeName="ICodeVisitor">localDeclarationStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ILockStatement)">
      <summary>
            Performs some computation with the given lock statement.
            </summary>
      <param name="lockStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILockStatement)" inheritedFromTypeName="ICodeVisitor">lockStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ILogicalNot)">
      <summary>
            Performs some computation with the given logical not expression.
            </summary>
      <param name="logicalNot" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILogicalNot)" inheritedFromTypeName="ICodeVisitor">logicalNot != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IMakeTypedReference)">
      <summary>
            Performs some computation with the given make typed reference expression.
            </summary>
      <param name="makeTypedReference" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IMakeTypedReference)" inheritedFromTypeName="ICodeVisitor">makeTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IMethodCall)">
      <summary>
            Performs some computation with the given method call.
            </summary>
      <param name="methodCall" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IMethodCall)" inheritedFromTypeName="ICodeVisitor">methodCall != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IModulus)">
      <summary>
            Performs some computation with the given modulus expression.
            </summary>
      <param name="modulus" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IModulus)" inheritedFromTypeName="ICodeVisitor">modulus != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IMultiplication)">
      <summary>
            Performs some computation with the given multiplication expression.
            </summary>
      <param name="multiplication" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IMultiplication)" inheritedFromTypeName="ICodeVisitor">multiplication != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.INamedArgument)">
      <summary>
            Performs some computation with the given named argument expression.
            </summary>
      <param name="namedArgument" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.INamedArgument)" inheritedFromTypeName="ICodeVisitor">namedArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.INotEquality)">
      <summary>
            Performs some computation with the given not equality expression.
            </summary>
      <param name="notEquality" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.INotEquality)" inheritedFromTypeName="ICodeVisitor">notEquality != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IOldValue)">
      <summary>
            Performs some computation with the given old value expression.
            </summary>
      <param name="oldValue" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IOldValue)" inheritedFromTypeName="ICodeVisitor">oldValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IOnesComplement)">
      <summary>
            Performs some computation with the given one's complement expression.
            </summary>
      <param name="onesComplement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IOnesComplement)" inheritedFromTypeName="ICodeVisitor">onesComplement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IOutArgument)">
      <summary>
            Performs some computation with the given out argument expression.
            </summary>
      <param name="outArgument" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IOutArgument)" inheritedFromTypeName="ICodeVisitor">outArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IPointerCall)">
      <summary>
            Performs some computation with the given pointer call.
            </summary>
      <param name="pointerCall" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IPointerCall)" inheritedFromTypeName="ICodeVisitor">pointerCall != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IPopValue)">
      <summary>
            Performs some computation with the given pop value expression.
            </summary>
      <param name="popValue" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IPopValue)" inheritedFromTypeName="ICodeVisitor">popValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IPushStatement)">
      <summary>
            Performs some computation with the given push statement.
            </summary>
      <param name="pushStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IPushStatement)" inheritedFromTypeName="ICodeVisitor">pushStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IRefArgument)">
      <summary>
            Performs some computation with the given ref argument expression.
            </summary>
      <param name="refArgument" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRefArgument)" inheritedFromTypeName="ICodeVisitor">refArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IResourceUseStatement)">
      <summary>
            Performs some computation with the given resource usage statement.
            </summary>
      <param name="resourceUseStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IResourceUseStatement)" inheritedFromTypeName="ICodeVisitor">resourceUseStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IRethrowStatement)">
      <summary>
            Performs some computation with the rethrow statement.
            </summary>
      <param name="rethrowStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRethrowStatement)" inheritedFromTypeName="ICodeVisitor">rethrowStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IReturnStatement)">
      <summary>
            Performs some computation with the return statement.
            </summary>
      <param name="returnStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IReturnStatement)" inheritedFromTypeName="ICodeVisitor">returnStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IReturnValue)">
      <summary>
            Performs some computation with the given return value expression.
            </summary>
      <param name="returnValue" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IReturnValue)" inheritedFromTypeName="ICodeVisitor">returnValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IRightShift)">
      <summary>
            Performs some computation with the given right shift expression.
            </summary>
      <param name="rightShift" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRightShift)" inheritedFromTypeName="ICodeVisitor">rightShift != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IStackArrayCreate)">
      <summary>
            Performs some computation with the given stack array create expression.
            </summary>
      <param name="stackArrayCreate" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IStackArrayCreate)" inheritedFromTypeName="ICodeVisitor">stackArrayCreate != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IRuntimeArgumentHandleExpression)">
      <summary>
            Performs some computation with the given runtime argument handle expression.
            </summary>
      <param name="runtimeArgumentHandleExpression" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRuntimeArgumentHandleExpression)" inheritedFromTypeName="ICodeVisitor">runtimeArgumentHandleExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ISizeOf)">
      <summary>
            Performs some computation with the given sizeof() expression.
            </summary>
      <param name="sizeOf" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISizeOf)" inheritedFromTypeName="ICodeVisitor">sizeOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IStatement)">
      <summary>
            Visits the specified statement.
            </summary>
      <param name="statement">The statement.</param>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ISubtraction)">
      <summary>
            Performs some computation with the given subtraction expression.
            </summary>
      <param name="subtraction" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISubtraction)" inheritedFromTypeName="ICodeVisitor">subtraction != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ISwitchCase)">
      <summary>
            Performs some computation with the given switch case.
            </summary>
      <param name="switchCase" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISwitchCase)" inheritedFromTypeName="ICodeVisitor">switchCase != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ISwitchStatement)">
      <summary>
            Performs some computation with the given switch statement.
            </summary>
      <param name="switchStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISwitchStatement)" inheritedFromTypeName="ICodeVisitor">switchStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ITargetExpression)">
      <summary>
            Performs some computation with the given target expression.
            </summary>
      <param name="targetExpression" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITargetExpression)" inheritedFromTypeName="ICodeVisitor">targetExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IThisReference)">
      <summary>
            Performs some computation with the given this reference expression.
            </summary>
      <param name="thisReference" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IThisReference)" inheritedFromTypeName="ICodeVisitor">thisReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IThrowStatement)">
      <summary>
            Performs some computation with the throw statement.
            </summary>
      <param name="throwStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IThrowStatement)" inheritedFromTypeName="ICodeVisitor">throwStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ITryCatchFinallyStatement)">
      <summary>
            Performs some computation with the try-catch-filter-finally statement.
            </summary>
      <param name="tryCatchFilterFinallyStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITryCatchFinallyStatement)" inheritedFromTypeName="ICodeVisitor">tryCatchFilterFinallyStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ITokenOf)">
      <summary>
            Performs some computation with the given tokenof() expression.
            </summary>
      <param name="tokenOf" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITokenOf)" inheritedFromTypeName="ICodeVisitor">tokenOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.ITypeOf)">
      <summary>
            Performs some computation with the given typeof() expression.
            </summary>
      <param name="typeOf" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITypeOf)" inheritedFromTypeName="ICodeVisitor">typeOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IUnaryNegation)">
      <summary>
            Performs some computation with the given unary negation expression.
            </summary>
      <param name="unaryNegation" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IUnaryNegation)" inheritedFromTypeName="ICodeVisitor">unaryNegation != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IUnaryOperation)">
      <summary>
            Performs some computation with the given unary operation expression.
            </summary>
      <param name="unaryOperation" />
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IUnaryPlus)">
      <summary>
            Performs some computation with the given unary plus expression.
            </summary>
      <param name="unaryPlus" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IUnaryPlus)" inheritedFromTypeName="ICodeVisitor">unaryPlus != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IVectorLength)">
      <summary>
            Performs some computation with the given vector length expression.
            </summary>
      <param name="vectorLength" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IVectorLength)" inheritedFromTypeName="ICodeVisitor">vectorLength != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IWhileDoStatement)">
      <summary>
            Performs some computation with the given while do statement.
            </summary>
      <param name="whileDoStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IWhileDoStatement)" inheritedFromTypeName="ICodeVisitor">whileDoStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IYieldBreakStatement)">
      <summary>
            Performs some computation with the given yield break statement.
            </summary>
      <param name="yieldBreakStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IYieldBreakStatement)" inheritedFromTypeName="ICodeVisitor">yieldBreakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeVisitor.Visit(Microsoft.Cci.IYieldReturnStatement)">
      <summary>
            Performs some computation with the given yield return statement.
            </summary>
      <param name="yieldReturnStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IYieldReturnStatement)" inheritedFromTypeName="ICodeVisitor">yieldReturnStatement != null</requires>
    </member>
    <member name="T:Microsoft.Cci.CodeTraverser">
      <summary>
            A class that traverses the code and metadata model in depth first, left to right order,
            calling visitors on each model instance in pre-order as well as post-order.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.#ctor">
      <summary>
            A class that traverses the code and metadata model in depth first, left to right order,
            calling visitors on each model instance in pre-order as well as post-order.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IAddition)">
      <summary>
            Traverses the addition.
            </summary>
      <requires>addition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IAddressableExpression)">
      <summary>
            Traverses the addressable expression.
            </summary>
      <requires>addressableExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IAddressDereference)">
      <summary>
            Traverses the address dereference expression.
            </summary>
      <requires>addressDereference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IAddressOf)">
      <summary>
            Traverses the AddressOf expression.
            </summary>
      <requires>addressOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IAnonymousDelegate)">
      <summary>
            Traverses the anonymous delegate expression.
            </summary>
      <requires>anonymousDelegate != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IArrayIndexer)">
      <summary>
            Traverses the array indexer expression.
            </summary>
      <requires>arrayIndexer != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IAssertStatement)">
      <summary>
            Traverses the assert statement.
            </summary>
      <requires>assertStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IAssignment)">
      <summary>
            Traverses the assignment expression.
            </summary>
      <requires>assignment != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IAssumeStatement)">
      <summary>
            Traverses the assume statement.
            </summary>
      <requires>assumeStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IBinaryOperation)">
      <summary>
            Traverses the bitwise and expression.
            </summary>
      <param name="binaryOperation" />
      <requires>binaryOperation != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IBitwiseAnd)">
      <summary>
            Traverses the bitwise and expression.
            </summary>
      <requires>bitwiseAnd != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IBitwiseOr)">
      <summary>
            Traverses the bitwise or expression.
            </summary>
      <requires>bitwiseOr != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IBlockExpression)">
      <summary>
            Traverses the block expression.
            </summary>
      <requires>blockExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IBlockStatement)">
      <summary>
            Traverses the statement block.
            </summary>
      <requires>block != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IBoundExpression)">
      <summary>
            Traverses the bound expression.
            </summary>
      <requires>boundExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IBreakStatement)">
      <summary>
            Traverses the break statement.
            </summary>
      <requires>breakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ICastIfPossible)">
      <summary>
            Traverses the cast-if-possible expression.
            </summary>
      <requires>castIfPossible != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ICatchClause)">
      <summary>
            Traverses the catch clause.
            </summary>
      <requires>catchClause != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ICheckIfInstance)">
      <summary>
            Traverses the check-if-instance expression.
            </summary>
      <requires>checkIfInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ICompileTimeConstant)">
      <summary>
            Traverses the compile time constant.
            </summary>
      <requires>constant != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IConditional)">
      <summary>
            Traverses the conditional expression.
            </summary>
      <requires>conditional != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IConditionalStatement)">
      <summary>
            Traverses the conditional statement.
            </summary>
      <requires>conditionalStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IContinueStatement)">
      <summary>
            Traverses the continue statement.
            </summary>
      <requires>continueStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IConversion)">
      <summary>
            Traverses the conversion expression.
            </summary>
      <requires>conversion != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ICopyMemoryStatement)">
      <summary>
            Traverses the copy memory statement.
            </summary>
      <param name="copyMemoryStatement" />
      <requires>copyMemoryStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ICreateArray)">
      <summary>
            Traverses the array creation expression.
            </summary>
      <requires>createArray != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ICreateDelegateInstance)">
      <summary>
            Traverses the delegate creation expression.
            </summary>
      <requires>createDelegateInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ICreateObjectInstance)">
      <summary>
            Traverses the create object instance expression.
            </summary>
      <requires>createObjectInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IDebuggerBreakStatement)">
      <summary>
            Traverses the debugger break statement.
            </summary>
      <requires>debuggerBreakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IDefaultValue)">
      <summary>
            Traverses the defalut value expression.
            </summary>
      <requires>defaultValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IDivision)">
      <summary>
            Traverses the division expression.
            </summary>
      <requires>division != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IDoUntilStatement)">
      <summary>
            Traverses the do until statement.
            </summary>
      <requires>doUntilStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IDupValue)">
      <summary>
            Traverses the dup value expression.
            </summary>
      <requires>dupValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IEmptyStatement)">
      <summary>
            Traverses the empty statement.
            </summary>
      <requires>emptyStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IEquality)">
      <summary>
            Traverses the equality expression.
            </summary>
      <requires>equality != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IExclusiveOr)">
      <summary>
            Traverses the exclusive or expression.
            </summary>
      <requires>exclusiveOr != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IExpression)">
      <summary>
            Traverses the expression.
            </summary>
      <requires>expression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IExpressionStatement)">
      <summary>
            Traverses the expression statement.
            </summary>
      <requires>expressionStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IFillMemoryStatement)">
      <summary>
            Traverses the fill memory statement.
            </summary>
      <param name="fillMemoryStatement" />
      <requires>fillMemoryStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IForEachStatement)">
      <summary>
            Traverses the foreach statement.
            </summary>
      <requires>forEachStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IForStatement)">
      <summary>
            Traverses the for statement.
            </summary>
      <requires>forStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IGetTypeOfTypedReference)">
      <summary>
            Traverses the get type of typed reference expression.
            </summary>
      <requires>getTypeOfTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IGetValueOfTypedReference)">
      <summary>
            Traverses the get value of typed reference expression.
            </summary>
      <requires>getValueOfTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IGotoStatement)">
      <summary>
            Traverses the goto statement.
            </summary>
      <requires>gotoStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IGotoSwitchCaseStatement)">
      <summary>
            Traverses the goto switch case statement.
            </summary>
      <requires>gotoSwitchCaseStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IGreaterThan)">
      <summary>
            Traverses the greater-than expression.
            </summary>
      <requires>greaterThan != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IGreaterThanOrEqual)">
      <summary>
            Traverses the greater-than-or-equal expression.
            </summary>
      <requires>greaterThanOrEqual != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ILabeledStatement)">
      <summary>
            Traverses the labeled statement.
            </summary>
      <requires>labeledStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ILeftShift)">
      <summary>
            Traverses the left shift expression.
            </summary>
      <requires>leftShift != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ILessThan)">
      <summary>
            Traverses the less-than expression.
            </summary>
      <requires>lessThan != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ILessThanOrEqual)">
      <summary>
            Traverses the less-than-or-equal expression.
            </summary>
      <requires>lessThanOrEqual != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ILocalDeclarationStatement)">
      <summary>
            Traverses the local declaration statement.
            </summary>
      <requires>localDeclarationStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ILockStatement)">
      <summary>
            Traverses the lock statement.
            </summary>
      <requires>lockStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ILogicalNot)">
      <summary>
            Traverses the logical not expression.
            </summary>
      <requires>logicalNot != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IMakeTypedReference)">
      <summary>
            Traverses the make typed reference expression.
            </summary>
      <requires>makeTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IMethodBody)">
      <summary>
            Traverses the the given method body.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.MetadataTraverser.Traverse(Microsoft.Cci.IMethodBody)" inheritedFromTypeName="MetadataTraverser">methodBody != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IMethodCall)">
      <summary>
            Traverses the method call.
            </summary>
      <requires>methodCall != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IModulus)">
      <summary>
            Traverses the modulus expression.
            </summary>
      <requires>modulus != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IMultiplication)">
      <summary>
            Traverses the multiplication expression.
            </summary>
      <requires>multiplication != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.INamedArgument)">
      <summary>
            Traverses the named argument expression.
            </summary>
      <requires>namedArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.INotEquality)">
      <summary>
            Traverses the not equality expression.
            </summary>
      <requires>notEquality != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IOldValue)">
      <summary>
            Traverses the old value expression.
            </summary>
      <requires>oldValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IOnesComplement)">
      <summary>
            Traverses the one's complement expression.
            </summary>
      <requires>onesComplement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IOutArgument)">
      <summary>
            Traverses the out argument expression.
            </summary>
      <requires>outArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IPointerCall)">
      <summary>
            Traverses the pointer call.
            </summary>
      <requires>pointerCall != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IPopValue)">
      <summary>
            Traverses the pop value expression.
            </summary>
      <requires>popValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IPushStatement)">
      <summary>
            Traverses the push statement.
            </summary>
      <requires>pushStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IRefArgument)">
      <summary>
            Traverses the ref argument expression.
            </summary>
      <requires>refArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IResourceUseStatement)">
      <summary>
            Traverses the resource usage statement.
            </summary>
      <requires>resourceUseStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IRethrowStatement)">
      <summary>
            Traverses the rethrow statement.
            </summary>
      <requires>rethrowStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IReturnStatement)">
      <summary>
            Traverses the return statement.
            </summary>
      <requires>returnStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IReturnValue)">
      <summary>
            Traverses the return value expression.
            </summary>
      <requires>returnValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IRightShift)">
      <summary>
            Traverses the right shift expression.
            </summary>
      <requires>rightShift != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IRuntimeArgumentHandleExpression)">
      <summary>
            Traverses the runtime argument handle expression.
            </summary>
      <requires>runtimeArgumentHandleExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ISizeOf)">
      <summary>
            Traverses the sizeof() expression.
            </summary>
      <requires>sizeOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ISourceMethodBody)">
      <summary>
            Traverses the the given source method body.
            </summary>
      <requires>sourceMethodBody != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IStackArrayCreate)">
      <summary>
            Traverses the stack array create expression.
            </summary>
      <requires>stackArrayCreate != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IStatement)">
      <summary>
            Traverses the specified statement.
            </summary>
      <param name="statement">The statement.</param>
      <requires>statement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ISubtraction)">
      <summary>
            Traverses the subtraction expression.
            </summary>
      <requires>subtraction != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ISwitchCase)">
      <summary>
            Traverses the switch case.
            </summary>
      <requires>switchCase != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ISwitchStatement)">
      <summary>
            Traverses the switch statement.
            </summary>
      <requires>switchStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ITargetExpression)">
      <summary>
            Traverses the target expression.
            </summary>
      <requires>targetExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IThisReference)">
      <summary>
            Traverses the this reference expression.
            </summary>
      <requires>thisReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IThrowStatement)">
      <summary>
            Traverses the throw statement.
            </summary>
      <requires>throwStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ITryCatchFinallyStatement)">
      <summary>
            Traverses the try-catch-filter-finally statement.
            </summary>
      <requires>tryCatchFilterFinallyStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ITokenOf)">
      <summary>
            Traverses the tokenof() expression.
            </summary>
      <requires>tokenOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.ITypeOf)">
      <summary>
            Traverses the typeof() expression.
            </summary>
      <requires>typeOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IUnaryNegation)">
      <summary>
            Traverses the unary negation expression.
            </summary>
      <requires>unaryNegation != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IUnaryOperation)">
      <summary>
            Traverses the unary operation expression.
            </summary>
      <param name="unaryOperation" />
      <requires>unaryOperation != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IUnaryPlus)">
      <summary>
            Traverses the unary plus expression.
            </summary>
      <requires>unaryPlus != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IVectorLength)">
      <summary>
            Traverses the vector length expression.
            </summary>
      <requires>vectorLength != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IWhileDoStatement)">
      <summary>
            Traverses the while do statement.
            </summary>
      <requires>whileDoStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IYieldBreakStatement)">
      <summary>
            Traverses the yield break statement.
            </summary>
      <requires>yieldBreakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(Microsoft.Cci.IYieldReturnStatement)">
      <summary>
            Traverses the yield return statement.
            </summary>
      <requires>yieldReturnStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(System.Collections.Generic.IEnumerable{Microsoft.Cci.ICatchClause})">
      <summary>
            Traverses the enumeration of catch clauses.
            </summary>
      <requires>catchClauses != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(System.Collections.Generic.IEnumerable{Microsoft.Cci.IExpression})">
      <summary>
            Traverses the enumeration of expressions.
            </summary>
      <requires>expressions != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(System.Collections.Generic.IEnumerable{Microsoft.Cci.ISwitchCase})">
      <summary>
            Traverses the enumeration of switch cases.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Traverse(System.Collections.Generic.IEnumerable{Microsoft.Cci.IStatement})">
      <summary>
            Traverses the enumeration of statements.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IAddition)">
      <summary>
            Traverses the children of the addition.
            </summary>
      <requires>addition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IAddressableExpression)">
      <summary>
            Traverses the children of the addressable expression.
            </summary>
      <requires>addressableExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IAddressDereference)">
      <summary>
            Traverses the children of the address dereference expression.
            </summary>
      <requires>addressDereference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IAddressOf)">
      <summary>
            Traverses the children of the AddressOf expression.
            </summary>
      <requires>addressOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IAnonymousDelegate)">
      <summary>
            Traverses the children of the anonymous delegate expression.
            </summary>
      <requires>anonymousDelegate != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IArrayIndexer)">
      <summary>
            Traverses the children of the array indexer expression.
            </summary>
      <requires>arrayIndexer != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IAssertStatement)">
      <summary>
            Traverses the children of the assert statement.
            </summary>
      <requires>assertStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IAssignment)">
      <summary>
            Traverses the children of the assignment expression.
            </summary>
      <requires>assignment != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IAssumeStatement)">
      <summary>
            Traverses the children of the assume statement.
            </summary>
      <requires>assumeStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IBinaryOperation)">
      <summary>
            Called whenever a binary operation expression is about to be traversed by a type specific routine.
            This gives the traverser the opportunity to take some uniform action for all binary operation expressions,
            regardless of how the traversal gets to them.
            </summary>
      <requires>binaryOperation != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IBitwiseAnd)">
      <summary>
            Traverses the children of the bitwise and expression.
            </summary>
      <requires>bitwiseAnd != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IBitwiseOr)">
      <summary>
            Traverses the children of the bitwise or expression.
            </summary>
      <requires>bitwiseOr != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IBlockExpression)">
      <summary>
            Traverses the children of the block expression.
            </summary>
      <requires>blockExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IBlockStatement)">
      <summary>
            Traverses the children of the statement block.
            </summary>
      <requires>block != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IBoundExpression)">
      <summary>
            Traverses the children of the bound expression.
            </summary>
      <requires>boundExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IBreakStatement)">
      <summary>
            Traverses the children of the break statement.
            </summary>
      <requires>breakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ICastIfPossible)">
      <summary>
            Traverses the cast-if-possible expression.
            </summary>
      <requires>castIfPossible != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ICatchClause)">
      <summary>
            Traverses the children of the catch clause.
            </summary>
      <requires>catchClause != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ICheckIfInstance)">
      <summary>
            Traverses the children of the check-if-instance expression.
            </summary>
      <requires>checkIfInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ICompileTimeConstant)">
      <summary>
            Traverses the children of the compile time constant.
            </summary>
      <requires>constant != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IConditional)">
      <summary>
            Traverses the children of the conditional expression.
            </summary>
      <requires>conditional != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IConditionalStatement)">
      <summary>
            Traverses the children of the conditional statement.
            </summary>
      <requires>conditionalStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IContinueStatement)">
      <summary>
            Traverses the children of the continue statement.
            </summary>
      <requires>continueStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ICopyMemoryStatement)">
      <summary>
            Traverses the children of the copy memory statement.
            </summary>
      <requires>copyMemoryStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IConversion)">
      <summary>
            Traverses the children of the conversion expression.
            </summary>
      <requires>conversion != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ICreateArray)">
      <summary>
            Traverses the children of the array creation expression.
            </summary>
      <requires>createArray != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ICreateDelegateInstance)">
      <summary>
            Traverses the children the delegate instance creation expression.
            </summary>
      <requires>createDelegateInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ICreateObjectInstance)">
      <summary>
            Traverses the children of the create object instance expression.
            </summary>
      <requires>createObjectInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IDebuggerBreakStatement)">
      <summary>
            Traverses the children of the debugger break statement.
            </summary>
      <requires>debuggerBreakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IDefaultValue)">
      <summary>
            Traverses the children of the defalut value expression.
            </summary>
      <requires>defaultValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IDivision)">
      <summary>
            Traverses the children of the division expression.
            </summary>
      <requires>division != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IDoUntilStatement)">
      <summary>
            Traverses the children of the do until statement.
            </summary>
      <requires>doUntilStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IDupValue)">
      <summary>
            Traverses the children of the dup value expression.
            </summary>
      <requires>dupValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IEmptyStatement)">
      <summary>
            Traverses the children of the empty statement.
            </summary>
      <requires>emptyStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IEquality)">
      <summary>
            Traverses the children of the equality expression.
            </summary>
      <requires>equality != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IExclusiveOr)">
      <summary>
            Traverses the children of the exclusive or expression.
            </summary>
      <requires>exclusiveOr != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IExpression)">
      <summary>
            Called whenever an expression is about to be traversed by a type specific routine.
            This gives the traverser the opportunity to take some uniform action for all expressions,
            regardless of how the traversal gets to them.
            </summary>
      <requires>expression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IExpressionStatement)">
      <summary>
            Traverses the children of the expression statement.
            </summary>
      <requires>expressionStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IFillMemoryStatement)">
      <summary>
            Traverses the children of the fill memory statement.
            </summary>
      <requires>fillMemoryStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IForEachStatement)">
      <summary>
            Traverses the children of the foreach statement.
            </summary>
      <requires>forEachStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IForStatement)">
      <summary>
            Traverses the children of the for statement.
            </summary>
      <requires>forStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IGetTypeOfTypedReference)">
      <summary>
            Traverses the children of the get type of typed reference expression.
            </summary>
      <requires>getTypeOfTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IGetValueOfTypedReference)">
      <summary>
            Traverses the children of the get value of typed reference expression.
            </summary>
      <requires>getValueOfTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IGotoStatement)">
      <summary>
            Traverses the children of the goto statement.
            </summary>
      <requires>gotoStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IGotoSwitchCaseStatement)">
      <summary>
            Traverses the children of the goto switch case statement.
            </summary>
      <requires>gotoSwitchCaseStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IGreaterThan)">
      <summary>
            Traverses the children of the greater-than expression.
            </summary>
      <requires>greaterThan != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IGreaterThanOrEqual)">
      <summary>
            Traverses the children of the greater-than-or-equal expression.
            </summary>
      <requires>greaterThanOrEqual != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ILabeledStatement)">
      <summary>
            Traverses the children of the labeled statement.
            </summary>
      <requires>labeledStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ILeftShift)">
      <summary>
            Traverses the children of the left shift expression.
            </summary>
      <requires>leftShift != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ILessThan)">
      <summary>
            Traverses the children of the less-than expression.
            </summary>
      <requires>lessThan != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ILessThanOrEqual)">
      <summary>
            Traverses the children of the less-than-or-equal expression.
            </summary>
      <requires>lessThanOrEqual != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ILocalDeclarationStatement)">
      <summary>
            Traverses the children of the local declaration statement.
            </summary>
      <requires>localDeclarationStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ILockStatement)">
      <summary>
            Traverses the children of the lock statement.
            </summary>
      <requires>lockStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ILogicalNot)">
      <summary>
            Traverses the children of the logical not expression.
            </summary>
      <requires>logicalNot != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IMakeTypedReference)">
      <summary>
            Traverses the children of the make typed reference expression.
            </summary>
      <requires>makeTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IMethodCall)">
      <summary>
            Traverses the children of the method call.
            </summary>
      <requires>methodCall != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IModulus)">
      <summary>
            Traverses the children of the modulus expression.
            </summary>
      <requires>modulus != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IMultiplication)">
      <summary>
            Traverses the children of the multiplication expression.
            </summary>
      <requires>multiplication != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.INamedArgument)">
      <summary>
            Traverses the children of the named argument expression.
            </summary>
      <requires>namedArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.INotEquality)">
      <summary>
            Traverses the children of the not equality expression.
            </summary>
      <requires>notEquality != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IOldValue)">
      <summary>
            Traverses the children of the old value expression.
            </summary>
      <requires>oldValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IOnesComplement)">
      <summary>
            Traverses the children of the one's complement expression.
            </summary>
      <requires>onesComplement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IOutArgument)">
      <summary>
            Traverses the children of the out argument expression.
            </summary>
      <requires>outArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IPointerCall)">
      <summary>
            Traverses the children of the pointer call.
            </summary>
      <requires>pointerCall != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IPopValue)">
      <summary>
            Traverses the children of the pop value expression.
            </summary>
      <requires>popValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IPushStatement)">
      <summary>
            Traverses the children of the push statement.
            </summary>
      <requires>pushStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IRefArgument)">
      <summary>
            Traverses the children of the ref argument expression.
            </summary>
      <requires>refArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IResourceUseStatement)">
      <summary>
            Traverses the children of the resource usage statement.
            </summary>
      <requires>resourceUseStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IRethrowStatement)">
      <summary>
            Traverses the rethrow statement.
            </summary>
      <requires>rethrowStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IReturnStatement)">
      <summary>
            Traverses the return statement.
            </summary>
      <requires>returnStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IReturnValue)">
      <summary>
            Traverses the children of the return value expression.
            </summary>
      <requires>returnValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IRightShift)">
      <summary>
            Traverses the children of the right shift expression.
            </summary>
      <requires>rightShift != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IRuntimeArgumentHandleExpression)">
      <summary>
            Traverses the children of the runtime argument handle expression.
            </summary>
      <requires>runtimeArgumentHandleExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ISizeOf)">
      <summary>
            Traverses the children of the sizeof() expression.
            </summary>
      <requires>sizeOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ISourceMethodBody)">
      <summary>
            Traverses the the given source method body.
            </summary>
      <requires>sourceMethodBody != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IStackArrayCreate)">
      <summary>
            Traverses the children of the stack array create expression.
            </summary>
      <requires>stackArrayCreate != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IStatement)">
      <summary>
            Called whenever a statement is about to be traversed by a type specific routine.
            This gives the traverser the opportunity to take some uniform action for all statements,
            regardless of how the traversal gets to them.
            </summary>
      <requires>statement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ISubtraction)">
      <summary>
            Traverses the children of the subtraction expression.
            </summary>
      <requires>subtraction != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ISwitchCase)">
      <summary>
            Traverses the children of the switch case.
            </summary>
      <requires>switchCase != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ISwitchStatement)">
      <summary>
            Traverses the children of the switch statement.
            </summary>
      <requires>switchStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ITargetExpression)">
      <summary>
            Traverses the children of the target expression.
            </summary>
      <requires>targetExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IThisReference)">
      <summary>
            Traverses the children of the this reference expression.
            </summary>
      <requires>thisReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IThrowStatement)">
      <summary>
            Traverses the throw statement.
            </summary>
      <requires>throwStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ITryCatchFinallyStatement)">
      <summary>
            Traverses the try-catch-filter-finally statement.
            </summary>
      <requires>tryCatchFilterFinallyStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ITokenOf)">
      <summary>
            Traverses the children of the tokenof() expression.
            </summary>
      <requires>tokenOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.ITypeOf)">
      <summary>
            Traverses the children of the typeof() expression.
            </summary>
      <requires>typeOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IUnaryNegation)">
      <summary>
            Traverses the children of the unary negation expression.
            </summary>
      <requires>unaryNegation != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IUnaryOperation)">
      <summary>
            Called whenever a unary operation expression is about to be traversed by a type specific routine.
            This gives the traverser the opportunity to take some uniform action for all unary operation expressions,
            regardless of how the traversal gets to them.
            </summary>
      <requires>unaryOperation != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IUnaryPlus)">
      <summary>
            Traverses the children of the unary plus expression.
            </summary>
      <requires>unaryPlus != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IVectorLength)">
      <summary>
            Traverses the children of the vector length expression.
            </summary>
      <requires>vectorLength != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IWhileDoStatement)">
      <summary>
            Traverses the children of the while do statement.
            </summary>
      <requires>whileDoStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IYieldBreakStatement)">
      <summary>
            Traverses the children of the yield break statement.
            </summary>
      <requires>yieldBreakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IYieldReturnStatement)">
      <summary>
            Traverses the children of the yield return statement.
            </summary>
      <requires>yieldReturnStatement != null</requires>
    </member>
    <member name="P:Microsoft.Cci.CodeTraverser.PreorderVisitor">
      <summary>
            A visitor that should be called on each object being traversed, before any of its children are traversed. May be null.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.CodeTraverser.PostorderVisitor">
      <summary>
            A visitor that should be called on each object being traversed, after all of its children are traversed. May be null. 
            </summary>
    </member>
    <member name="T:Microsoft.Cci.BaseCodeTraverser">
      <summary>
            A visitor base class that traverses the code model in depth first, left to right order.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.#ctor">
      <summary>
            Allocates a visitor instance that traverses the code model in depth first, left to right order.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IAddition)">
      <summary>
            Traverses the given addition.
            </summary>
      <param name="addition" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddition)" inheritedFromTypeName="ICodeVisitor">addition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IAddressableExpression)">
      <summary>
            Traverses the given addressable expression.
            </summary>
      <param name="addressableExpression" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddressableExpression)" inheritedFromTypeName="ICodeVisitor">addressableExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IAddressDereference)">
      <summary>
            Traverses the given address dereference expression.
            </summary>
      <param name="addressDereference" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddressDereference)" inheritedFromTypeName="ICodeVisitor">addressDereference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IAddressOf)">
      <summary>
            Traverses the given AddressOf expression.
            </summary>
      <param name="addressOf" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddressOf)" inheritedFromTypeName="ICodeVisitor">addressOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IAnonymousDelegate)">
      <summary>
            Traverses the given anonymous delegate expression.
            </summary>
      <param name="anonymousDelegate" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAnonymousDelegate)" inheritedFromTypeName="ICodeVisitor">anonymousDelegate != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IAssertStatement)">
      <summary>
            Traverses the given assert statement.
            </summary>
      <param name="assertStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAssertStatement)" inheritedFromTypeName="ICodeVisitor">assertStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IAssignment})">
      <summary>
            Visits the specified assignments.
            </summary>
      <param name="assignments">The assignments.</param>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IAssignment)">
      <summary>
            Traverses the given assignment expression.
            </summary>
      <param name="assignment" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAssignment)" inheritedFromTypeName="ICodeVisitor">assignment != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IAssumeStatement)">
      <summary>
            Traverses the given assume statement.
            </summary>
      <param name="assumeStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAssumeStatement)" inheritedFromTypeName="ICodeVisitor">assumeStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IBitwiseAnd)">
      <summary>
            Traverses the given bitwise and expression.
            </summary>
      <param name="bitwiseAnd" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBitwiseAnd)" inheritedFromTypeName="ICodeVisitor">bitwiseAnd != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IBitwiseOr)">
      <summary>
            Traverses the given bitwise or expression.
            </summary>
      <param name="bitwiseOr" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBitwiseOr)" inheritedFromTypeName="ICodeVisitor">bitwiseOr != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IBlockExpression)">
      <summary>
            Traverses the given block expression.
            </summary>
      <param name="blockExpression" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBlockExpression)" inheritedFromTypeName="ICodeVisitor">blockExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IBlockStatement)">
      <summary>
            Traverses the given statement block.
            </summary>
      <param name="block" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBlockStatement)" inheritedFromTypeName="ICodeVisitor">block != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ICastIfPossible)">
      <summary>
            Traverses the cast-if-possible expression.
            </summary>
      <param name="castIfPossible" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICastIfPossible)" inheritedFromTypeName="ICodeVisitor">castIfPossible != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.ICatchClause})">
      <summary>
            Visits the specified catch clauses.
            </summary>
      <param name="catchClauses">The catch clauses.</param>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ICatchClause)">
      <summary>
            Traverses the given catch clause.
            </summary>
      <param name="catchClause" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICatchClause)" inheritedFromTypeName="ICodeVisitor">catchClause != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ICheckIfInstance)">
      <summary>
            Traverses the given check-if-instance expression.
            </summary>
      <param name="checkIfInstance" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICheckIfInstance)" inheritedFromTypeName="ICodeVisitor">checkIfInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ICompileTimeConstant)">
      <summary>
            Traverses the given compile time constant.
            </summary>
      <param name="constant" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICompileTimeConstant)" inheritedFromTypeName="ICodeVisitor">constant != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IConversion)">
      <summary>
            Traverses the given conversion expression.
            </summary>
      <param name="conversion" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IConversion)" inheritedFromTypeName="ICodeVisitor">conversion != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IConditional)">
      <summary>
            Traverses the given conditional expression.
            </summary>
      <param name="conditional" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IConditional)" inheritedFromTypeName="ICodeVisitor">conditional != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IConditionalStatement)">
      <summary>
            Traverses the given conditional statement.
            </summary>
      <param name="conditionalStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IConditionalStatement)" inheritedFromTypeName="ICodeVisitor">conditionalStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IContinueStatement)">
      <summary>
            Traverses the given continue statement.
            </summary>
      <param name="continueStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IContinueStatement)" inheritedFromTypeName="ICodeVisitor">continueStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ICopyMemoryStatement)">
      <summary>
            Traverses the given copy memory statement.
            </summary>
      <param name="copyMemoryStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICopyMemoryStatement)" inheritedFromTypeName="ICodeVisitor">copyMemoryStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ICreateArray)">
      <summary>
            Traverses the given array creation expression.
            </summary>
      <param name="createArray" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICreateArray)" inheritedFromTypeName="ICodeVisitor">createArray != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ICreateObjectInstance)">
      <summary>
            Traverses the given constructor call expression.
            </summary>
      <param name="createObjectInstance" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICreateObjectInstance)" inheritedFromTypeName="ICodeVisitor">createObjectInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ICreateDelegateInstance)">
      <summary>
            Traverses the anonymous object creation expression.
            </summary>
      <param name="createDelegateInstance" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICreateDelegateInstance)" inheritedFromTypeName="ICodeVisitor">createDelegateInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IArrayIndexer)">
      <summary>
            Traverses the given array indexer expression.
            </summary>
      <param name="arrayIndexer" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IArrayIndexer)" inheritedFromTypeName="ICodeVisitor">arrayIndexer != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IBoundExpression)">
      <summary>
            Traverses the given bound expression.
            </summary>
      <param name="boundExpression" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBoundExpression)" inheritedFromTypeName="ICodeVisitor">boundExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ICustomAttribute)">
      <summary>
            Traverses the given custom attribute.
            </summary>
      <param name="customAttribute" />
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IDefaultValue)">
      <summary>
            Traverses the given defalut value expression.
            </summary>
      <param name="defaultValue" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDefaultValue)" inheritedFromTypeName="ICodeVisitor">defaultValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IDebuggerBreakStatement)">
      <summary>
            Traverses the given debugger break statement.
            </summary>
      <param name="debuggerBreakStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDebuggerBreakStatement)" inheritedFromTypeName="ICodeVisitor">debuggerBreakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IDivision)">
      <summary>
            Traverses the given division expression.
            </summary>
      <param name="division" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDivision)" inheritedFromTypeName="ICodeVisitor">division != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IDoUntilStatement)">
      <summary>
            Traverses the given do until statement.
            </summary>
      <param name="doUntilStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDoUntilStatement)" inheritedFromTypeName="ICodeVisitor">doUntilStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IDupValue)">
      <summary>
            Traverses the given dup value expression.
            </summary>
      <param name="popValue" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDupValue)" inheritedFromTypeName="ICodeVisitor">dupValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IEmptyStatement)">
      <summary>
            Traverses the given empty statement.
            </summary>
      <param name="emptyStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IEmptyStatement)" inheritedFromTypeName="ICodeVisitor">emptyStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IEquality)">
      <summary>
            Traverses the given equality expression.
            </summary>
      <param name="equality" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IEquality)" inheritedFromTypeName="ICodeVisitor">equality != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IExclusiveOr)">
      <summary>
            Traverses the given exclusive or expression.
            </summary>
      <param name="exclusiveOr" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IExclusiveOr)" inheritedFromTypeName="ICodeVisitor">exclusiveOr != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IExpression})">
      <summary>
            Visits the specified expressions.
            </summary>
      <param name="expressions">The expressions.</param>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IExpression)">
      <summary>
            Traverses the given expression.
            </summary>
      <param name="expression" />
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IExpressionStatement)">
      <summary>
            Traverses the given expression statement.
            </summary>
      <param name="expressionStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IExpressionStatement)" inheritedFromTypeName="ICodeVisitor">expressionStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IFillMemoryStatement)">
      <summary>
            Traverses the given fill memory statement.
            </summary>
      <param name="fillMemoryStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IFillMemoryStatement)" inheritedFromTypeName="ICodeVisitor">fillMemoryStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IForEachStatement)">
      <summary>
            Traverses the given foreach statement.
            </summary>
      <param name="forEachStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IForEachStatement)" inheritedFromTypeName="ICodeVisitor">forEachStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IForStatement)">
      <summary>
            Traverses the given for statement.
            </summary>
      <param name="forStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IForStatement)" inheritedFromTypeName="ICodeVisitor">forStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IGetTypeOfTypedReference)">
      <summary>
            Traverses the given get type of typed reference expression.
            </summary>
      <param name="getTypeOfTypedReference" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGetTypeOfTypedReference)" inheritedFromTypeName="ICodeVisitor">getTypeOfTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IGetValueOfTypedReference)">
      <summary>
            Traverses the given get value of typed reference expression.
            </summary>
      <param name="getValueOfTypedReference" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGetValueOfTypedReference)" inheritedFromTypeName="ICodeVisitor">getValueOfTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IGotoStatement)">
      <summary>
            Traverses the given goto statement.
            </summary>
      <param name="gotoStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGotoStatement)" inheritedFromTypeName="ICodeVisitor">gotoStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IGotoSwitchCaseStatement)">
      <summary>
            Traverses the given goto switch case statement.
            </summary>
      <param name="gotoSwitchCaseStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGotoSwitchCaseStatement)" inheritedFromTypeName="ICodeVisitor">gotoSwitchCaseStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IGreaterThan)">
      <summary>
            Traverses the given greater-than expression.
            </summary>
      <param name="greaterThan" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGreaterThan)" inheritedFromTypeName="ICodeVisitor">greaterThan != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IGreaterThanOrEqual)">
      <summary>
            Traverses the given greater-than-or-equal expression.
            </summary>
      <param name="greaterThanOrEqual" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGreaterThanOrEqual)" inheritedFromTypeName="ICodeVisitor">greaterThanOrEqual != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ILabeledStatement)">
      <summary>
            Traverses the given labeled statement.
            </summary>
      <param name="labeledStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILabeledStatement)" inheritedFromTypeName="ICodeVisitor">labeledStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ILeftShift)">
      <summary>
            Traverses the given left shift expression.
            </summary>
      <param name="leftShift" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILeftShift)" inheritedFromTypeName="ICodeVisitor">leftShift != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ILessThan)">
      <summary>
            Traverses the given less-than expression.
            </summary>
      <param name="lessThan" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILessThan)" inheritedFromTypeName="ICodeVisitor">lessThan != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ILessThanOrEqual)">
      <summary>
            Traverses the given less-than-or-equal expression.
            </summary>
      <param name="lessThanOrEqual" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILessThanOrEqual)" inheritedFromTypeName="ICodeVisitor">lessThanOrEqual != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ILocalDeclarationStatement)">
      <summary>
            Traverses the given local declaration statement.
            </summary>
      <param name="localDeclarationStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILocalDeclarationStatement)" inheritedFromTypeName="ICodeVisitor">localDeclarationStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ILockStatement)">
      <summary>
            Traverses the given lock statement.
            </summary>
      <param name="lockStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILockStatement)" inheritedFromTypeName="ICodeVisitor">lockStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ILogicalNot)">
      <summary>
            Traverses the given logical not expression.
            </summary>
      <param name="logicalNot" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILogicalNot)" inheritedFromTypeName="ICodeVisitor">logicalNot != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IBreakStatement)">
      <summary>
            Traverses the given break statement.
            </summary>
      <param name="breakStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBreakStatement)" inheritedFromTypeName="ICodeVisitor">breakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IMakeTypedReference)">
      <summary>
            Traverses the given make typed reference expression.
            </summary>
      <param name="makeTypedReference" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IMakeTypedReference)" inheritedFromTypeName="ICodeVisitor">makeTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ISourceMethodBody)">
      <summary>
            Visits the specified method body.
            </summary>
      <param name="methodBody">The method body.</param>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IMethodDefinition)">
      <summary>
            Traverses the given method definition.
            </summary>
      <param name="method" />
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IMethodBody)">
      <summary>
            Traverses the given method body.
            </summary>
      <param name="methodBody" />
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IMethodCall)">
      <summary>
            Traverses the given method call.
            </summary>
      <param name="methodCall" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IMethodCall)" inheritedFromTypeName="ICodeVisitor">methodCall != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IModulus)">
      <summary>
            Traverses the given modulus expression.
            </summary>
      <param name="modulus" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IModulus)" inheritedFromTypeName="ICodeVisitor">modulus != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IMultiplication)">
      <summary>
            Traverses the given multiplication expression.
            </summary>
      <param name="multiplication" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IMultiplication)" inheritedFromTypeName="ICodeVisitor">multiplication != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.INamedArgument})">
      <summary>
            Visits the specified named arguments.
            </summary>
      <param name="namedArguments">The named arguments.</param>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.INamedArgument)">
      <summary>
            Traverses the given named argument expression.
            </summary>
      <param name="namedArgument" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.INamedArgument)" inheritedFromTypeName="ICodeVisitor">namedArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.INotEquality)">
      <summary>
            Traverses the given not equality expression.
            </summary>
      <param name="notEquality" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.INotEquality)" inheritedFromTypeName="ICodeVisitor">notEquality != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IOldValue)">
      <summary>
            Traverses the given old value expression.
            </summary>
      <param name="oldValue" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IOldValue)" inheritedFromTypeName="ICodeVisitor">oldValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IOnesComplement)">
      <summary>
            Traverses the given one's complement expression.
            </summary>
      <param name="onesComplement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IOnesComplement)" inheritedFromTypeName="ICodeVisitor">onesComplement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IOutArgument)">
      <summary>
            Traverses the given out argument expression.
            </summary>
      <param name="outArgument" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IOutArgument)" inheritedFromTypeName="ICodeVisitor">outArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IPointerCall)">
      <summary>
            Traverses the given pointer call.
            </summary>
      <param name="pointerCall" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IPointerCall)" inheritedFromTypeName="ICodeVisitor">pointerCall != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IPopValue)">
      <summary>
            Traverses the given pop value expression.
            </summary>
      <param name="popValue" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IPopValue)" inheritedFromTypeName="ICodeVisitor">popValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IPushStatement)">
      <summary>
            Traverses the given push statement.
            </summary>
      <param name="pushStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IPushStatement)" inheritedFromTypeName="ICodeVisitor">pushStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IRefArgument)">
      <summary>
            Traverses the given ref argument expression.
            </summary>
      <param name="refArgument" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRefArgument)" inheritedFromTypeName="ICodeVisitor">refArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IResourceUseStatement)">
      <summary>
            Traverses the given resource usage statement.
            </summary>
      <param name="resourceUseStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IResourceUseStatement)" inheritedFromTypeName="ICodeVisitor">resourceUseStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IRethrowStatement)">
      <summary>
            Traverses the rethrow statement.
            </summary>
      <param name="rethrowStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRethrowStatement)" inheritedFromTypeName="ICodeVisitor">rethrowStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IReturnStatement)">
      <summary>
            Traverses the return statement.
            </summary>
      <param name="returnStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IReturnStatement)" inheritedFromTypeName="ICodeVisitor">returnStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IReturnValue)">
      <summary>
            Traverses the given return value expression.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IReturnValue)" inheritedFromTypeName="ICodeVisitor">returnValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IRightShift)">
      <summary>
            Traverses the given right shift expression.
            </summary>
      <param name="rightShift" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRightShift)" inheritedFromTypeName="ICodeVisitor">rightShift != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IStackArrayCreate)">
      <summary>
            Traverses the given stack array create expression.
            </summary>
      <param name="stackArrayCreate" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IStackArrayCreate)" inheritedFromTypeName="ICodeVisitor">stackArrayCreate != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IRuntimeArgumentHandleExpression)">
      <summary>
            Traverses the given runtime argument handle expression.
            </summary>
      <param name="runtimeArgumentHandleExpression" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRuntimeArgumentHandleExpression)" inheritedFromTypeName="ICodeVisitor">runtimeArgumentHandleExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ISizeOf)">
      <summary>
            Traverses the given sizeof() expression.
            </summary>
      <param name="sizeOf" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISizeOf)" inheritedFromTypeName="ICodeVisitor">sizeOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IStatement})">
      <summary>
            Visits the specified statements.
            </summary>
      <param name="statements">The statements.</param>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IStatement)">
      <summary>
            Visits the specified statement.
            </summary>
      <param name="statement">The statement.</param>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ISubtraction)">
      <summary>
            Traverses the given subtraction expression.
            </summary>
      <param name="subtraction" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISubtraction)" inheritedFromTypeName="ICodeVisitor">subtraction != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.ISwitchCase})">
      <summary>
            Visits the specified switch cases.
            </summary>
      <param name="switchCases">The switch cases.</param>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ISwitchCase)">
      <summary>
            Traverses the given switch case.
            </summary>
      <param name="switchCase" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISwitchCase)" inheritedFromTypeName="ICodeVisitor">switchCase != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ISwitchStatement)">
      <summary>
            Traverses the given switch statement.
            </summary>
      <param name="switchStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISwitchStatement)" inheritedFromTypeName="ICodeVisitor">switchStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ITargetExpression)">
      <summary>
            Traverses the given target expression.
            </summary>
      <param name="targetExpression" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITargetExpression)" inheritedFromTypeName="ICodeVisitor">targetExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IThisReference)">
      <summary>
            Traverses the given this reference expression.
            </summary>
      <param name="thisReference" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IThisReference)" inheritedFromTypeName="ICodeVisitor">thisReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IThrowStatement)">
      <summary>
            Traverses the throw statement.
            </summary>
      <param name="throwStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IThrowStatement)" inheritedFromTypeName="ICodeVisitor">throwStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ITryCatchFinallyStatement)">
      <summary>
            Traverses the try-catch-filter-finally statement.
            </summary>
      <param name="tryCatchFilterFinallyStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITryCatchFinallyStatement)" inheritedFromTypeName="ICodeVisitor">tryCatchFilterFinallyStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ITokenOf)">
      <summary>
            Traverses the given tokenof() expression.
            </summary>
      <param name="tokenOf" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITokenOf)" inheritedFromTypeName="ICodeVisitor">tokenOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.ITypeOf)">
      <summary>
            Traverses the given typeof() expression.
            </summary>
      <param name="typeOf" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITypeOf)" inheritedFromTypeName="ICodeVisitor">typeOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IUnaryNegation)">
      <summary>
            Traverses the given unary negation expression.
            </summary>
      <param name="unaryNegation" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IUnaryNegation)" inheritedFromTypeName="ICodeVisitor">unaryNegation != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IUnaryPlus)">
      <summary>
            Traverses the given unary plus expression.
            </summary>
      <param name="unaryPlus" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IUnaryPlus)" inheritedFromTypeName="ICodeVisitor">unaryPlus != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IVectorLength)">
      <summary>
            Traverses the given vector length expression.
            </summary>
      <param name="vectorLength" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IVectorLength)" inheritedFromTypeName="ICodeVisitor">vectorLength != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IWhileDoStatement)">
      <summary>
            Traverses the given while do statement.
            </summary>
      <param name="whileDoStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IWhileDoStatement)" inheritedFromTypeName="ICodeVisitor">whileDoStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IYieldBreakStatement)">
      <summary>
            Traverses the given yield break statement.
            </summary>
      <param name="yieldBreakStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IYieldBreakStatement)" inheritedFromTypeName="ICodeVisitor">yieldBreakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.Visit(Microsoft.Cci.IYieldReturnStatement)">
      <summary>
            Traverses the given yield return statement.
            </summary>
      <param name="yieldReturnStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IYieldReturnStatement)" inheritedFromTypeName="ICodeVisitor">yieldReturnStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeTraverser.VisitReference(Microsoft.Cci.IPropertyDefinition)">
      <summary>
            Performs some computation on the reference to the given property definition.
            </summary>
      <param name="property">The property definition being referenced.</param>
    </member>
    <member name="T:Microsoft.Cci.BaseCodeVisitor">
      <summary>
            A visitor base class that provides a dummy body for each method of ICodeVisitor.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.#ctor">
      <summary />
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IAddition)">
      <summary>
            Performs some computation with the given addition.
            </summary>
      <param name="addition" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddition)" inheritedFromTypeName="ICodeVisitor">addition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IAddressableExpression)">
      <summary>
            Performs some computation with the given addressable expression.
            </summary>
      <param name="addressableExpression" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddressableExpression)" inheritedFromTypeName="ICodeVisitor">addressableExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IAddressDereference)">
      <summary>
            Performs some computation with the given address dereference expression.
            </summary>
      <param name="addressDereference" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddressDereference)" inheritedFromTypeName="ICodeVisitor">addressDereference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IAddressOf)">
      <summary>
            Performs some computation with the given AddressOf expression.
            </summary>
      <param name="addressOf" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddressOf)" inheritedFromTypeName="ICodeVisitor">addressOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IAnonymousDelegate)">
      <summary>
            Performs some computation with the given anonymous delegate expression.
            </summary>
      <param name="anonymousDelegate" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAnonymousDelegate)" inheritedFromTypeName="ICodeVisitor">anonymousDelegate != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IArrayIndexer)">
      <summary>
            Performs some computation with the given array indexer expression.
            </summary>
      <param name="arrayIndexer" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IArrayIndexer)" inheritedFromTypeName="ICodeVisitor">arrayIndexer != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IAssertStatement)">
      <summary>
            Performs some computation with the given assert statement.
            </summary>
      <param name="assertStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAssertStatement)" inheritedFromTypeName="ICodeVisitor">assertStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IAssignment})">
      <summary>
            Visits the specified assignments.
            </summary>
      <param name="assignments">The assignments.</param>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IAssignment)">
      <summary>
            Performs some computation with the given assignment expression.
            </summary>
      <param name="assignment" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAssignment)" inheritedFromTypeName="ICodeVisitor">assignment != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IAssumeStatement)">
      <summary>
            Performs some computation with the given assume statement.
            </summary>
      <param name="assumeStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAssumeStatement)" inheritedFromTypeName="ICodeVisitor">assumeStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IBitwiseAnd)">
      <summary>
            Performs some computation with the given bitwise and expression.
            </summary>
      <param name="bitwiseAnd" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBitwiseAnd)" inheritedFromTypeName="ICodeVisitor">bitwiseAnd != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IBitwiseOr)">
      <summary>
            Performs some computation with the given bitwise or expression.
            </summary>
      <param name="bitwiseOr" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBitwiseOr)" inheritedFromTypeName="ICodeVisitor">bitwiseOr != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IBlockExpression)">
      <summary>
            Performs some computation with the given block expression.
            </summary>
      <param name="blockExpression" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBlockExpression)" inheritedFromTypeName="ICodeVisitor">blockExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IBlockStatement)">
      <summary>
            Performs some computation with the given statement block.
            </summary>
      <param name="block" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBlockStatement)" inheritedFromTypeName="ICodeVisitor">block != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IBreakStatement)">
      <summary>
            Performs some computation with the given break statement.
            </summary>
      <param name="breakStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBreakStatement)" inheritedFromTypeName="ICodeVisitor">breakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ICastIfPossible)">
      <summary>
            Performs some computation with the cast-if-possible expression.
            </summary>
      <param name="castIfPossible" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICastIfPossible)" inheritedFromTypeName="ICodeVisitor">castIfPossible != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.ICatchClause})">
      <summary>
            Visits the specified catch clauses.
            </summary>
      <param name="catchClauses">The catch clauses.</param>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ICatchClause)">
      <summary>
            Performs some computation with the given catch clause.
            </summary>
      <param name="catchClause" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICatchClause)" inheritedFromTypeName="ICodeVisitor">catchClause != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ICheckIfInstance)">
      <summary>
            Performs some computation with the given check-if-instance expression.
            </summary>
      <param name="checkIfInstance" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICheckIfInstance)" inheritedFromTypeName="ICodeVisitor">checkIfInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ICompileTimeConstant)">
      <summary>
            Performs some computation with the given compile time constant.
            </summary>
      <param name="constant" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICompileTimeConstant)" inheritedFromTypeName="ICodeVisitor">constant != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IConversion)">
      <summary>
            Performs some computation with the given conversion expression.
            </summary>
      <param name="conversion" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IConversion)" inheritedFromTypeName="ICodeVisitor">conversion != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IConditional)">
      <summary>
            Performs some computation with the given conditional expression.
            </summary>
      <param name="conditional" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IConditional)" inheritedFromTypeName="ICodeVisitor">conditional != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IConditionalStatement)">
      <summary>
            Performs some computation with the given conditional statement.
            </summary>
      <param name="conditionalStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IConditionalStatement)" inheritedFromTypeName="ICodeVisitor">conditionalStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IContinueStatement)">
      <summary>
            Performs some computation with the given continue statement.
            </summary>
      <param name="continueStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IContinueStatement)" inheritedFromTypeName="ICodeVisitor">continueStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ICopyMemoryStatement)">
      <summary>
            Performs some computation with the given copy memory statement.
            </summary>
      <param name="copyMemoryStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICopyMemoryStatement)" inheritedFromTypeName="ICodeVisitor">copyMemoryStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ICreateArray)">
      <summary>
            Performs some computation with the given array creation expression.
            </summary>
      <param name="createArray" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICreateArray)" inheritedFromTypeName="ICodeVisitor">createArray != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ICreateObjectInstance)">
      <summary>
            Performs some computation with the given constructor call expression.
            </summary>
      <param name="createObjectInstance" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICreateObjectInstance)" inheritedFromTypeName="ICodeVisitor">createObjectInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ICreateDelegateInstance)">
      <summary>
            Performs some computation with the anonymous object creation expression.
            </summary>
      <param name="createDelegateInstance" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICreateDelegateInstance)" inheritedFromTypeName="ICodeVisitor">createDelegateInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IDefaultValue)">
      <summary>
            Performs some computation with the given defalut value expression.
            </summary>
      <param name="defaultValue" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDefaultValue)" inheritedFromTypeName="ICodeVisitor">defaultValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IDivision)">
      <summary>
            Performs some computation with the given division expression.
            </summary>
      <param name="division" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDivision)" inheritedFromTypeName="ICodeVisitor">division != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IDoUntilStatement)">
      <summary>
            Performs some computation with the given do until statement.
            </summary>
      <param name="doUntilStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDoUntilStatement)" inheritedFromTypeName="ICodeVisitor">doUntilStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IDupValue)">
      <summary>
            Performs some computation with the given dup value expression.
            </summary>
      <param name="dupValue" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDupValue)" inheritedFromTypeName="ICodeVisitor">dupValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IEmptyStatement)">
      <summary>
            Performs some computation with the given empty statement.
            </summary>
      <param name="emptyStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IEmptyStatement)" inheritedFromTypeName="ICodeVisitor">emptyStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IEquality)">
      <summary>
            Performs some computation with the given equality expression.
            </summary>
      <param name="equality" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IEquality)" inheritedFromTypeName="ICodeVisitor">equality != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IExclusiveOr)">
      <summary>
            Performs some computation with the given exclusive or expression.
            </summary>
      <param name="exclusiveOr" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IExclusiveOr)" inheritedFromTypeName="ICodeVisitor">exclusiveOr != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IBoundExpression)">
      <summary>
            Performs some computation with the given bound expression.
            </summary>
      <param name="boundExpression" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBoundExpression)" inheritedFromTypeName="ICodeVisitor">boundExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IDebuggerBreakStatement)">
      <summary>
            Performs some computation with the given debugger break statement.
            </summary>
      <param name="debuggerBreakStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDebuggerBreakStatement)" inheritedFromTypeName="ICodeVisitor">debuggerBreakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IExpression)">
      <summary>
            Performs some computation with the given expression.
            </summary>
      <param name="expression" />
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IExpressionStatement)">
      <summary>
            Performs some computation with the given expression statement.
            </summary>
      <param name="expressionStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IExpressionStatement)" inheritedFromTypeName="ICodeVisitor">expressionStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IFillMemoryStatement)">
      <summary>
            Performs some computation with the given fill memory block statement.
            </summary>
      <param name="fillMemoryStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IFillMemoryStatement)" inheritedFromTypeName="ICodeVisitor">fillMemoryStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IForEachStatement)">
      <summary>
            Performs some computation with the given foreach statement.
            </summary>
      <param name="forEachStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IForEachStatement)" inheritedFromTypeName="ICodeVisitor">forEachStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IForStatement)">
      <summary>
            Performs some computation with the given for statement.
            </summary>
      <param name="forStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IForStatement)" inheritedFromTypeName="ICodeVisitor">forStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IGetTypeOfTypedReference)">
      <summary>
            Performs some computation with the given get type of typed reference expression.
            </summary>
      <param name="getTypeOfTypedReference" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGetTypeOfTypedReference)" inheritedFromTypeName="ICodeVisitor">getTypeOfTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IGetValueOfTypedReference)">
      <summary>
            Performs some computation with the given get value of typed reference expression.
            </summary>
      <param name="getValueOfTypedReference" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGetValueOfTypedReference)" inheritedFromTypeName="ICodeVisitor">getValueOfTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IGotoStatement)">
      <summary>
            Performs some computation with the given goto statement.
            </summary>
      <param name="gotoStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGotoStatement)" inheritedFromTypeName="ICodeVisitor">gotoStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IGotoSwitchCaseStatement)">
      <summary>
            Performs some computation with the given goto switch case statement.
            </summary>
      <param name="gotoSwitchCaseStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGotoSwitchCaseStatement)" inheritedFromTypeName="ICodeVisitor">gotoSwitchCaseStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IGreaterThan)">
      <summary>
            Performs some computation with the given greater-than expression.
            </summary>
      <param name="greaterThan" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGreaterThan)" inheritedFromTypeName="ICodeVisitor">greaterThan != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IGreaterThanOrEqual)">
      <summary>
            Performs some computation with the given greater-than-or-equal expression.
            </summary>
      <param name="greaterThanOrEqual" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGreaterThanOrEqual)" inheritedFromTypeName="ICodeVisitor">greaterThanOrEqual != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ILabeledStatement)">
      <summary>
            Performs some computation with the given labeled statement.
            </summary>
      <param name="labeledStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILabeledStatement)" inheritedFromTypeName="ICodeVisitor">labeledStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ILeftShift)">
      <summary>
            Performs some computation with the given left shift expression.
            </summary>
      <param name="leftShift" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILeftShift)" inheritedFromTypeName="ICodeVisitor">leftShift != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ILessThan)">
      <summary>
            Performs some computation with the given less-than expression.
            </summary>
      <param name="lessThan" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILessThan)" inheritedFromTypeName="ICodeVisitor">lessThan != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ILessThanOrEqual)">
      <summary>
            Performs some computation with the given less-than-or-equal expression.
            </summary>
      <param name="lessThanOrEqual" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILessThanOrEqual)" inheritedFromTypeName="ICodeVisitor">lessThanOrEqual != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ILocalDeclarationStatement)">
      <summary>
            Performs some computation with the given local declaration statement.
            </summary>
      <param name="localDeclarationStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILocalDeclarationStatement)" inheritedFromTypeName="ICodeVisitor">localDeclarationStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ILockStatement)">
      <summary>
            Performs some computation with the given lock statement.
            </summary>
      <param name="lockStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILockStatement)" inheritedFromTypeName="ICodeVisitor">lockStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ILogicalNot)">
      <summary>
            Performs some computation with the given logical not expression.
            </summary>
      <param name="logicalNot" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILogicalNot)" inheritedFromTypeName="ICodeVisitor">logicalNot != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IMakeTypedReference)">
      <summary>
            Performs some computation with the given make typed reference expression.
            </summary>
      <param name="makeTypedReference" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IMakeTypedReference)" inheritedFromTypeName="ICodeVisitor">makeTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IMethodCall)">
      <summary>
            Performs some computation with the given method call.
            </summary>
      <param name="methodCall" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IMethodCall)" inheritedFromTypeName="ICodeVisitor">methodCall != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IModulus)">
      <summary>
            Performs some computation with the given modulus expression.
            </summary>
      <param name="modulus" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IModulus)" inheritedFromTypeName="ICodeVisitor">modulus != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IMultiplication)">
      <summary>
            Performs some computation with the given multiplication expression.
            </summary>
      <param name="multiplication" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IMultiplication)" inheritedFromTypeName="ICodeVisitor">multiplication != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.INamedArgument})">
      <summary>
            Visits the specified named arguments.
            </summary>
      <param name="namedArguments">The named arguments.</param>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.INamedArgument)">
      <summary>
            Performs some computation with the given named argument expression.
            </summary>
      <param name="namedArgument" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.INamedArgument)" inheritedFromTypeName="ICodeVisitor">namedArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.INotEquality)">
      <summary>
            Performs some computation with the given not equality expression.
            </summary>
      <param name="notEquality" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.INotEquality)" inheritedFromTypeName="ICodeVisitor">notEquality != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IOldValue)">
      <summary>
            Performs some computation with the given old value expression.
            </summary>
      <param name="oldValue" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IOldValue)" inheritedFromTypeName="ICodeVisitor">oldValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IOnesComplement)">
      <summary>
            Performs some computation with the given one's complement expression.
            </summary>
      <param name="onesComplement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IOnesComplement)" inheritedFromTypeName="ICodeVisitor">onesComplement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IOutArgument)">
      <summary>
            Performs some computation with the given out argument expression.
            </summary>
      <param name="outArgument" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IOutArgument)" inheritedFromTypeName="ICodeVisitor">outArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IPointerCall)">
      <summary>
            Performs some computation with the given pointer call.
            </summary>
      <param name="pointerCall" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IPointerCall)" inheritedFromTypeName="ICodeVisitor">pointerCall != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IPopValue)">
      <summary>
            Performs some computation with the given pop value expression.
            </summary>
      <param name="popValue" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IPopValue)" inheritedFromTypeName="ICodeVisitor">popValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IPushStatement)">
      <summary>
            Performs some computation with the given push statement.
            </summary>
      <param name="pushStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IPushStatement)" inheritedFromTypeName="ICodeVisitor">pushStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IRefArgument)">
      <summary>
            Performs some computation with the given ref argument expression.
            </summary>
      <param name="refArgument" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRefArgument)" inheritedFromTypeName="ICodeVisitor">refArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IResourceUseStatement)">
      <summary>
            Performs some computation with the given resource usage statement.
            </summary>
      <param name="resourceUseStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IResourceUseStatement)" inheritedFromTypeName="ICodeVisitor">resourceUseStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IRethrowStatement)">
      <summary>
            Performs some computation with the rethrow statement.
            </summary>
      <param name="rethrowStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRethrowStatement)" inheritedFromTypeName="ICodeVisitor">rethrowStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IReturnStatement)">
      <summary>
            Performs some computation with the return statement.
            </summary>
      <param name="returnStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IReturnStatement)" inheritedFromTypeName="ICodeVisitor">returnStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IReturnValue)">
      <summary>
            Performs some computation with the given return value expression.
            </summary>
      <param name="returnValue" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IReturnValue)" inheritedFromTypeName="ICodeVisitor">returnValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IRightShift)">
      <summary>
            Performs some computation with the given right shift expression.
            </summary>
      <param name="rightShift" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRightShift)" inheritedFromTypeName="ICodeVisitor">rightShift != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IStackArrayCreate)">
      <summary>
            Performs some computation with the given stack array create expression.
            </summary>
      <param name="stackArrayCreate" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IStackArrayCreate)" inheritedFromTypeName="ICodeVisitor">stackArrayCreate != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IRuntimeArgumentHandleExpression)">
      <summary>
            Performs some computation with the given runtime argument handle expression.
            </summary>
      <param name="runtimeArgumentHandleExpression" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRuntimeArgumentHandleExpression)" inheritedFromTypeName="ICodeVisitor">runtimeArgumentHandleExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ISizeOf)">
      <summary>
            Performs some computation with the given sizeof() expression.
            </summary>
      <param name="sizeOf" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISizeOf)" inheritedFromTypeName="ICodeVisitor">sizeOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IStatement})">
      <summary>
            Visits the specified statements.
            </summary>
      <param name="statements">The statements.</param>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IStatement)">
      <summary>
            Visits the specified statement.
            </summary>
      <param name="statement">The statement.</param>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ISubtraction)">
      <summary>
            Performs some computation with the given subtraction expression.
            </summary>
      <param name="subtraction" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISubtraction)" inheritedFromTypeName="ICodeVisitor">subtraction != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.ISwitchCase})">
      <summary>
            Visits the specified switch cases.
            </summary>
      <param name="switchCases">The switch cases.</param>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ISwitchCase)">
      <summary>
            Performs some computation with the given switch case.
            </summary>
      <param name="switchCase" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISwitchCase)" inheritedFromTypeName="ICodeVisitor">switchCase != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ISwitchStatement)">
      <summary>
            Performs some computation with the given switch statement.
            </summary>
      <param name="switchStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISwitchStatement)" inheritedFromTypeName="ICodeVisitor">switchStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ITargetExpression)">
      <summary>
            Performs some computation with the given target expression.
            </summary>
      <param name="targetExpression" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITargetExpression)" inheritedFromTypeName="ICodeVisitor">targetExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IThisReference)">
      <summary>
            Performs some computation with the given this reference expression.
            </summary>
      <param name="thisReference" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IThisReference)" inheritedFromTypeName="ICodeVisitor">thisReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IThrowStatement)">
      <summary>
            Performs some computation with the throw statement.
            </summary>
      <param name="throwStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IThrowStatement)" inheritedFromTypeName="ICodeVisitor">throwStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ITryCatchFinallyStatement)">
      <summary>
            Performs some computation with the try-catch-filter-finally statement.
            </summary>
      <param name="tryCatchFilterFinallyStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITryCatchFinallyStatement)" inheritedFromTypeName="ICodeVisitor">tryCatchFilterFinallyStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ITokenOf)">
      <summary>
            Performs some computation with the given tokenof() expression.
            </summary>
      <param name="tokenOf" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITokenOf)" inheritedFromTypeName="ICodeVisitor">tokenOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.ITypeOf)">
      <summary>
            Performs some computation with the given typeof() expression.
            </summary>
      <param name="typeOf" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITypeOf)" inheritedFromTypeName="ICodeVisitor">typeOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IUnaryNegation)">
      <summary>
            Performs some computation with the given unary negation expression.
            </summary>
      <param name="unaryNegation" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IUnaryNegation)" inheritedFromTypeName="ICodeVisitor">unaryNegation != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IUnaryPlus)">
      <summary>
            Performs some computation with the given unary plus expression.
            </summary>
      <param name="unaryPlus" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IUnaryPlus)" inheritedFromTypeName="ICodeVisitor">unaryPlus != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IVectorLength)">
      <summary>
            Performs some computation with the given vector length expression.
            </summary>
      <param name="vectorLength" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IVectorLength)" inheritedFromTypeName="ICodeVisitor">vectorLength != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IWhileDoStatement)">
      <summary>
            Performs some computation with the given while do statement.
            </summary>
      <param name="whileDoStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IWhileDoStatement)" inheritedFromTypeName="ICodeVisitor">whileDoStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IYieldBreakStatement)">
      <summary>
            Performs some computation with the given yield break statement.
            </summary>
      <param name="yieldBreakStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IYieldBreakStatement)" inheritedFromTypeName="ICodeVisitor">yieldBreakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.BaseCodeVisitor.Visit(Microsoft.Cci.IYieldReturnStatement)">
      <summary>
            Performs some computation with the given yield return statement.
            </summary>
      <param name="yieldReturnStatement" />
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IYieldReturnStatement)" inheritedFromTypeName="ICodeVisitor">yieldReturnStatement != null</requires>
    </member>
    <member name="T:Microsoft.Cci.Contracts.ICodeAndContractVisitor">
      <summary>
            Implemented by classes that visit nodes of object graphs via a double dispatch mechanism, usually performing some computation of a subset of the nodes in the graph.
            Contains a specialized Visit routine for each standard type of object defined in the contract object model. 
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ILoopContract)">
      <summary>
            Performs some computation with the given loop contract.
            </summary>
      <requires>loopContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ILoopInvariant)">
      <summary>
            Performs some computation with the given loop invariant.
            </summary>
      <requires>loopInvariant != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IMethodContract)">
      <summary>
            Performs some computation with the given method contract.
            </summary>
      <requires>methodContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IPostcondition)">
      <summary>
            Performs some computation with the given postCondition.
            </summary>
      <requires>postCondition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IPrecondition)">
      <summary>
            Performs some computation with the given pre condition.
            </summary>
      <requires>precondition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IThrownException)">
      <summary>
            Performs some computation with the given thrown exception.
            </summary>
      <requires>thrownException != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ITypeContract)">
      <summary>
            Performs some computation with the given type contract.
            </summary>
      <requires>typeContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ITypeInvariant)">
      <summary>
            Performs some computation with the given type invariant.
            </summary>
      <requires>typeInvariant != null</requires>
    </member>
    <member name="T:Microsoft.Cci.Contracts.CodeAndContractVisitor">
      <summary>
            Contains a specialized Visit routine for each standard type of object defined in the contract, code and metadata model. 
            </summary>
    </member>
    <member name="F:Microsoft.Cci.Contracts.CodeAndContractVisitor.contractProvider">
      <summary>
            A map from code model objects to contract objects.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractVisitor.#ctor(Microsoft.Cci.Contracts.IContractProvider)">
      <summary>
            Contains a specialized Visit routine for each standard type of object defined in the contract, code and metadata model. 
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IContractElement)">
      <summary>
            Visits the given contract element.
            </summary>
      <param name="contractElement" />
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ILoopContract)">
      <summary>
            Visits the given loop contract.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ILoopContract)" inheritedFromTypeName="ICodeAndContractVisitor">loopContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ILoopInvariant)">
      <summary>
            Visits the given loop invariant.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ILoopInvariant)" inheritedFromTypeName="ICodeAndContractVisitor">loopInvariant != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IMethodContract)">
      <summary>
            Visits the given method contract.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IMethodContract)" inheritedFromTypeName="ICodeAndContractVisitor">methodContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IPostcondition)">
      <summary>
            Visits the given postCondition.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IPostcondition)" inheritedFromTypeName="ICodeAndContractVisitor">postCondition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IPrecondition)">
      <summary>
            Visits the given precondition.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IPrecondition)" inheritedFromTypeName="ICodeAndContractVisitor">precondition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IThrownException)">
      <summary>
            Visits the given thrown exception.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IThrownException)" inheritedFromTypeName="ICodeAndContractVisitor">thrownException != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ITypeContract)">
      <summary>
            Visits the given type contract.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ITypeContract)" inheritedFromTypeName="ICodeAndContractVisitor">typeContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ITypeInvariant)">
      <summary>
            Visits the given type invariant.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ITypeInvariant)" inheritedFromTypeName="ICodeAndContractVisitor">typeInvariant != null</requires>
    </member>
    <member name="T:Microsoft.Cci.Contracts.CodeAndContractTraverser">
      <summary>
            A class that traverses the contract, code and metadata models in depth first, left to right order.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.#ctor(Microsoft.Cci.Contracts.IContractProvider)">
      <summary>
            A class that traverses the contract, code and metadata models in depth first, left to right order.
            </summary>
    </member>
    <member name="F:Microsoft.Cci.Contracts.CodeAndContractTraverser.contractProvider">
      <summary>
            A map from code model objects to contract objects.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.Traverse(Microsoft.Cci.Contracts.IContractElement)">
      <summary>
            Traverses the contract element.
            </summary>
      <requires>contractElement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.Traverse(System.Collections.Generic.IEnumerable{Microsoft.Cci.IAddressableExpression})">
      <summary>
            Traverses the enumeration of addressable expressions.
            </summary>
      <requires>addressableExpressions != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.Traverse(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Microsoft.Cci.IExpression}})">
      <summary>
            Traverses the enumeration of trigger expressions.
            </summary>
      <requires>triggers != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.Traverse(System.Collections.Generic.IEnumerable{Microsoft.Cci.Contracts.ILoopInvariant})">
      <summary>
            Traverses the enumeration of loop invariants.
            </summary>
      <requires>loopInvariants != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.Traverse(System.Collections.Generic.IEnumerable{Microsoft.Cci.Contracts.IPostcondition})">
      <summary>
            Traverses the enumeration of post conditions.
            </summary>
      <requires>postConditions != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.Traverse(System.Collections.Generic.IEnumerable{Microsoft.Cci.Contracts.IPrecondition})">
      <summary>
            Traverses the enumeration of pre conditions.
            </summary>
      <requires>preconditions != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.Traverse(System.Collections.Generic.IEnumerable{Microsoft.Cci.Contracts.IThrownException})">
      <summary>
            Traverses the enumeration of thrown exceptions.
            </summary>
      <requires>thrownExceptions != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.Traverse(System.Collections.Generic.IEnumerable{Microsoft.Cci.Contracts.ITypeInvariant})">
      <summary>
            Traverses the enumeration of addressable expressions.
            </summary>
      <requires>typeInvariants != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.Traverse(Microsoft.Cci.Contracts.ILoopContract)">
      <summary>
            Traverses the loop contract.
            </summary>
      <requires>loopContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.Traverse(Microsoft.Cci.Contracts.ILoopInvariant)">
      <summary>
            Traverses the loop invariant.
            </summary>
      <requires>loopInvariant != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.Traverse(Microsoft.Cci.Contracts.IMethodContract)">
      <summary>
            Traverses the method contract.
            </summary>
      <requires>methodContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.Traverse(Microsoft.Cci.Contracts.IPostcondition)">
      <summary>
            Traverses the postCondition.
            </summary>
      <requires>postCondition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.Traverse(Microsoft.Cci.Contracts.IPrecondition)">
      <summary>
            Traverses the pre condition.
            </summary>
      <requires>precondition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.Traverse(Microsoft.Cci.Contracts.IThrownException)">
      <summary>
            Traverses the thrown exception.
            </summary>
      <requires>thrownException != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.Traverse(Microsoft.Cci.Contracts.ITypeContract)">
      <summary>
            Traverses the type contract.
            </summary>
      <requires>typeContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.Traverse(Microsoft.Cci.Contracts.ITypeInvariant)">
      <summary>
            Traverses the type invariant.
            </summary>
      <requires>typeInvariant != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.TraverseChildren(Microsoft.Cci.Contracts.IContractElement)">
      <summary>
            Called whenever a contract element is about to be traversed by a type specific routine.
            This gives the traverser the opportunity to take some uniform action for all contract elements,
            regardless of how the traversal gets to them.
            </summary>
      <requires>contractElement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.TraverseChildren(Microsoft.Cci.Contracts.ILoopContract)">
      <summary>
            Traverses the children of the loop contract.
            </summary>
      <requires>loopContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.TraverseChildren(Microsoft.Cci.Contracts.ILoopInvariant)">
      <summary>
            Traverses the children of the loop invariant.
            </summary>
      <requires>loopInvariant != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.TraverseChildren(Microsoft.Cci.IMethodCall)">
      <summary>
            Traverses the children of the method call.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IMethodCall)" inheritedFromTypeName="CodeTraverser">methodCall != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.TraverseChildren(Microsoft.Cci.Contracts.IMethodContract)">
      <summary>
            Traverses the children of the method contract.
            </summary>
      <requires>methodContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.TraverseChildren(Microsoft.Cci.IMethodDefinition)">
      <summary>
            Traverses the children of the method definition.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.MetadataTraverser.TraverseChildren(Microsoft.Cci.IMethodDefinition)" inheritedFromTypeName="MetadataTraverser">method != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.TraverseChildren(Microsoft.Cci.Contracts.IPostcondition)">
      <summary>
            Traverses the children of the postCondition.
            </summary>
      <requires>postCondition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.TraverseChildren(Microsoft.Cci.Contracts.IPrecondition)">
      <summary>
            Traverses the children of the pre condition.
            </summary>
      <requires>precondition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.TraverseChildren(Microsoft.Cci.IStatement)">
      <summary>
            Traverses the children of the statement.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.CodeTraverser.TraverseChildren(Microsoft.Cci.IStatement)" inheritedFromTypeName="CodeTraverser">statement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.TraverseChildren(Microsoft.Cci.Contracts.IThrownException)">
      <summary>
            Traverses the children of the thrown exception.
            </summary>
      <requires>thrownException != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.TraverseChildren(Microsoft.Cci.Contracts.ITypeContract)">
      <summary>
            Traverses the children of the type contract.
            </summary>
      <requires>typeContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.TraverseChildren(Microsoft.Cci.ITypeDefinition)">
      <summary>
            Traverses the children of the type definition.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.MetadataTraverser.TraverseChildren(Microsoft.Cci.ITypeDefinition)" inheritedFromTypeName="MetadataTraverser">typeDefinition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.TraverseChildren(Microsoft.Cci.Contracts.ITypeInvariant)">
      <summary>
            Traverses the children of the type invariant.
            </summary>
      <requires>typeInvariant != null</requires>
    </member>
    <member name="P:Microsoft.Cci.Contracts.CodeAndContractTraverser.PreorderVisitor">
      <summary>
            A visitor that should be called on each object being traversed, before any of its children are traversed. May be null.
            </summary>
    </member>
    <member name="P:Microsoft.Cci.Contracts.CodeAndContractTraverser.PostorderVisitor">
      <summary>
            A visitor that should be called on each object being traversed, after all of its children are traversed. May be null. 
            </summary>
    </member>
    <member name="T:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser">
      <summary>
            A visitor base class that traverses a code model in depth first, left to right order.
            </summary>
    </member>
    <member name="F:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.contractProvider">
      <summary>
            A map from code model objects to contract objects.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.#ctor(Microsoft.Cci.Contracts.IContractProvider)">
      <summary>
            Allocates a visitor that traverses a code model model in depth first, left to right order.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.IAddressableExpression})">
      <summary>
            Traverses the given list of addressable expressions.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Microsoft.Cci.IExpression}})">
      <summary>
            Traverses the given list of trigger expressions.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(Microsoft.Cci.IExpression)">
      <summary>
            Traverses the given expression and any triggers that hang of it.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(Microsoft.Cci.Contracts.ILoopContract)">
      <summary>
            Traverses the given loop contract.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ILoopContract)" inheritedFromTypeName="ICodeAndContractVisitor">loopContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.Contracts.ILoopInvariant})">
      <summary>
            Traverses the given list of loop invariants.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(Microsoft.Cci.Contracts.ILoopInvariant)">
      <summary>
            Traverses the given loop invariant.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ILoopInvariant)" inheritedFromTypeName="ICodeAndContractVisitor">loopInvariant != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(Microsoft.Cci.Contracts.IMethodContract)">
      <summary>
            Traverses the given method contract.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IMethodContract)" inheritedFromTypeName="ICodeAndContractVisitor">methodContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.Contracts.IPostcondition})">
      <summary>
            Traverses the given list of post conditions.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(Microsoft.Cci.Contracts.IPostcondition)">
      <summary>
            Traverses the given postCondition.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IPostcondition)" inheritedFromTypeName="ICodeAndContractVisitor">postCondition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.Contracts.IPrecondition})">
      <summary>
            Traverses the given list of pre conditions.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(Microsoft.Cci.Contracts.IPrecondition)">
      <summary>
            Traverses the given pre condition.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IPrecondition)" inheritedFromTypeName="ICodeAndContractVisitor">precondition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(Microsoft.Cci.IStatement)">
      <summary>
            Traverses the given statement.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.Contracts.IThrownException})">
      <summary>
            Traverses the given list of thrown exceptions.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(Microsoft.Cci.Contracts.IThrownException)">
      <summary>
            Traverses the given thrown exception.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IThrownException)" inheritedFromTypeName="ICodeAndContractVisitor">thrownException != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(Microsoft.Cci.Contracts.ITypeContract)">
      <summary>
            Traverses the given type contract.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ITypeContract)" inheritedFromTypeName="ICodeAndContractVisitor">typeContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(System.Collections.Generic.IEnumerable{Microsoft.Cci.Contracts.ITypeInvariant})">
      <summary>
            Traverses the given list of addressable expressions.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(Microsoft.Cci.Contracts.ITypeInvariant)">
      <summary>
            Traverses the given type invariant.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ITypeInvariant)" inheritedFromTypeName="ICodeAndContractVisitor">typeInvariant != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(Microsoft.Cci.IMethodDefinition)">
      <summary>
            Traverses the given method definition.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractTraverser.Visit(Microsoft.Cci.ITypeDefinition)">
      <summary>
            Traverses the given type definition.
            </summary>
    </member>
    <member name="T:Microsoft.Cci.Contracts.BaseCodeAndContractVisitor">
      <summary>
            A visitor base class that provides a dummy body for each method of ICodeAndContractVisitor.
            </summary>
    </member>
    <member name="F:Microsoft.Cci.Contracts.BaseCodeAndContractVisitor.contractProvider">
      <summary>
            A map from code model objects to contract objects.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractVisitor.#ctor(Microsoft.Cci.Contracts.IContractProvider)">
      <summary>
            Allocates a visitor that traverses a code model model in depth first, left to right order.
            </summary>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ILoopContract)">
      <summary>
            Visits the given loop contract.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ILoopContract)" inheritedFromTypeName="ICodeAndContractVisitor">loopContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ILoopInvariant)">
      <summary>
            Visits the given loop invariant.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ILoopInvariant)" inheritedFromTypeName="ICodeAndContractVisitor">loopInvariant != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IMethodContract)">
      <summary>
            Visits the given method contract.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IMethodContract)" inheritedFromTypeName="ICodeAndContractVisitor">methodContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IPostcondition)">
      <summary>
            Visits the given postCondition.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IPostcondition)" inheritedFromTypeName="ICodeAndContractVisitor">postCondition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IPrecondition)">
      <summary>
            Visits the given precondition.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IPrecondition)" inheritedFromTypeName="ICodeAndContractVisitor">precondition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IThrownException)">
      <summary>
            Visits the given thrown exception.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IThrownException)" inheritedFromTypeName="ICodeAndContractVisitor">thrownException != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ITypeContract)">
      <summary>
            Visits the given type contract.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ITypeContract)" inheritedFromTypeName="ICodeAndContractVisitor">typeContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.BaseCodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ITypeInvariant)">
      <summary>
            Visits the given type invariant.
            </summary>
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ITypeInvariant)" inheritedFromTypeName="ICodeAndContractVisitor">typeInvariant != null</requires>
    </member>
    <member name="P:Microsoft.Cci.DummyCreateArray.ElementType">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.ICreateArray.get_ElementType" inheritedFromTypeName="ICreateArray">Contract.Result&lt;ITypeReference&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyCreateArray.LowerBounds">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.ICreateArray.get_LowerBounds" inheritedFromTypeName="ICreateArray">Contract.Result&lt;IEnumerable&lt;int&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyCreateArray.Rank">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.ICreateArray.get_Rank" inheritedFromTypeName="ICreateArray">Contract.Result&lt;uint&gt;() &gt; 0</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyCreateArray.Sizes">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.ICreateArray.get_Sizes" inheritedFromTypeName="ICreateArray">Contract.Result&lt;IEnumerable&lt;IExpression&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyCreateArray.Type">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IExpression.get_Type" inheritedFromTypeName="IExpression">Contract.Result&lt;ITypeReference&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyCreateArray.Locations">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;(), x =&gt; x != null)</ensures>
      </getter>
    </member>
    <member name="M:Microsoft.Cci.DummyCreateArray.Dispatch(Microsoft.Cci.ICodeVisitor)">
      <requires inheritedFrom="M:Microsoft.Cci.IExpression.Dispatch(Microsoft.Cci.ICodeVisitor)" inheritedFromTypeName="IExpression">visitor != null</requires>
    </member>
    <member name="P:Microsoft.Cci.DummyCreateArray.Initializers">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.ICreateArray.get_Initializers" inheritedFromTypeName="ICreateArray">Contract.Result&lt;IEnumerable&lt;IExpression&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyAssignment.Type">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IExpression.get_Type" inheritedFromTypeName="IExpression">Contract.Result&lt;ITypeReference&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyAssignment.Source">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IAssignment.get_Source" inheritedFromTypeName="IAssignment">Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyAssignment.Locations">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;(), x =&gt; x != null)</ensures>
      </getter>
    </member>
    <member name="M:Microsoft.Cci.DummyAssignment.Dispatch(Microsoft.Cci.ICodeVisitor)">
      <requires inheritedFrom="M:Microsoft.Cci.IExpression.Dispatch(Microsoft.Cci.ICodeVisitor)" inheritedFromTypeName="IExpression">visitor != null</requires>
    </member>
    <member name="P:Microsoft.Cci.DummyAssignment.Target">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IAssignment.get_Target" inheritedFromTypeName="IAssignment">Contract.Result&lt;ITargetExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummySwitchCase.Locations">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;(), x =&gt; x != null)</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyTargetExpression.Type">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IExpression.get_Type" inheritedFromTypeName="IExpression">Contract.Result&lt;ITypeReference&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Microsoft.Cci.DummyTargetExpression.Dispatch(Microsoft.Cci.ICodeVisitor)">
      <requires inheritedFrom="M:Microsoft.Cci.IExpression.Dispatch(Microsoft.Cci.ICodeVisitor)" inheritedFromTypeName="IExpression">visitor != null</requires>
    </member>
    <member name="P:Microsoft.Cci.DummyTargetExpression.Locations">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;(), x =&gt; x != null)</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyExpression.Type">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IExpression.get_Type" inheritedFromTypeName="IExpression">Contract.Result&lt;ITypeReference&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyExpression.Locations">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;(), x =&gt; x != null)</ensures>
      </getter>
    </member>
    <member name="M:Microsoft.Cci.DummyExpression.Dispatch(Microsoft.Cci.ICodeVisitor)">
      <requires inheritedFrom="M:Microsoft.Cci.IExpression.Dispatch(Microsoft.Cci.ICodeVisitor)" inheritedFromTypeName="IExpression">visitor != null</requires>
    </member>
    <member name="P:Microsoft.Cci.DummyLabeledStatement.Statement">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.ILabeledStatement.get_Statement" inheritedFromTypeName="ILabeledStatement">Contract.Result&lt;IStatement&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyLabeledStatement.Label">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.ILabeledStatement.get_Label" inheritedFromTypeName="ILabeledStatement">Contract.Result&lt;IName&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyLabeledStatement.Locations">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;(), x =&gt; x != null)</ensures>
      </getter>
    </member>
    <member name="M:Microsoft.Cci.DummyLabeledStatement.Dispatch(Microsoft.Cci.ICodeVisitor)">
      <requires inheritedFrom="M:Microsoft.Cci.IStatement.Dispatch(Microsoft.Cci.ICodeVisitor)" inheritedFromTypeName="IStatement">visitor != null</requires>
    </member>
    <member name="M:Microsoft.Cci.DummySwitchStatement.Dispatch(Microsoft.Cci.ICodeVisitor)">
      <requires inheritedFrom="M:Microsoft.Cci.IStatement.Dispatch(Microsoft.Cci.ICodeVisitor)" inheritedFromTypeName="IStatement">visitor != null</requires>
    </member>
    <member name="P:Microsoft.Cci.DummySwitchStatement.Locations">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;(), x =&gt; x != null)</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyMethodCall.Arguments">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IMethodCall.get_Arguments" inheritedFromTypeName="IMethodCall">Contract.Result&lt;IEnumerable&lt;IExpression&gt;&gt;() != null</ensures>
      </getter>
    </member>
    <member name="M:Microsoft.Cci.DummyMethodCall.Dispatch(Microsoft.Cci.ICodeVisitor)">
      <requires inheritedFrom="M:Microsoft.Cci.IExpression.Dispatch(Microsoft.Cci.ICodeVisitor)" inheritedFromTypeName="IExpression">visitor != null</requires>
    </member>
    <member name="P:Microsoft.Cci.DummyMethodCall.Type">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IExpression.get_Type" inheritedFromTypeName="IExpression">Contract.Result&lt;ITypeReference&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyMethodCall.MethodToCall">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IMethodCall.get_MethodToCall" inheritedFromTypeName="IMethodCall">Contract.Result&lt;IMethodReference&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyMethodCall.Locations">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;(), x =&gt; x != null)</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyMethodCall.ThisArgument">
      <getter>
        <requires inheritedFrom="M:Microsoft.Cci.IMethodCall.get_ThisArgument" inheritedFromTypeName="IMethodCall">!this.IsStaticCall</requires>
        <ensures inheritedFrom="M:Microsoft.Cci.IMethodCall.get_ThisArgument" inheritedFromTypeName="IMethodCall">Contract.Result&lt;IExpression&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyGotoStatement.TargetStatement">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IGotoStatement.get_TargetStatement" inheritedFromTypeName="IGotoStatement">Contract.Result&lt;ILabeledStatement&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyGotoStatement.Locations">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;(), x =&gt; x != null)</ensures>
      </getter>
    </member>
    <member name="M:Microsoft.Cci.DummyGotoStatement.Dispatch(Microsoft.Cci.ICodeVisitor)">
      <requires inheritedFrom="M:Microsoft.Cci.IStatement.Dispatch(Microsoft.Cci.ICodeVisitor)" inheritedFromTypeName="IStatement">visitor != null</requires>
    </member>
    <member name="P:Microsoft.Cci.DummyAddressableExpression.Type">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IExpression.get_Type" inheritedFromTypeName="IExpression">Contract.Result&lt;ITypeReference&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyAddressableExpression.Locations">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;(), x =&gt; x != null)</ensures>
      </getter>
    </member>
    <member name="M:Microsoft.Cci.DummyAddressableExpression.Dispatch(Microsoft.Cci.ICodeVisitor)">
      <requires inheritedFrom="M:Microsoft.Cci.IExpression.Dispatch(Microsoft.Cci.ICodeVisitor)" inheritedFromTypeName="IExpression">visitor != null</requires>
    </member>
    <member name="P:Microsoft.Cci.DummyCompileTimeConstant.Type">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IExpression.get_Type" inheritedFromTypeName="IExpression">Contract.Result&lt;ITypeReference&gt;() != null</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.DummyCompileTimeConstant.Locations">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;(), x =&gt; x != null)</ensures>
      </getter>
    </member>
    <member name="M:Microsoft.Cci.DummyCompileTimeConstant.Dispatch(Microsoft.Cci.ICodeVisitor)">
      <requires inheritedFrom="M:Microsoft.Cci.IExpression.Dispatch(Microsoft.Cci.ICodeVisitor)" inheritedFromTypeName="IExpression">visitor != null</requires>
    </member>
    <member name="P:Microsoft.Cci.DummyBlock.Locations">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;(), x =&gt; x != null)</ensures>
      </getter>
    </member>
    <member name="M:Microsoft.Cci.DummyBlock.Dispatch(Microsoft.Cci.ICodeVisitor)">
      <requires inheritedFrom="M:Microsoft.Cci.IStatement.Dispatch(Microsoft.Cci.ICodeVisitor)" inheritedFromTypeName="IStatement">visitor != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IBlockExpression)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBlockExpression)" inheritedFromTypeName="ICodeVisitor">blockExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IAnonymousDelegate)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAnonymousDelegate)" inheritedFromTypeName="ICodeVisitor">anonymousDelegate != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IBoundExpression)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBoundExpression)" inheritedFromTypeName="ICodeVisitor">boundExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ISizeOf)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISizeOf)" inheritedFromTypeName="ICodeVisitor">sizeOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IMakeTypedReference)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IMakeTypedReference)" inheritedFromTypeName="ICodeVisitor">makeTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IYieldBreakStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IYieldBreakStatement)" inheritedFromTypeName="ICodeVisitor">yieldBreakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ICompileTimeConstant)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICompileTimeConstant)" inheritedFromTypeName="ICodeVisitor">constant != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IOldValue)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IOldValue)" inheritedFromTypeName="ICodeVisitor">oldValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ISubtraction)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISubtraction)" inheritedFromTypeName="ICodeVisitor">subtraction != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IModulus)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IModulus)" inheritedFromTypeName="ICodeVisitor">modulus != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IDupValue)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDupValue)" inheritedFromTypeName="ICodeVisitor">dupValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IWhileDoStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IWhileDoStatement)" inheritedFromTypeName="ICodeVisitor">whileDoStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IGetTypeOfTypedReference)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGetTypeOfTypedReference)" inheritedFromTypeName="ICodeVisitor">getTypeOfTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.INamedArgument)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.INamedArgument)" inheritedFromTypeName="ICodeVisitor">namedArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IForStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IForStatement)" inheritedFromTypeName="ICodeVisitor">forStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IEquality)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IEquality)" inheritedFromTypeName="ICodeVisitor">equality != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IVectorLength)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IVectorLength)" inheritedFromTypeName="ICodeVisitor">vectorLength != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IDefaultValue)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDefaultValue)" inheritedFromTypeName="ICodeVisitor">defaultValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IGotoSwitchCaseStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGotoSwitchCaseStatement)" inheritedFromTypeName="ICodeVisitor">gotoSwitchCaseStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IConditional)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IConditional)" inheritedFromTypeName="ICodeVisitor">conditional != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IExpressionStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IExpressionStatement)" inheritedFromTypeName="ICodeVisitor">expressionStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IUnaryPlus)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IUnaryPlus)" inheritedFromTypeName="ICodeVisitor">unaryPlus != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IDoUntilStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDoUntilStatement)" inheritedFromTypeName="ICodeVisitor">doUntilStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ICreateArray)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICreateArray)" inheritedFromTypeName="ICodeVisitor">createArray != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IContinueStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IContinueStatement)" inheritedFromTypeName="ICodeVisitor">continueStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IPointerCall)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IPointerCall)" inheritedFromTypeName="ICodeVisitor">pointerCall != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IUnaryNegation)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IUnaryNegation)" inheritedFromTypeName="ICodeVisitor">unaryNegation != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IRethrowStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRethrowStatement)" inheritedFromTypeName="ICodeVisitor">rethrowStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ICreateObjectInstance)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICreateObjectInstance)" inheritedFromTypeName="ICodeVisitor">createObjectInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IPushStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IPushStatement)" inheritedFromTypeName="ICodeVisitor">pushStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IGreaterThanOrEqual)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGreaterThanOrEqual)" inheritedFromTypeName="ICodeVisitor">greaterThanOrEqual != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ITypeOf)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITypeOf)" inheritedFromTypeName="ICodeVisitor">typeOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ILockStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILockStatement)" inheritedFromTypeName="ICodeVisitor">lockStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IResourceUseStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IResourceUseStatement)" inheritedFromTypeName="ICodeVisitor">resourceUseStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ILeftShift)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILeftShift)" inheritedFromTypeName="ICodeVisitor">leftShift != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ICheckIfInstance)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICheckIfInstance)" inheritedFromTypeName="ICodeVisitor">checkIfInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ITokenOf)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITokenOf)" inheritedFromTypeName="ICodeVisitor">tokenOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IDebuggerBreakStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDebuggerBreakStatement)" inheritedFromTypeName="ICodeVisitor">debuggerBreakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ILessThanOrEqual)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILessThanOrEqual)" inheritedFromTypeName="ICodeVisitor">lessThanOrEqual != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IFillMemoryStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IFillMemoryStatement)" inheritedFromTypeName="ICodeVisitor">fillMemoryStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IExclusiveOr)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IExclusiveOr)" inheritedFromTypeName="ICodeVisitor">exclusiveOr != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ITryCatchFinallyStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITryCatchFinallyStatement)" inheritedFromTypeName="ICodeVisitor">tryCatchFilterFinallyStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IDivision)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IDivision)" inheritedFromTypeName="ICodeVisitor">division != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ICopyMemoryStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICopyMemoryStatement)" inheritedFromTypeName="ICodeVisitor">copyMemoryStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IConditionalStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IConditionalStatement)" inheritedFromTypeName="ICodeVisitor">conditionalStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IRuntimeArgumentHandleExpression)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRuntimeArgumentHandleExpression)" inheritedFromTypeName="ICodeVisitor">runtimeArgumentHandleExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IThrowStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IThrowStatement)" inheritedFromTypeName="ICodeVisitor">throwStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IAddressableExpression)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddressableExpression)" inheritedFromTypeName="ICodeVisitor">addressableExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ICreateDelegateInstance)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICreateDelegateInstance)" inheritedFromTypeName="ICodeVisitor">createDelegateInstance != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IStackArrayCreate)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IStackArrayCreate)" inheritedFromTypeName="ICodeVisitor">stackArrayCreate != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IMethodCall)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IMethodCall)" inheritedFromTypeName="ICodeVisitor">methodCall != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IThisReference)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IThisReference)" inheritedFromTypeName="ICodeVisitor">thisReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IOnesComplement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IOnesComplement)" inheritedFromTypeName="ICodeVisitor">onesComplement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ISwitchCase)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISwitchCase)" inheritedFromTypeName="ICodeVisitor">switchCase != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IMultiplication)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IMultiplication)" inheritedFromTypeName="ICodeVisitor">multiplication != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IForEachStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IForEachStatement)" inheritedFromTypeName="ICodeVisitor">forEachStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ITargetExpression)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ITargetExpression)" inheritedFromTypeName="ICodeVisitor">targetExpression != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IGetValueOfTypedReference)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGetValueOfTypedReference)" inheritedFromTypeName="ICodeVisitor">getValueOfTypedReference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.INotEquality)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.INotEquality)" inheritedFromTypeName="ICodeVisitor">notEquality != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IGotoStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGotoStatement)" inheritedFromTypeName="ICodeVisitor">gotoStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IAddressOf)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddressOf)" inheritedFromTypeName="ICodeVisitor">addressOf != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ISwitchStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ISwitchStatement)" inheritedFromTypeName="ICodeVisitor">switchStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IBitwiseAnd)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBitwiseAnd)" inheritedFromTypeName="ICodeVisitor">bitwiseAnd != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IAddressDereference)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddressDereference)" inheritedFromTypeName="ICodeVisitor">addressDereference != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IBlockStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBlockStatement)" inheritedFromTypeName="ICodeVisitor">block != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IAssignment)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAssignment)" inheritedFromTypeName="ICodeVisitor">assignment != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IOutArgument)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IOutArgument)" inheritedFromTypeName="ICodeVisitor">outArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ICastIfPossible)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICastIfPossible)" inheritedFromTypeName="ICodeVisitor">castIfPossible != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IAssertStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAssertStatement)" inheritedFromTypeName="ICodeVisitor">assertStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IAddition)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAddition)" inheritedFromTypeName="ICodeVisitor">addition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IPopValue)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IPopValue)" inheritedFromTypeName="ICodeVisitor">popValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IGreaterThan)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IGreaterThan)" inheritedFromTypeName="ICodeVisitor">greaterThan != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IReturnStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IReturnStatement)" inheritedFromTypeName="ICodeVisitor">returnStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IReturnValue)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IReturnValue)" inheritedFromTypeName="ICodeVisitor">returnValue != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IRefArgument)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRefArgument)" inheritedFromTypeName="ICodeVisitor">refArgument != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ILabeledStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILabeledStatement)" inheritedFromTypeName="ICodeVisitor">labeledStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IEmptyStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IEmptyStatement)" inheritedFromTypeName="ICodeVisitor">emptyStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ILogicalNot)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILogicalNot)" inheritedFromTypeName="ICodeVisitor">logicalNot != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ILocalDeclarationStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILocalDeclarationStatement)" inheritedFromTypeName="ICodeVisitor">localDeclarationStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ILessThan)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ILessThan)" inheritedFromTypeName="ICodeVisitor">lessThan != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IConversion)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IConversion)" inheritedFromTypeName="ICodeVisitor">conversion != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IBreakStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBreakStatement)" inheritedFromTypeName="ICodeVisitor">breakStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IAssumeStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IAssumeStatement)" inheritedFromTypeName="ICodeVisitor">assumeStatement != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.ICatchClause)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.ICatchClause)" inheritedFromTypeName="ICodeVisitor">catchClause != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IBitwiseOr)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IBitwiseOr)" inheritedFromTypeName="ICodeVisitor">bitwiseOr != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IArrayIndexer)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IArrayIndexer)" inheritedFromTypeName="ICodeVisitor">arrayIndexer != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IRightShift)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IRightShift)" inheritedFromTypeName="ICodeVisitor">rightShift != null</requires>
    </member>
    <member name="M:Microsoft.Cci.CodeTraverser.Dispatcher.Visit(Microsoft.Cci.IYieldReturnStatement)">
      <requires inheritedFrom="M:Microsoft.Cci.ICodeVisitor.Visit(Microsoft.Cci.IYieldReturnStatement)" inheritedFromTypeName="ICodeVisitor">yieldReturnStatement != null</requires>
    </member>
    <member name="P:Microsoft.Cci.Contracts.DummyMethodContract.Locations">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;(), x =&gt; x != null)</ensures>
      </getter>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.ContractElementDispatcher.Visit(Microsoft.Cci.Contracts.IPostcondition)">
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IPostcondition)" inheritedFromTypeName="ICodeAndContractVisitor">postCondition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.ContractElementDispatcher.Visit(Microsoft.Cci.Contracts.ITypeInvariant)">
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ITypeInvariant)" inheritedFromTypeName="ICodeAndContractVisitor">typeInvariant != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.ContractElementDispatcher.Visit(Microsoft.Cci.Contracts.IMethodContract)">
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IMethodContract)" inheritedFromTypeName="ICodeAndContractVisitor">methodContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.ContractElementDispatcher.Visit(Microsoft.Cci.Contracts.ITypeContract)">
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ITypeContract)" inheritedFromTypeName="ICodeAndContractVisitor">typeContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.ContractElementDispatcher.Visit(Microsoft.Cci.Contracts.ILoopInvariant)">
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ILoopInvariant)" inheritedFromTypeName="ICodeAndContractVisitor">loopInvariant != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.ContractElementDispatcher.Visit(Microsoft.Cci.Contracts.IPrecondition)">
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IPrecondition)" inheritedFromTypeName="ICodeAndContractVisitor">precondition != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.ContractElementDispatcher.Visit(Microsoft.Cci.Contracts.ILoopContract)">
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.ILoopContract)" inheritedFromTypeName="ICodeAndContractVisitor">loopContract != null</requires>
    </member>
    <member name="M:Microsoft.Cci.Contracts.CodeAndContractTraverser.ContractElementDispatcher.Visit(Microsoft.Cci.Contracts.IThrownException)">
      <requires inheritedFrom="M:Microsoft.Cci.Contracts.ICodeAndContractVisitor.Visit(Microsoft.Cci.Contracts.IThrownException)" inheritedFromTypeName="ICodeAndContractVisitor">thrownException != null</requires>
    </member>
    <member name="P:Microsoft.Cci.Contracts.DummyPostcondition.Locations">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;(), x =&gt; x != null)</ensures>
      </getter>
    </member>
    <member name="P:Microsoft.Cci.Contracts.DummyTypeContract.Locations">
      <getter>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;() != null</ensures>
        <ensures inheritedFrom="M:Microsoft.Cci.IObjectWithLocations.get_Locations" inheritedFromTypeName="IObjectWithLocations">Contract.ForAll(Contract.Result&lt;IEnumerable&lt;ILocation&gt;&gt;(), x =&gt; x != null)</ensures>
      </getter>
    </member>
  </members>
</doc>