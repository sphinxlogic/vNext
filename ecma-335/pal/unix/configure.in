dnl /*++
dnl 
dnl  Copyright (c) 2006 Microsoft Corporation.  All rights reserved.
dnl 
dnl  The use and distribution terms for this software are contained in the file
dnl  named license.txt, which can be found in the root of this distribution.
dnl  By using this software in any fashion, you are agreeing to be bound by the
dnl  terms of this license.
dnl 
dnl  You must not remove this notice, or any other, from this software.
dnl 
dnl
dnl Module Name : configure.in
dnl
dnl process this file with autoconf to create a configure script
dnl
dnl --*/

AC_INIT(include/pal/palinternal.h)
rm -f config.status

if test ! "$BUILD_ALT_DIR"
then
    echo "Environment not set. Run '. env.sh' before building the PAL."
    exit
fi

AC_CONFIG_HEADER(config.h:../../config.h.in)

dnl configure options go here.

AC_ARG_ENABLE(debug,
[  --disable-debug          compile out all debug-only code],
[if test "$enableval" = "no"; then DEBUG_ENABLED="no"; fi])

AC_ARG_ENABLE(dbgmsg,
[  --disable-dbgmsg         compile out all debugging messages],
[if test "$enableval" = "no"; then DEBUG_MSGS="no"; fi])

AC_ARG_ENABLE(appendtraces,
[  --enable-appendtraces    append debug traces to existing file \
instead of overwriting],
[if test "$enableval" = "yes"; then DBG_APPEND="yes"; else DBG_APPEND="no"; fi])

AC_ARG_ENABLE(tracechecks,
[  --enable-tracechecks     check format specifiers in trace macros (gcc only)],
,enable_tracechecks=no)

AC_ARG_WITH(vac,
[  --with-vac   use visual age compiler instead of gcc],
USE_VAC_CC=1)
 
dnl define more options here

AC_SUBST(OPTIONS)


AC_MSG_CHECKING(platform name)
platform_name=`uname -s`
if test X"$platform_name" = "X"; then
  platform_name=Unknown
fi
AC_MSG_RESULT($platform_name)

AC_MSG_CHECKING(architecture)
ARCH_DIR=`(/usr/bin/uname -p | sed -e s/powerpc/ppc/ -e s/i.86/i386/) 2>/dev/null`
if test X"$ARCH_DIR" = "X"; then
  if test "$platform_name" = "HP-UX"; then
    if test `uname -m` = "ia64"; then
      ARCH_DIR="hpia64"
    else
      ARCH_DIR=`(/usr/bin/uname -s | sed -e s/HP-UX/parisc/) 2>/dev/null || echo unknown`
    fi
  fi
fi
if test "$ARCH_DIR" = "ppc"; then
  if test "$platform_name" = "AIX"; then
    ARCH_DIR="aixppc"
    if test "$USE_VAC_CC" = "1"; then
        CC=xlc_r
        CXX=xlC_r
        dnl these flags are necessary for PAL shared library but not useful for a normal C program
        EXTRA_EXPORT_FLAGS="-L/usr/lib -L/usr/vacpp/lib -L/usr/vac/lib -G -bM:SRE -bnoentry -qalloca"
    else
        EXTRA_EXPORT_FLAGS=
        CC=$CC
        CXX=$CXX
    fi
  fi
fi
dnl Special hack to create the directory that will be needed -> normaly this is done by preconfig, but in this case
dnl the preconfig doesn't know the directory name
mkdir -p ../../arch/$ARCH_DIR/obj$BUILD_ALT_DIR/$_BUILDARCH
AC_MSG_RESULT($ARCH_DIR)
AC_SUBST(ARCH_DIR)
AC_SUBST(EXTRA_EXPORT_FLAGS)


if test "$DEBUG_ENABLED" = "no"
then
    AC_DEFINE(_NO_DEBUG_MESSAGES_)
else
    AC_DEFINE(_DEBUG)
    if test "$DEBUG_MSGS" = "no"
    then
        AC_DEFINE(_NO_DEBUG_MESSAGES_)
    fi
fi

if test "$DBG_APPEND" = "yes"
then
        AC_DEFINE(_PAL_APPEND_DBG_OUTPUT_)
fi

if test "$enable_tracechecks" = "yes"
then
        AC_DEFINE(CHECK_TRACE_SPECIFIERS,1)
else
        AC_DEFINE(CHECK_TRACE_SPECIFIERS,0)
fi

dnl Define BIGENDIAN if the current system is big-endian.
dnl The presence of this macro causes autoconf 2.13 to print a warning
dnl about cross-compiling.  The warning is a non-issue and can't be
dnl disabled without modifying autoconf.
AC_C_BIGENDIAN
if test "$ac_cv_c_bigendian" = yes; then
    BIGENDIAN="-DBIGENDIAN"
else
    dnl For completeness
    BIGENDIAN=""
fi
AC_SUBST(BIGENDIAN)


dnl Default compiler flags. Honor any set in the environment, but
dnl also turn all warnings on, create position-independent code,
dnl enable exceptions, and disallow common symbols between
dnl compilation units because the linker won't allow them on some
dnl systems.
dnl Note that this has to go before AC_PROG_CC because that will set
dnl default CFLAGS values if CFLAGS isn't already set. Since we don't
dnl always want the -g -O2 that autoconf uses by default, we have to
dnl set CFLAGS before AC_PROG_CC.
dnl All code whose makefiles we build with configure is LP64 compatible (i.e.
dnl does not assume long is always 32-bits)
if test "$USE_VAC_CC" = "1";
then
     CFLAGS="-L/usr/lib -L/usr/vacpp/lib $CFLAGS -qeh $BIGENDIAN -qlanglvl=extc99 -qlanglvl=extended -DLP64COMPATIBLE"
     CFLAGS="$CFLAGS -qflag=w:w -D__STDC_VERSION__=199901L -qcpluscmt -D_VAC_"
else
     CFLAGS="$CFLAGS $ALL_WARNINGS_FLAG -fexceptions -fno-common $BIGENDIAN -DLP64COMPATIBLE"
fi

dnl Defalt linker flags. Honor any set in the environment, but
dnl also enable exceptions.
if test "$USE_VAC_CC" = "1"; then
    LDFLAGS="$LDFLAGS -qeh"
else
    LDFLAGS="$LDFLAGS -fexceptions"
fi

dnl Allow us to have tests which require the math library.
LIBS="$LIBS -lm"

dnl If we're on Solaris, we also need to set __EXTENSIONS__ to be
dnl able to see prototypes for APIs that are not in ANSI C.
dnl Also, set _POSIX_C_SOURCE=199506L so we see modern POSIX prototypes
dnl for various POSIX APIs rather then the pre-POSIX Solaris
dnl prototypes for the same APIs and set _LARGEFILE64_SOURCE and
dnl _FILE_OFFSET_BITS=64 so we use 64-bit data types and functions for
dnl file APIs. Finally, we require v9 instructions, so we build only
dnl for that CPU.
AC_MSG_CHECKING(whether __EXTENSIONS__ and _POSIX_C_SOURCE are required)
if test "$platform_name" = "SunOS"; then
    CFLAGS="$CFLAGS -D__EXTENSIONS__ -D_POSIX_C_SOURCE=199506L"
    CFLAGS="$CFLAGS -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64"
    if test `uname -p` = "sparc"; then
      CFLAGS="$CFLAGS -Wa,-Av9"
    fi
    AC_MSG_RESULT(yes)
elif test "$platform_name" = "HP-UX"; then
    dnl _XOPEN_SOURCE_EXTENDED is needed to get modern prototypes for some
    dnl functions -- in particular, the use of socklen_t instead of int
    dnl in a lot of the socket functions
    CFLAGS="$CFLAGS -D_POSIX_C_SOURCE=199506L -D_HPUX_ -D_XOPEN_SOURCE_EXTENDED"
    if test "$_BIT64" = "1"; then
        CFLAGS="$CFLAGS -mlp64 -DBIT64 -D_WIN64"
        LDFLAGS="$LDFLAGS -mlp64 "
    fi
    AC_MSG_RESULT(yes)        
else
    AC_MSG_RESULT(no)
fi

dnl If we're on MacOS, we need to generate unwind tables for non-call instructions
if test "$platform_name" = "Darwin"; then
    CFLAGS="$CFLAGS -fnon-call-exceptions"
fi

dnl Same On FreeBSD if using gcc 3.3.3
if test "$platform_name" = "FreeBSD"; then
    if test "$ROTOR_TOOLSET_VERSION"  \> "3.0.0 "; then
        CFLAGS="$CFLAGS -fnon-call-exceptions"
    fi
fi

dnl On 32-bit Solaris, we always use sjlj-exceptions
dnl but 64-bit Solaris GCC doesn't support -fsjlj-exceptions
if test "$platform_name" = "SunOS"; then
    if test "$_BIT64" != "1"; then
        CFLAGS="$CFLAGS -fsjlj-exceptions"
    fi
fi
dnl Decide whether to enable debugging.
if test "$NTDEBUG" != "ntsdnodbg"; then
    CFLAGS="$CFLAGS -g"
fi

dnl If we are checked (c) or free (r), turn on optimizations.
dnl If we are building debug (d), turn optimizations off.
if test "$BUILD_ALT_DIR" = "d"; then
    if test "$USE_VAC_CC" = "1"; then
        CFLAGS="$CFLAGS -O0 -qnoipa -qdbxextra"
    else
        CFLAGS="$CFLAGS -O0 -finline"
    fi
fi
if test "$BUILD_ALT_DIR" = "c"; then
    if test "$USE_VAC_CC" = "1"; then
        CFLAGS="$CFLAGS -O2 -qnoipa -qunroll -qdbxextra -qmaxmem=-1 -qstrict"
    else
        CFLAGS="$CFLAGS -O2"
    fi
fi
if test "$BUILD_ALT_DIR" = "r"; then
    if test "$USE_VAC_CC" = "1"; then
        CFLAGS="$CFLAGS -O2 -qnoipa -Q -qunroll -qmaxmem=-1 -qstrict"
    else
        CFLAGS="$CFLAGS -O2"
    fi
fi

if test "$BUILD_ALT_DIR" = "m"; then
    CFLAGS="$CFLAGS -O2"
fi
if test "${PAL_LIB_PERF}" = "_perf" ; then
CFLAGS="$CFLAGS -DPAL_PERF"
fi

dnl We still have some changes to make to CFLAGS. Save the current
dnl set of flags till later.
CFLAGS_NO_PIC="$CFLAGS"
AC_SUBST(CFLAGS_NO_PIC)
if test "$USE_VAC_CC" = "1"; then
    CFLAGS="$CFLAGS -DPIC -DPLATFORM_UNIX"
else
    CFLAGS="$CFLAGS -fPIC -DPIC -DPLATFORM_UNIX"
fi

ac_saved_cflags=$CFLAGS

dnl Checks for programs go here.
AC_PROG_CC
AC_PROG_CPP
AC_PROG_CXX
AC_PROG_INSTALL

dnl command to do partial linking (join multiple .o files in a single .o file)
if test "$_BIT64" = "1" && test "$platform_name" = "SunOS"; then
    LDPARTIAL="/usr/local64/bin/ld -r"
else
    LDPARTIAL="ld -r"
fi
AC_SUBST(LDPARTIAL)

dnl gcc -M lets the preprocessor generate a list of dependencies. we want
dnl to use this for "make depend", but we need to do something else if
dnl $CC isn't gcc. So we need a test to detect availability of gcc -M
MDTOOL=mdtool_gcc
dnl MDTOOL=mdtool_dummy                         
AC_SUBST(MDTOOL)

dnl Checks for libraries go here.

dnl On FreeBSD, the option -pthread must be passed to gcc in order to link with
dnl libc_r (thread-safe version of libc, which also includes pthread functions).
dnl It's unclear how to check for the validity of -pthread because it isn't a
dnl library flag, so we'll just check for the presence of pthread_self in
dnl libc_r instead.
if test "$USE_VAC_CC" = "1"; then
    PTHREAD_OPTIONS=
else
    AC_CHECK_LIB(c_r, pthread_self, has_pthread_flag=yes, has_pthread_flag=no)

    if test $has_pthread_flag = yes; then
        PTHREAD_OPTIONS="-pthread"
    else
        PTHREAD_OPTIONS=
    fi
fi
AC_SUBST(PTHREAD_OPTIONS)

dnl Autoconf doesn't have any way to validate flags to the linker. This is a
dnl bit of a hack, but it's probably better to do this than to switch on the
dnl result of uname.
dnl This doesn't work in Autoconf 2.5, which passes $LIBS to the compiler
dnl when it does AC_TRY_LINK_FUNC.
AC_MSG_CHECKING(for linker support for -soname)
saved_libs=$LIBS
LIBS="$LIBS -soname libfoo.so"
AC_TRY_LINK_FUNC(malloc, has_soname=yes, has_soname=no)
LIBS=$saved_libs
if test $has_soname = yes; then
    AC_MSG_RESULT(yes)
    CC_SONAME="-Wl,-soname,\$(MODULE_NAME)"
else
    AC_MSG_RESULT(no)
    CC_SONAME=
fi
dnl We'll substitute CC_SONAME below, after we have a chance to set it on
dnl Autoconf 2.5.2 platforms.

dnl Set our file system case-sensitivity flag.
AC_MSG_CHECKING(whether to build for a case-sensitive file system)
if test "$FEATURE_CASE_SENSITIVE_FS" = "1"; then
    AC_DEFINE(HAVE_CASE_SENSITIVE_FILESYSTEM)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

dnl Figure out what our C runtime library is. At the same time, we can
dnl determine the flags that we need to pass to the compiler to get the
dnl linker to produce a shared library, and also set the extension for
dnl the library. Also, since this section notices if we're on Mac OS X,
dnl set a flag that tells us that we can use CoreFoundation, and another
dnl which determines whether we should use dlcompat.

DLCOMPAT_DIR=
DLCOMPAT_OBJ=
DLCOMPAT_INC=
ASMFLAGS=
ASM_WITH_CPP_FLAGS="-x assembler-with-cpp"

dnl gcc -M generates make-friendly dependencies;
dnl -MM ignores system includes (#include <file.h>)
MDTOOL_CFLAGS="-MM"

dnl We need LIBS w/o the pthread libraries for pthread checks performed
dnl later on
no_pthread_libs="$LIBS"

dnl On some platforms (e.g., AIX) libc_r contains an entry for sigreturn
dnl even though that function does not actually exist. On those platforms
dnl the following shoudl be set to "yes"
ac_bad_sigreturn_in_libc_r=no

dnl consolidate platform-dependent (rather than feature-dependent) stuff 
dnl here.  
if test "$platform_name" = "AIX"; then
    if test "$USE_VAC_CC" = "1"; then
        ASM_WITH_CPP_FLAGS=
        MDTOOL_CFLAGS="-M"
        C_RUNTIME=c_r
        SHARED_LIB="-L/usr/lib -L/usr/vacpp/lib -L/usr/vac/lib -G -bM:SRE -bnoentry"
    else
        C_RUNTIME=c
        SHARED_LIB=-shared
    fi

    SHARED_LIB_EXTENSION=.a
    FRAMEWORKS=
    dnl __STDC__=2 is necessary to prevent the AIX headers from defining
    dnl a random sigsetjmp macro, which would cause endless redefinition
    dnl warnings
    if test "$USE_VAC_CC" = "1"; then
        CFLAGS="$ac_saved_cflags -qchars=signed -qenum=4"
    else
        CFLAGS="$ac_saved_cflags -fsigned-char -Wno-format -D__STDC__=2"
    fi

    dnl AIX has libpthreads.
    LIBS="$LIBS -lpthreads"

    if test "$USE_VAC_CC" = "1"; then
        EXTRA_LIBS="-lC_r -lpthreads"
    else
        EXTRA_LIBS="-lpthreads"
    fi

    ASMFLAGS="-Wa,-mppc"
    ac_bad_sigreturn_in_libc_r=yes
    AC_DEFINE(PAL_PTRACE(cmd, pid, addr, data), ptrace((cmd), (pid), (int*)(addr), (data), NULL))
    AC_DEFINE(PAL_PT_ATTACH, PT_ATTACH)
    AC_DEFINE(PAL_PT_DETACH, PT_DETACH)
    AC_DEFINE(PAL_PT_READ_D, PT_READ_D)
    AC_DEFINE(PAL_PT_WRITE_D, PT_WRITE_D)
    AC_DEFINE(RETURNS_NEW_HANDLES_ON_REPEAT_DLOPEN)
    AC_DEFINE(WRITE_0_BYTES_HANGS_TTY)
    dnl close(fd) blocks if there is any outstanding syscall on fd
    AC_DEFINE(CLOSE_BLOCKS_ON_OUTSTANDING_SYSCALLS)
    dnl a sendto with a To not matching the socket family returns EHOSTUNREACH
    AC_DEFINE(SENDTO_RETURNS_UNREACH_ON_WRONG_AF)
    AC_DEFINE(USER_H_DEFINES_DEBUG)
    AC_MSG_RESULT(AIX)
elif test "$platform_name" = "HP-UX"; then
    C_RUNTIME=c
    FRAMEWORKS=
    CFLAGS="$ac_saved_cflags -fno-strict-aliasing"
    LIBS="$LIBS -lpthread"
    EXTRA_LIBS="-lpthread"
    SHARED_LIB_EXTENSION=.sl
    dnl SO_RCVTIMEO and SO_SNDTIMEO are not supported by get/setsockopt
    AC_DEFINE(SO_TIMEO_NOT_SUPPORTED)
    if test `uname -m` = "ia64"; then
        SHARED_LIB="-shared"
        LDFLAGS="$LDFLAGS -L/usr/local/lib/hpux64/ -L/usr/lib/hpux64/ /usr/lib/hpux64/libunwind.so"
        LIBS="$LIBS -lxnet"
        EXTRA_LIBS="$EXTRA_LIBS -lxnet"
        AC_MSG_RESULT(HPUX-Itanium)
    else
        SHARED_LIB="-Wl,-b -nostartfiles"
        AC_MSG_RESULT(HPUX - PA-RISC)
    fi
    dnl PRIV_RTSCHED / PRIV_RTPRIO are required to call pthread_setschedparam on HPUX
    AC_DEFINE(SET_SCHEDPARAM_NEEDS_PRIVS)
elif test "$platform_name" = "FreeBSD"; then
    C_RUNTIME=c_r
    SHARED_LIB=-shared
    SHARED_LIB_EXTENSION=.so
    FRAMEWORKS=
    CFLAGS=$ac_saved_cflags
    EXTRA_LIBS=
    AC_DEFINE(PAL_PTRACE(cmd, pid, addr, data), ptrace((cmd), (pid), (caddr_t)(addr), (data)))
    AC_DEFINE(PAL_PT_ATTACH, PT_ATTACH)
    AC_DEFINE(PAL_PT_DETACH, PT_DETACH)
    AC_DEFINE(PAL_PT_READ_D, PT_READ_D)
    AC_DEFINE(PAL_PT_WRITE_D, PT_WRITE_D)
    AC_DEFINE(HAVE_BROKEN_REALPATH)
    dnl For FreeBSD 4.x, we run all threads at the same priority 
    dnl   except for TIME_CRITICAL and IDLE (see bug 235413).
    dnl   This should not be needed with the FreeBSD 5.x ULE scheduler
    AC_DEFINE(PAL_IGNORE_NORMAL_THREAD_PRIORITY, 1)
    dnl SO_RCVTIMEO and SO_SNDTIMEO are ignored by FreeBSD 4.9 and 5.2
    AC_DEFINE(SO_TIMEO_NOT_SUPPORTED)
    AC_DEFINE(SYS_PARAM_DEFINES_MAXHOSTNAMELEN)
    AC_MSG_RESULT(FREEBSD)
elif test "$platform_name" = "Darwin"; then
    dnl libSystem is Darwin's C runtime.
    C_RUNTIME=System
    SHARED_LIB=-dynamiclib
    SHARED_LIB_EXTENSION=.dylib
    FRAMEWORKS="-framework CoreFoundation"
    AC_DEFINE(HAVE_CFSTRING)
    AC_CHECK_LIB(System, _NSGetEnviron, AC_DEFINE(HAVE__NSGETENVIRON))
    DLCOMPAT_DIR=dlcompat
    DLCOMPAT_OBJ="dlcompatobjs.o"
    DLCOMPAT_INC="-I\$(TOP_SRC_DIR)/dlcompat"
    AC_DEFINE(HAVE_BROKEN_REALPATH)
    AC_DEFINE(HAVE_DYLIBS)
    CFLAGS="$ac_saved_cflags -no-cpp-precomp"
    EXTRA_LIBS="-sub_library libSystem"
    CC_SONAME="-install_name \$(MODULE_NAME)"
    AC_DEFINE(PAL_PTRACE(cmd, pid, addr, data), ptrace((cmd), (pid), (caddr_t)(addr), (data)))
    AC_DEFINE(PAL_PT_ATTACH, PT_ATTACH)
    AC_DEFINE(PAL_PT_DETACH, PT_DETACH)
    AC_DEFINE(PAL_PT_READ_D, PT_READ_D)
    AC_DEFINE(PAL_PT_WRITE_D, PT_WRITE_D)
    AC_MSG_RESULT(MACOSX)
elif test "$platform_name" = "SunOS"; then
    C_RUNTIME=c
    SHARED_LIB=-shared
    SHARED_LIB_EXTENSION=.so
    FRAMEWORKS=
    dnl 64-bit Solaris changes
    if test "$_BIT64" = "1"; then
        CFLAGS="$ac_saved_cflags -DBIT64 -D_WIN64"
        CC=/usr/local64/bin/gcc
        CXX=/usr/local64/bin/g++
    else
        CFLAGS=$ac_saved_cflags
    fi
    LIBS="$LIBS -lrt -lsocket -lthread"
    EXTRA_LIBS="-lrt -lsocket -lthread"
    AC_DEFINE(PAL_PTRACE(cmd, pid, addr, data), ptrace((cmd), (pid), (int)(addr), (data)))
    AC_DEFINE(PAL_PT_ATTACH, PTRACE_ATTACH)
    AC_DEFINE(PAL_PT_DETACH, PTRACE_DETACH)
    AC_DEFINE(PAL_PT_READ_D, PTRACE_PEEKDATA)
    AC_DEFINE(PAL_PT_WRITE_D, PTRACE_POKEDATA)
    dnl use of directio is currently disabled
    AC_DEFINE(DIRECTIO_DISABLED)
    dnl SO_RCVTIMEO and SO_SNDTIMEO are not supported by get/setsockopt
    AC_DEFINE(SO_TIMEO_NOT_SUPPORTED)
    AC_DEFINE(NETDB_DEFINES_MAXHOSTNAMELEN)
    AC_MSG_RESULT(SOLARIS)
else
    AC_MSG_ERROR(Unknown Platform!)
fi

AC_SUBST(CC_SONAME)

AC_SUBST(C_RUNTIME)
AC_SUBST(SHARED_LIB)
AC_SUBST(SHARED_LIB_EXTENSION)
AC_SUBST(FRAMEWORKS)
AC_SUBST(DLCOMPAT_DIR)
AC_SUBST(DLCOMPAT_OBJ)
AC_SUBST(DLCOMPAT_INC)
AC_SUBST(CFLAGS)
AC_SUBST(EXTRA_LIBS)
AC_SUBST(ASMFLAGS)
AC_SUBST(ASM_WITH_CPP_FLAGS)
AC_SUBST(MDTOOL_CFLAGS)

dnl Checks for header files go here.
AC_HEADER_STDC
AC_CHECK_HEADERS(wchar.h wctype.h ieeefp.h alloca.h stdint.h inttypes.h)
AC_CHECK_HEADERS(stropts.h sys/vmparam.h sys/filio.h sys/sockio.h)
AC_CHECK_HEADERS(crt_externs.h sys/time.h pthread_np.h)
AC_CHECK_HEADERS(sys/lwp.h procfs.h)
AC_CHECK_HEADERS(sys/param.h netdb.h)

dnl Checks for typedefs, structures, and compiler characteristics go here.
dnl Check if pthread_rwlock_t exists.
AC_MSG_CHECKING(for pthread_rwlock_t)
AC_EGREP_CPP(pthread_rwlock_t, [
    #define _GNU_SOURCE 1
    #include <pthread.h>
    int main(void) { exit(0); }
], ac_has_pthread_rwlock_t=yes, ac_has_pthread_rwlock_t=no)
if test $ac_has_pthread_rwlock_t = yes; then
    AC_MSG_RESULT(yes)
    AC_DEFINE(HAVE_PTHREAD_RWLOCK_T)
else
    AC_MSG_RESULT(no)
fi

dnl Check if in_addr_t exists.
AC_MSG_CHECKING(for in_addr_t)
AC_EGREP_CPP(in_addr_t, [
    #include <sys/types.h>
    int main(void) { exit(0); }
], ac_has_in_addr_t=yes, ac_has_in_addr_t=no)
if test $ac_has_in_addr_t = yes; then
    AC_MSG_RESULT(yes)
    AC_DEFINE(HAVE_IN_ADDR_T)
else
    AC_MSG_RESULT(no)
fi

dnl Check if socklen_t exists.
AC_MSG_CHECKING(for socklen_t)
AC_EGREP_CPP(socklen_t, [
    #include <sys/socket.h>
    int main(void) { exit(0); }
], ac_has_socklen_t=yes, ac_has_socklen_t=no)
if test $ac_has_socklen_t = yes; then
    AC_MSG_RESULT(yes)
    AC_DEFINE(HAVE_SOCKLEN_T)
else
    AC_MSG_RESULT(no)
fi

dnl Check if struct sockaddr_ext exists
AC_MSG_CHECKING(for struct sockaddr_ext)
AC_TRY_COMPILE([#include <sys/socket.h>],
    [struct sockaddr_ext sa;],
    ac_has_sockaddr_ext=yes, ac_has_sockaddr_ext=no)
if test $ac_has_sockaddr_ext = yes; then
    AC_MSG_RESULT(yes)
    AC_DEFINE(HAVE_SOCKADDR_EXT)
else
    AC_MSG_RESULT(no)
fi

dnl Check if siginfo_t exists.
AC_MSG_CHECKING(for siginfo_t)
AC_EGREP_CPP(siginfo_t, [
    #include <signal.h>
    int main(void) { exit(0); }
], ac_has_siginfo_t=yes, ac_has_siginfo_t=no)
if test $ac_has_siginfo_t = yes; then
    AC_MSG_RESULT(yes)
    AC_DEFINE(HAVE_SIGINFO_T)
else
    AC_MSG_RESULT(no)
fi

dnl Check if ucontext_t exists
AC_MSG_CHECKING(for ucontext_t)
AC_EGREP_CPP(ucontext_t, [
    #include <ucontext.h>
    int main(void) { exit(0); }
], ac_has_ucontext_t=yes, ac_has_ucontext_t=no)
if test $ac_has_ucontext_t = yes; then
    AC_MSG_RESULT(yes)
    AC_DEFINE(HAVE_UCONTEXT_T)
else
    AC_MSG_RESULT(no)
fi

dnl Check if prwatch_t exists
AC_MSG_CHECKING(for prwatch_t)
AC_EGREP_CPP(prwatch_t, [
    #undef _LARGEFILE64_SOURCE
    #undef _FILE_OFFSET_BITS
    #include <procfs.h>
    int main(void) { exit(0); }
], ac_has_prwatch_t=yes, ac_has_prwatch_t=no)
if test $ac_has_prwatch_t = yes; then
    AC_MSG_RESULT(yes)
    AC_DEFINE(HAVE_PRWATCH_T)
else
    AC_MSG_RESULT(no)
fi


dnl Check the size of off_t. If it's 32 bits or less, we'll
dnl avoid right-shifting off_t values by 32 in some places.
AC_CHECK_SIZEOF(off_t)

dnl Check if the stat structure supports time in nsecs.
dnl This could be in one of two ways: either the structure has a field
dnl called 'st_atimespec', or a field called 'st_atimensec'.
AC_MSG_CHECKING(for timespec fields in struct stat)
AC_TRY_COMPILE([#include <sys/types.h>
#include <sys/stat.h>], [struct stat s; s.st_atimespec;],
ac_stat_struct_timespec=yes, ac_stat_struct_timespec=no)
if test $ac_stat_struct_timespec = yes; then
    AC_MSG_RESULT(yes)
    AC_DEFINE(HAVE_STAT_TIMESPEC)
else
    AC_MSG_RESULT(no)
    AC_MSG_CHECKING(for nsec fields in struct stat)
    AC_TRY_COMPILE([#include <sys/types.h>
    #include <sys/stat.h>], [struct stat s; s.st_atimensec;],
    ac_stat_struct_nsec=yes, ac_stat_struct_nsec=no)

    if test $ac_stat_struct_nsec = yes; then
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_STAT_NSEC)
    else
        AC_MSG_RESULT(no)
    fi
fi

dnl Check if struct sockaddr has an sa_len field.
AC_MSG_CHECKING(for sa_len field in struct sockaddr)
AC_TRY_COMPILE([#include <sys/types.h>
    #include <sys/socket.h>], [struct sockaddr s; s.sa_len;],
    ac_struct_sockaddr_sa_len=yes, ac_struct_sockaddr_sa_len=no)
if test $ac_struct_sockaddr_sa_len = yes; then
    AC_MSG_RESULT(yes)
    AC_DEFINE(HAVE_SOCKADDR_SA_LEN)
else
    AC_MSG_RESULT(no)
fi

dnl Check whether getpwuid_r exists.
AC_MSG_CHECKING(whether getpwuid_r exists)
AC_TRY_COMPILE([#include <sys/types.h>
    #include <pwd.h>], [getpwuid_r(0, 0, 0, 0, 0);],
    ac_getpwuid_r_exists=yes, ac_getpwuid_r_exists=no)
if test $ac_getpwuid_r_exists = yes; then
    AC_MSG_RESULT(yes)
    AC_DEFINE(HAVE_GETPWUID_R)
else
    AC_MSG_RESULT(no)
fi

dnl Check whether getpwuid_r returns ERANGE or sets errno to ERANGE
AC_MSG_CHECKING(whether getpwuid_r sets errno)
if test $ac_getpwuid_r_exists = no; then
    $ac_getpwuid_r_sets_errno = no
else
    AC_TRY_RUN([
                #include <sys/types.h>
                #include <pwd.h>
                #include <errno.h>
                #include <unistd.h>

                int main(void)
                {
                    struct passwd sPasswd;
                    struct passwd *pPasswd;
                    char buf[1];
                    int bufLen = sizeof(buf)/sizeof(buf[0]);
                    int euid = geteuid();
                    int ret = 0;

                    errno = 0; // clear errno
                    ret = getpwuid_r(euid, &sPasswd, buf, bufLen, &pPasswd);
                    if (0 != ret)
                    {
                        if (ERANGE == errno)
                        {
                            return 0;
                        }
                    }

                    return 1; // assume errno is NOT set for all other cases
                }
                ], 
                ac_getpwuid_r_sets_errno=yes, ac_getpwuid_r_sets_errno=no,
                ac_getpwuid_r_sets_errno=no)
fi
    
if test $ac_getpwuid_r_sets_errno = yes; then
    AC_MSG_RESULT(yes)
    AC_DEFINE(GETPWUID_R_SETS_ERRNO)
else
    AC_MSG_RESULT(no)
fi

dnl Check if realpath requires that the last path component exist.
AC_MSG_CHECKING(whether realpath requires that the last path component exist)
AC_TRY_RUN([
    #include <sys/param.h>
    #include <stdlib.h>
    
    int main(void) {
        char *path;
#ifdef PATH_MAX
        char resolvedPath[PATH_MAX];
#elif defined(MAXPATHLEN)
        char resolvedPath[MAXPATHLEN];
#else
        char resolvedPath[1024];
#endif
        path = realpath("a_nonexistent_file", resolvedPath);
        if (path == NULL) {
            exit(1);
        }
        exit(0);
    }
    ],
    ac_realpath_last_must_exist=no, ac_realpath_last_must_exist=yes,
    ac_realpath_last_must_exist=no)
if test $ac_realpath_last_must_exist = yes; then
    AC_MSG_RESULT(yes)
else
    AC_DEFINE(REALPATH_SUPPORTS_NONEXISTENT_FILES)
    AC_MSG_RESULT(no)
fi

dnl Check to see if the BSD struct reg is supported.
AC_MSG_CHECKING(whether the BSD struct reg is supported)
AC_TRY_COMPILE([#include <machine/reg.h>], [struct reg regs;],
ac_regs_struct_t=yes, ac_regs_struct_t=no)
if test $ac_regs_struct_t = yes; then
    AC_MSG_RESULT(yes)
    AC_DEFINE(HAVE_BSD_REGS_T)
else
    AC_MSG_RESULT(no)
fi

dnl Check for the existence of struct pt_regs (ptrace registers).
AC_MSG_CHECKING(for struct pt_regs)
AC_TRY_COMPILE([#include <asm/ptrace.h>], [struct pt_regs registers;],
               has_pt_regs=yes, has_pt_regs=no)
if test $has_pt_regs = yes; then
    AC_MSG_RESULT(yes)
    AC_DEFINE(HAVE_PT_REGS)
else
    AC_MSG_RESULT(no)
fi

dnl Check to see if mcontext_t has named registers.
if test $ac_has_ucontext_t = yes; then
    AC_MSG_CHECKING(whether mcontext_t contains a gregset_t)
    AC_TRY_COMPILE([#include <ucontext.h>],
                   [ucontext_t context; context.uc_mcontext.gregs[0] = 0;],
                   has_gregset_t=yes, has_gregset_t=no)
    if test $has_gregset_t = yes; then
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_GREGSET_T)
    else
        AC_MSG_RESULT(no)
    fi
fi

dnl Check whether or not it is safe to free NULL
dnl This test is just a screening for old non-C99 compilers.
dnl Even if free(NULL) is not safely supported, this test does
dnl not necessarily detect it, since the behavior in such a case
dnl would be undefined
AC_MSG_CHECKING(whether or not it is safe to free NULL)
AC_RUN_IFELSE([
#include <stdlib.h>
#ifndef NULL
#define NULL ((void*)0)
#endif

int main()
{
    int i;
    char **pp;

    pp = (char **)malloc(10 * sizeof(char *));
    if (pp)
    {
        for (i=0;i<10;i++)
        {
            *(pp+i) = (char*)malloc(i*i+1);
            free(NULL);
        }
    }
    free(NULL);
    if (pp)
    {
        for (i=0;i<10;i++)
        {
            free(*(pp+i));
            free(NULL);
        }
    }
    free(pp);
    exit(0);
};
], free_null_supported=yes, free_null_supported=no, free_null_supported=dontknow)
if test $free_null_supported = yes; then
    AC_MSG_RESULT(yes)
else
    if test $free_null_supported = no; then
        AC_MSG_RESULT(no)
        AC_MSG_ERROR(This platform does not seem to safely support calling free on a NULL pointer: can't continue)
    else
        AC_MSG_RESULT(WARNING: cross-compiling not supported)
    fi
fi

dnl This check is done because FreeBSD's sscanf doesn't seem to support 
dnl the "%ll" (long long) prefix but has "%q" instead.
AC_MSG_CHECKING(supported behavior of sscanf(%ll))
AC_TRY_RUN([
            #include <stdio.h>
            int main(void)
            {
              long long n = 0;                
              sscanf("5000000000", "%qu", &n);
              exit (n == 5000000000);
            }
            ],
            ac_sscanf_support_ll=yes, ac_sscanf_support_ll=no,
            ac_sscanf_support_ll=no)
if test $ac_sscanf_support_ll = yes; then
    AC_DEFINE(SSCANF_SUPPORT_ll)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

dnl Checking whether sscanf is able to parse a float from "12.34e"
AC_MSG_CHECKING(whether sscanf is able to parse a float from "12.34e")
define([sscanf_float_e_limitation_testcode], [
#include <stdio.h>

int main()
{
    int ret;
    float f = 0;
    char * strin = "12.34e";

    ret = sscanf (strin, "%e", &f);
    if (ret <= 0)
        exit (1);
    exit(0);
};
])
AC_LINK_IFELSE([sscanf_float_e_limitation_testcode],,[AC_MSG_ERROR([Failed to compile and link test code])])
AC_RUN_IFELSE([sscanf_float_e_limitation_testcode], has_sscanf_float_e_limitation=no, has_sscanf_float_e_limitation=yes, has_sscanf_float_e_limitation=dontknow)
if test $has_sscanf_float_e_limitation = yes; then
    AC_MSG_RESULT(no)
    AC_DEFINE(SSCANF_CANNOT_HANDLE_MISSING_EXPONENT,1)
else
    if test $has_sscanf_float_e_limitation = no; then
        AC_MSG_RESULT(yes)
    else 
        AC_MSG_RESULT(WARNING: cross-compiling not supported)
    fi
fi

dnl snprintf has trouble when printing "%#x" with large values
dnl of 'n' on some systems.
AC_MSG_CHECKING(whether snprintf supports large values of n)
AC_TRY_RUN([
        #include <stdio.h>

        int main(void) {
            char buf[256] = { 0 };
            snprintf(buf, 0x7fffffff, "%#x", 0x12345678);
            if (buf[0] == '\0') {
                exit(1);
            }
            exit(0);
        }
], has_large_snprintf=yes, has_large_snprintf=no, has_large_snprintf=yes)
if test $has_large_snprintf = yes; then
    AC_DEFINE(HAVE_LARGE_SNPRINTF_SUPPORT)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

dnl Checking whether select() on an open fifo that hasn't been
dnl written to returns that it has data available.
AC_MSG_CHECKING(for broken select() behavior with fifos)
define([broken_select_testcode], [
        #include <stdio.h>
        #include <stdlib.h>       
        #include <fcntl.h>
        #include <string.h>
        #include <sys/stat.h>
        #include <sys/types.h>
        #include <sys/time.h>
        #include <unistd.h>
        
        int main(void) {
            int fd, numFDs;
            fd_set readFDs, writeFDs, exceptFDs;
            struct timeval time = { 0 };
            char * filename = NULL;

            filename = (char *)malloc(L_tmpnam * sizeof(char)); /* ok to leak this at exit */
            if (NULL == filename) {
                exit(1);
            }            
            
            /* On some platforms the multithreading c-runtime does not 
               support the tmpnam(NULL) semantics, and it returns NULL. Therefore 
               we need to use the tmpnam(pbuffer) version.
            */
            if (NULL == tmpnam(filename)) {
                exit(1);
            }
            if (mkfifo(filename, S_IRWXU) != 0) {
                if (unlink(filename) != 0) {
                    exit(1);
                }
                if (mkfifo(filename, S_IRWXU) != 0) {
                    exit(1);
                }
            }
            fd = open(filename, O_RDWR | O_NONBLOCK);
            if (fd == -1) {
                exit(1);
            }
        
            FD_ZERO(&readFDs);
            FD_ZERO(&writeFDs);
            FD_ZERO(&exceptFDs);
            FD_SET(fd, &readFDs);
            numFDs = select(fd + 1, &readFDs, &writeFDs, &exceptFDs, &time);
                
            close(fd);
            unlink(filename);
            
            /* numFDs is zero if select() works correctly */
            exit(numFDs);
        }
])
AC_LINK_IFELSE([broken_select_testcode],,[AC_MSG_ERROR([Failed to compile and link test code])])
AC_RUN_IFELSE([broken_select_testcode], has_broken_fifo_select=no, has_broken_fifo_select=yes, has_broken_fifo_select=dontknow)
case $has_broken_fifo_select in 
    yes) AC_DEFINE(HAVE_BROKEN_FIFO_SELECT)
         AC_MSG_RESULT(yes)
         ;;
    no)  AC_MSG_RESULT(no)
         ;;
    *)   AC_MSG_RESULT(WARNING: cross-compiling not supported)
         ;;
esac

if test $ac_cv_sizeof_off_t -gt 4; then
    dnl Check whether ftruncate'ing a zero-byte file to a very large length
    dnl fails as expected.  Mac OS X's ftruncate returns success in that
    dnl case, even though it actually fails.
    AC_MSG_CHECKING(whether ftruncate correctly fails for very large lengths)
    AC_TRY_RUN([
        #include <fcntl.h>
        #include <stdlib.h>
        #include <string.h>
        #include <unistd.h>
        
        /* INT64_MAX */
        #define OFFSET  9223372036854775807
        
        int main(void) {
            int fd;
            off_t result;
            char filename[1024];
            
            strcpy(filename, "ftruncate_test");
            fd = mkstemp(filename);
            if (fd == -1) {
                exit(1);
            }
        
            result = ftruncate(fd, OFFSET);
            unlink(filename);
            close(fd);
        
            if (result != -1) {
                exit(1);
            }    
            exit(0);
        }
        ], has_ftruncate_large_length_support=yes,
           has_ftruncate_large_length_support=no,
       has_ftruncate_large_length_support=no)
    if test $has_ftruncate_large_length_support = yes; then
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_FTRUNCATE_LARGE_LENGTH_SUPPORT)
    else
        AC_MSG_RESULT(no)
    fi
fi

AC_MSG_CHECKING(for yield system call)
AC_TRY_COMPILE([#include <sys/syscall.h>], [int foo = SYS_yield;],
    ac_has_sys_yield=yes, ac_has_sys_yield=no)
if test $ac_has_sys_yield = yes; then
    AC_DEFINE(HAVE_YIELD_SYSCALL)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

dnl Checks for library functions go here.
AC_CHECK_FUNCS(gmtime_r timegm _snwprintf)
AC_CHECK_FUNCS(futimes sysctl sysconf directio vm_allocate)
AC_CHECK_FUNCS(setcontext getcontext copysign)

dnl Since autoconf 2.57 has problem checking utimes function on HPUX
dnl using AC_CHECK_FUNC, we use AC_TRY_LINK to check utimes function
dnl if AC_CHECK_FUNC cannot find it.
AC_CHECK_FUNC(utimes, ac_has_utimes=yes, ac_has_utimes=no)
if test $ac_has_utimes = yes; then
    AC_DEFINE(HAVE_UTIMES)
else
    AC_MSG_CHECKING(utimes using ac_try_link)
    AC_TRY_LINK([#include <sys/time.h>], [utimes("foo", 0);],
        ac_has_utimes=yes, ac_has_utimes=no)
    if test $ac_has_utimes = yes; then
        AC_DEFINE(HAVE_UTIMES)
        AC_MSG_RESULT(yes)
    else
        AC_MSG_RESULT(no)
    fi
fi

AC_MSG_CHECKING(for POLLRDNORM)
AC_TRY_COMPILE([#include <poll.h>], [int foo = (int) POLLRDNORM;],
    ac_has_pollrdnorm=yes, ac_has_pollrdnorm=no)
if test $ac_has_pollrdnorm = yes; then
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

AC_CHECK_FUNC(poll, ac_has_poll=yes, ac_has_poll=no)
if test $ac_has_poll = yes -a $ac_has_pollrdnorm = yes; then
    POLL_DIR=
    POLL_OBJ=
    AC_DEFINE(HAVE_POLL)
    dnl Check for INFTIM.
    AC_MSG_CHECKING(for INFTIM)
    if test "$platform_name" = "SunOS"; then
        AC_TRY_COMPILE([#include <sys/stropts.h>], [int foo = (int) INFTIM;],
                ac_has_inftim=yes, ac_has_inftim=no)
    else
        AC_TRY_COMPILE([#include <poll.h>], [int foo = (int) INFTIM;],
                ac_has_inftim=yes, ac_has_inftim=no)
    fi
    if test $ac_has_inftim = yes; then
        AC_DEFINE(HAVE_INFTIM)
        AC_MSG_RESULT(yes)
    else
        AC_MSG_RESULT(no)
    fi
else
    POLL_DIR=poll
    POLL_OBJ="pollobjs.o"
fi
AC_SUBST(POLL_DIR)
AC_SUBST(POLL_OBJ)

AC_MSG_CHECKING(for CHAR_BIT)
AC_TRY_COMPILE([#include <sys/limits.h>], [int i = CHAR_BIT;],
    ac_has_char_bits=yes, ac_has_char_bits=no)
if test $ac_has_char_bits = yes; then
    AC_DEFINE(HAVE_CHAR_BIT)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi  

AC_CHECK_FUNC(strtok_r, AC_DEFINE(HAVE_STRTOK_R))
if test $ac_cv_func_strtok_r != yes; then
    AC_MSG_ERROR(strtok_r is required)
fi

AC_CHECK_FUNC(localtime_r, AC_DEFINE(HAVE_LOCALTIME_R))
if test $ac_cv_func_localtime_r != yes; then
    AC_MSG_CHECKING(localtime_r using ac_try_link)
    AC_TRY_LINK([#include <sys/time.h>], [struct tm timer; localtime_r(0, &timer);],
        ac_cv_func_localtime_r=yes, ac_cv_func_localtime_r=no)
    if test $ac_cv_func_localtime_r = yes; then
        AC_DEFINE(HAVE_LOCALTIME_R)
        AC_MSG_RESULT(yes)
    else
        AC_MSG_ERROR(localtime_r is required)
    fi
fi

AC_CHECK_FUNC(ctime_r, AC_DEFINE(HAVE_CTIME_R))
if test $ac_cv_func_ctime_r != yes; then
    AC_MSG_CHECKING(ctime_r using ac_try_link)
    AC_TRY_LINK([#include <sys/time.h>], [struct tm timer; ctime_r(0, &timer);],
        ac_cv_func_ctime_r=yes, ac_cv_func_ctime_r=no)
    if test $ac_cv_func_ctime_r = yes; then
        AC_DEFINE(HAVE_CTIME_R)
        AC_MSG_RESULT(yes)
    else
        AC_MSG_ERROR(ctime_r is required)
    fi
fi

dnl Solaris uses statvfs instead of statfs. It still has statfs
dnl but it's deprecated, so we prefer statvfs if it's available.
dnl We also check if the statvfs64() prototype takes a statvfs64
dnl struct since it does not on Solaris.
AC_CHECK_FUNC(statvfs, AC_DEFINE(HAVE_STATVFS))
if test $ac_cv_func_statvfs != yes; then
    AC_CHECK_FUNC(statfs, AC_DEFINE(HAVE_STATFS))
    if test $ac_cv_func_statfs != yes; then
        AC_MSG_ERROR(Either statfs or statvfs is required)
    fi
else
    AC_MSG_CHECKING(whether statvfs64 prototype is broken)
    saved_cflags="$CFLAGS"
    CFLAGS="-Werror -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64 $CFLAGS"
    define([statvfs64_testcode], [
        #include <sys/types.h>
        #include <sys/statvfs.h>

        int main(void) {
            char NameBuffer[[64]];
            struct statvfs infoBuffer;
            statvfs(NameBuffer, &infoBuffer);
            return 0;
        }
    ])
    AC_COMPILE_IFELSE([statvfs64_testcode],,)
    warn_str=`/usr/bin/tail -20 config.log | grep "statvfs64' from incompatible pointer"`
    if test "$warn_str" = ""; then
        AC_MSG_RESULT(no)
    else
        AC_MSG_RESULT(yes)
        AC_DEFINE(STATVFS64_PROTOTYPE_BROKEN)
    fi
    CFLAGS="$saved_cflags"
fi

dnl Check for thread self calls
AC_CHECK_FUNCS(thread_self _lwp_self)

dnl We need to figure out how to suspend and resume threads.
dnl First, check if we have Mach threads
AC_CHECK_FUNC(pthread_mach_thread_np, ac_has_mach_threads=yes,
              ac_has_mach_threads=no)
if test $ac_has_mach_threads = yes; then
    AC_DEFINE(HAVE_MACH_THREADS)
else
    dnl Perhaps we have Solaris threads. Try thr_suspend.
    AC_CHECK_FUNC(thr_suspend, ac_has_thr_suspend=yes, ac_has_thr_suspend=no)
    if test $ac_has_thr_suspend = yes; then
        AC_DEFINE(HAVE_SOLARIS_THREADS)
    else
        dnl freebsd has pthread_resume_np and pthread_suspend_np in libc_r
        dnl make sure that the pthread library is not in LIBS
        saved_libs="$LIBS"
        LIBS="$no_pthread_libs"
        AC_CHECK_LIB(c_r, pthread_resume_np, ac_pthread_resume_np=yes, ac_pthread_resume_np=no)
        if test $ac_pthread_resume_np = yes; then
            AC_DEFINE(HAVE_PTHREAD_RESUME_NP)
        fi
        AC_CHECK_LIB(c_r, pthread_suspend_np, ac_pthread_suspend_np=yes, ac_pthread_suspend_np=no)
        if test $ac_pthread_suspend_np = yes; then
            AC_DEFINE(HAVE_PTHREAD_SUSPEND_NP)
        fi
        LIBS="$saved_libs"
        dnl check the following pthread functions for AIX and HPUX
        AC_CHECK_FUNCS(pthread_suspend_np pthread_resume pthread_continue_np)   
        if test "$platform_name" = "AIX"; then
            dnl On AIX pthread_continue and pthread_suspend are not functional, so don't test for them
            AC_CHECK_FUNCS(pthread_resume_np)
        elif test "$platform_name" = "HP-UX"; then
            dnl pthread_resume_np on HPUX has an extra flag parameter, so don't test for it
            AC_CHECK_FUNCS(pthread_suspend pthread_continue)
        else
            AC_CHECK_FUNCS(pthread_suspend pthread_continue pthread_resume_np)  
        fi
    fi
fi

dnl Check to see if the system can return the thread priority boundaries
dnl For these tests we need to pass PTHREAD_OPTIONS to the compiler
dnl To do that we'll save CFLAG and restore afterwards
saved_cflags="$CFLAGS"
CFLAGS="$CFLAGS $PTHREAD_OPTIONS"
AC_MSG_CHECKING([for sched_get_priority_[min|max] functionality])
AC_TRY_RUN([
#include <pthread.h>
#include <sched.h>

int main(void)
{
    int policy;
    struct sched_param schedParam;
    int max_priority;
    int min_priority;

    if (0 != pthread_getschedparam(pthread_self(), &policy, &schedParam))
    {
        exit(1);
    }

    max_priority = sched_get_priority_max(policy);
    min_priority = sched_get_priority_min(policy);

    exit(-1 == max_priority || -1 == min_priority);
}
    ], ac_has_sched_get_priorty=yes, ac_has_sched_get_priorty=no, 
       ac_has_sched_get_priorty=no)
if test $ac_has_sched_get_priorty = yes; then
    AC_DEFINE(HAVE_SCHED_GET_PRIORITY)
    AC_MSG_RESULT(yes)
else
    if test "$platform_name" = "AIX"; then
        AC_DEFINE(PAL_THREAD_PRIORITY_MAX, 127)
        AC_DEFINE(PAL_THREAD_PRIORITY_MIN, 1)
        AC_MSG_RESULT(no; using AIX values of 1-127)
    else
        AC_MSG_RESULT(no; don't know proper values for this platform)
    fi
fi
CFLAGS="$saved_cflags"


dnl Check for thread_set_exception_ports. If it exists, we have Mach
dnl exceptions, and we'll use those in place of our signal handlers.
AC_CHECK_FUNC(thread_set_exception_ports, ac_has_mach_exceptions=yes,
              ac_has_mach_exceptions=no)
if test $ac_has_mach_exceptions = yes; then
    AC_DEFINE(HAVE_MACH_EXCEPTIONS)
fi

dnl Check for vm_read_overwrite. If it exists, we have Mach VM
dnl read/write functions, and we'll use those in place of ptrace.
AC_CHECK_FUNC(vm_read_overwrite, ac_has_vm_read_overwrite=yes,
              ac_has_vm_read_overwrite=no)
if test $ac_has_vm_read_overwrite = yes; then
    AC_DEFINE(HAVE_VM_READ)
fi  

if test $ac_bad_sigreturn_in_libc_r = no; then
    dnl Check for sigreturn in libc_r. If it's there, we can call it. If not,
    dnl check for _thread_sys_sigreturn. FreeBSD 4.4 doesn't alias
    dnl _thread_sys_sigreturn to sigreturn in libc_r.
    AC_CHECK_LIB(c_r, sigreturn, ac_has_sigreturn=yes, ac_has_sigreturn=no, $PTHREAD_OPTIONS)
    if test $ac_has_sigreturn = yes; then
        AC_DEFINE(HAVE_SIGRETURN)
    else
        dnl Check for _thread_sys_sigreturn now.
        AC_CHECK_LIB(c_r, _thread_sys_sigreturn, ac_has_thread_sys_sigreturn=yes,
                     ac_has_thread_sys_sigreturn=no, -pthread)
        if test $ac_has_thread_sys_sigreturn = yes; then
            AC_DEFINE(HAVE__THREAD_SYS_SIGRETURN)
        fi
    fi
fi    

dnl Determine whether tzname is supported. tzname is not the
dnl preferred means of reading time zone names on Unix, but
dnl its (at times incorrect) distinction between standard and
dnl daylight saving times is required for the PAL.
AC_MSG_CHECKING(for tzname global variable)
AC_TRY_LINK([#include <time.h>], [char *c = tzname[0];],
ac_tzname_var=yes, ac_tzname_var=no)
if test $ac_tzname_var = yes; then
    AC_MSG_RESULT(yes)
    AC_DEFINE(HAVE_TZNAME)
else
    AC_MSG_RESULT(no)
fi

dnl Figure out where to get the offset of this timezone.
dnl Many SysV systems have an extern timezone, while BSD
dnl systems typically have a tm_gmtoff field in struct tm.
dnl We prefer the BSD version, but we can use the SysV one
dnl if necessary.
dnl The SysV solution is insufficient for cases in which a
dnl timezone's GMT offset is dependent on the current date,
dnl as is the case for countries whose time zone has varied
dnl over the years.
AC_MSG_CHECKING(for tm_gmtoff field in struct tm)
AC_TRY_COMPILE([#include <time.h>], [struct tm t; t.tm_gmtoff;],
ac_tm_struct_gmtoff=yes, ac_tm_struct_gmtoff=no)
if test $ac_tm_struct_gmtoff = yes; then
    AC_MSG_RESULT(yes)
    AC_DEFINE(HAVE_TM_GMTOFF)
else
    AC_MSG_RESULT(no)
    AC_MSG_CHECKING(for timezone global variable)
    AC_TRY_LINK([#include <time.h>], [extern long int timezone;],
    ac_timezone_var=yes, ac_timezone_var=no)
    if test $ac_timezone_var = yes; then
        AC_MSG_RESULT(yes)
        AC_DEFINE(HAVE_TIMEZONE_VAR)
    else
        AC_MSG_RESULT(no)
        AC_MSG_ERROR(Either tm_gmtoff in struct tm or extern timezone is required)
    fi
fi

dnl Checking whether mmap() can shared-map from /dev/zero
AC_MSG_CHECKING(for mmap(MAP_SHARED) of /dev/zero)
AC_TRY_RUN([
        #include <stdlib.h>
        #include <sys/types.h>
        #include <sys/mman.h>
        #include <fcntl.h>

        int main(void) {
            int devzero;
            void *retval;

            devzero = open("/dev/zero", O_RDWR);
            if (-1 == devzero) {
                exit(1);
            }
            retval = mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_SHARED, devzero, 0);
            if (retval == (void *)-1) {
                exit(1);
            }
            exit(0);
        }
], has_mmap_dev_zero=yes, has_mmap_dev_zero=no,
   has_mmap_dev_zero=no)
if test $has_mmap_dev_zero = yes; then
    AC_DEFINE(HAVE_MMAP_DEV_ZERO)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

dnl Checking whether mmap uses its hint parameter
AC_MSG_CHECKING(whether mmap uses its hint parameter)
AC_TRY_RUN([
    #include <fcntl.h>
    #include <stdlib.h>
    #include <sys/types.h>
    #include <sys/mman.h>
    #include <unistd.h>

    #ifndef MAP_ANON
    #define MAP_ANON MAP_ANONYMOUS
    #endif
    
    int main(void) {
        void *hint, *ptr;
        int pagesize;
        int fd;
        
        pagesize = getpagesize();
        fd = open("/etc/passwd", O_RDONLY);
        if (fd == -1) {
            exit(1);
        }
        ptr = mmap(NULL, pagesize, PROT_NONE, MAP_ANON | MAP_PRIVATE, -1, 0);
        if (ptr == MAP_FAILED) {
            exit(1);
        }
        hint = mmap(NULL, pagesize, PROT_NONE, MAP_ANON | MAP_PRIVATE, -1, 0);
        if (hint == MAP_FAILED) {
            exit(1);
        }
        if (munmap(ptr, pagesize) != 0) {
            exit(1);
        }
        if (munmap(hint, pagesize) != 0) {
            exit(1);
        }
        ptr = mmap(hint, pagesize, PROT_NONE, MAP_PRIVATE, fd, 0);
        if (ptr == MAP_FAILED || ptr != hint) {
            exit(1);
        }
        exit(0);
    }
], mmap_ignores_hint=no, mmap_ignores_hint=yes, mmap_ignores_hint=yes)
if test $mmap_ignores_hint = yes; then
    AC_DEFINE(MMAP_IGNORES_HINT)
    AC_MSG_RESULT(no)
else
    AC_MSG_RESULT(yes)
    dnl Check whether mmap ignores its protection parameter when mapping
    dnl anonymous pages.
    AC_MSG_CHECKING(whether mmap ignores PROT_NONE when mapping anonymously)
    AC_TRY_RUN([
        #include <sys/types.h>
        #include <sys/mman.h>
        #include <signal.h>
        #include <stdlib.h>
        #include <unistd.h>

        #ifndef MAP_ANON
        #define MAP_ANON MAP_ANONYMOUS
        #endif

        int handle_signal(int signal) {
            /* If we reach this, we've crashed due to mmap honoring
               PROT_NONE. */
            _exit(1);
        }

        int main(void) {
            int *ptr;
            struct sigaction action;
            
            ptr = (int *) mmap(NULL, getpagesize(), PROT_NONE,
                               MAP_ANON | MAP_PRIVATE, -1, 0);
            if (ptr == (int *) MAP_FAILED) {
                exit(0);
            }
            action.sa_handler = &handle_signal;
            action.sa_flags = 0;
            sigemptyset(&action.sa_mask);
            if (sigaction(SIGBUS, &action, NULL) != 0) {
                exit(0);
            }
            if (sigaction(SIGSEGV, &action, NULL) != 0) {
                exit(0);
            }
            /* This will drop us into the signal handler if PROT_NONE
               is honored. */
            *ptr = 123;
            exit(0);
        }
    ], has_mmap_protections=no, has_mmap_protections=yes,
       has_mmap_protections=no)
    if test $has_mmap_protections = yes; then
        AC_MSG_RESULT(no)
    else
        AC_DEFINE(MMAP_ANON_IGNORES_PROTECTION)
        AC_MSG_RESULT(yes)
    fi
fi

dnl Checking whether it is legal to call mmap(MAP_FIXED) on an already mapped region
AC_MSG_CHECKING(whether it is legal to call mmap(MAP_FIXED) on an already mapped region)
define([mmap_remap_testcode], [
    #include <stdlib.h>
    #include <unistd.h>
    #include <sys/types.h>
    #include <sys/mman.h>

    #ifndef MAP_ANON
    #define MAP_ANON MAP_ANONYMOUS
    #endif

    int main()
    {
      int iRet = 0;
      void * pAddr = MAP_FAILED;
      int MemSize = 1024;

      MemSize = getpagesize();
      pAddr = mmap(0x0, MemSize, PROT_NONE, MAP_PRIVATE | MAP_ANON, -1, 0);
      if (pAddr == MAP_FAILED)
        exit(1);

      pAddr = mmap(pAddr, MemSize, PROT_WRITE | PROT_READ, MAP_FIXED | MAP_PRIVATE | MAP_ANON, -1, 0);
      if (pAddr == MAP_FAILED)
        iRet = 1;

      munmap(pAddr, MemSize); // don't care of this
      exit (iRet);
    }
])
AC_LINK_IFELSE([mmap_remap_testcode],,[AC_MSG_ERROR([Failed to compile and link test code])])
AC_RUN_IFELSE([mmap_remap_testcode], mmap_allows_remap=yes, mmap_allows_remap=no, mmap_allows_remap=dontknow)
if test $mmap_allows_remap = yes; then
    AC_MSG_RESULT(yes)
else
    if test $mmap_allows_remap = no; then
        AC_DEFINE(MMAP_DOESNOT_ALLOW_REMAP,1)
        AC_MSG_RESULT(no)
    else 
        AC_MSG_RESULT(WARNING: cross-compiling not supported)
    fi
fi

dnl Checking whether a file region may be shared-mapped twice in the same process
AC_MSG_CHECKING(whether a file region may be shared-mapped twice in the same process)
define([mmap_multiple_shared_mappings_testcode], [
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/mman.h>

#define MEM_SIZE 1024

int main(void)
{
    char * fname;
    int fd;
    int ret;
    void * pAddr0, * pAddr1;

    fname = (char *)malloc(MEM_SIZE);
    if (!fname)
        exit(1);
    strcpy(fname, "multiplemaptestXXXXXX");

    fd = mkstemp(fname);
    if (fd < 0)
        exit(1);

    ret = write (fd, (void *)fname, MEM_SIZE);
    if (ret < 0)
        exit(1);

    pAddr0 = mmap(0, MEM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    pAddr1 = mmap(0, MEM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

    /* In theory we should look for (pAddr1 == MAP_FAILED) && (pAddr1 != MAP_FAILED)
       but in case the first test also failed, i.e. we failed to run the test,
       let's assume that the system might not allow multiple shared mapping of the
       same file region in the same process. The code enabled in this case is
       only a fall-back code path. In case the double mmap actually works, virtually
       nothing will change and the normal code path will be executed */
    if (pAddr1 == MAP_FAILED)
        ret = 1;
    else
        ret = 0;

    if (pAddr0)
        munmap (pAddr0, MEM_SIZE);
    if (pAddr1)
        munmap (pAddr1, MEM_SIZE);
    close(fd);
    unlink(fname);
    free(fname);

    exit(ret);
}
])
AC_LINK_IFELSE([mmap_multiple_shared_mappings_testcode],,[AC_MSG_ERROR([Failed to compile and link test code])])
AC_RUN_IFELSE([mmap_multiple_shared_mappings_testcode], mmap_allows_multiple_shared_mappings=yes, mmap_allows_multiple_shared_mappings=no, mmap_allows_multiple_shared_mappings=dontknow)
if test $mmap_allows_multiple_shared_mappings = yes; then
    AC_MSG_RESULT(yes)
else
    if test $mmap_allows_multiple_shared_mappings = no; then
        AC_DEFINE(ONE_SHARED_MAPPING_PER_FILEREGION_PER_PROCESS,1)
        AC_MSG_RESULT(no)
    else 
        AC_MSG_RESULT(WARNING: cross-compiling not supported)
    fi
fi

dnl Checking whether shutdown fails on connectionless sockets
AC_MSG_CHECKING(whether shutdown fails on connectionless sockets)
define([shutdown_testcode], [
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>

int main()
{
  int ret = 0;
  int s;
  struct sockaddr_in targetAddr;
  char buff[10];

  s = socket(AF_INET, SOCK_DGRAM, 0);
  if (-1 == s)
  {
    exit (1);
  }

  memset (&targetAddr, 0, sizeof(targetAddr));
  targetAddr.sin_family = AF_INET;
  targetAddr.sin_addr.s_addr = htonl(inet_addr("127.0.0.1"));
  targetAddr.sin_port = htons(11000);

  ret = shutdown(s,2);
  if ((ret < 0) && (errno == ENOTCONN))
    ret = 0;
  else
    ret = 1;

  close(s);
  exit(ret);
}
])
SHUTDOWNTEST_OLDCFLAGS=$CFLAGS
if test "$platform_name" = "SunOS"; then
   CFLAGS="$CFLAGS -lsocket -lnsl"   
fi
AC_LINK_IFELSE([shutdown_testcode],,[AC_MSG_ERROR([Failed to compile and link test code])])
AC_RUN_IFELSE([shutdown_testcode], shutdown_fails_on_connectionless_sockets=yes, shutdown_fails_on_connectionless_sockets=no, shutdown_fails_on_connectionless_sockets=dontknow)
if test $shutdown_fails_on_connectionless_sockets = yes; then
    AC_DEFINE(SHUTDOWN_FAILS_ON_CONNECTIONLESS_SOCKETS,1)
    AC_MSG_RESULT(yes)
else
    if test $shutdown_fails_on_connectionless_sockets = no; then
        AC_MSG_RESULT(no)
    else 
        AC_MSG_RESULT(WARNING: cross-compiling not supported)
    fi
fi
CFLAGS=$SHUTDOWNTEST_OLDCFLAGS

dnl Checking whether it is possible to broadcast on a socket without SO_BROADCAST
AC_MSG_CHECKING(whether it is possible to broadcast on a socket without SO_BROADCAST)
define([broadcast_testcode], [
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <errno.h>

int main()
{
    int ret = 0;
    int ival = 0;
    int s;
    struct sockaddr_in targetAddr;
    char chr;

    s = socket(AF_INET, SOCK_DGRAM, 0);
    if (-1 == s)
    {
        exit (1);
    }

    /* Make sure SO_BROADCAST it is off (it should be by default) */
    ret = setsockopt(s, SOL_SOCKET, SO_BROADCAST, (char *)&ival, sizeof(int));
    if (-1 == ret)
    {
        exit (1);
    }

    memset (&targetAddr, 0, sizeof(targetAddr));
    targetAddr.sin_family = AF_INET;
    targetAddr.sin_addr.s_addr = htonl(inet_addr("255.255.255.255"));
    targetAddr.sin_port = htons(11000);

    ret = sendto(s, &chr, 1, 0, (struct sockaddr *)&targetAddr, sizeof(targetAddr));
    if ((ret < 0) && (errno == EACCES))
        ret = 1;
    else
        ret = 0;

    close(s);
    exit(ret);
}
])
BROADCASTTEST_OLDCFLAGS=$CFLAGS
if test "$platform_name" = "SunOS"; then
   CFLAGS="$CFLAGS -lsocket -lnsl"
fi
AC_COMPILE_IFELSE([broadcast_testcode],,[AC_MSG_ERROR([Failed to just compile test code])])
AC_LINK_IFELSE([broadcast_testcode],,[AC_MSG_ERROR([Failed to compile and link test code])])
AC_RUN_IFELSE([broadcast_testcode], broadcast_without_so_broadcast=yes, broadcast_without_so_broadcast=no, broadcast_without_so_broadcast=dontknow)
if test $broadcast_without_so_broadcast = yes; then
    AC_DEFINE(BROADCAST_ALLOWED_WITHOUT_SO_BROADCAST,1)
    AC_MSG_RESULT(yes)
else
    if test $broadcast_without_so_broadcast = no; then
        AC_MSG_RESULT(no)
    else 
        AC_MSG_RESULT(WARNING: cross-compiling not supported)
    fi
fi
CFLAGS=$BROADCASTTEST_OLDCFLAGS

AC_MSG_CHECKING(whether pthread_create modifies errno on success)
AC_TRY_RUN([
#include <errno.h>
#include <pthread.h>
#include <stdlib.h>

void *start_routine(void *param) { return NULL; }

int main() {
    int result;
    pthread_t tid;

    errno = 0;
    result = pthread_create(&tid, NULL, start_routine, NULL);
    if (result != 0) {
        exit(0);
    }
    if (errno != 0) {
        exit(1);
    }
    exit(0);
}
], pthread_create_modifies_errno=no, pthread_create_modifies_errno=yes,
   pthread_create_modifies_errno=no)
if test $pthread_create_modifies_errno = yes; then
    AC_DEFINE(PTHREAD_CREATE_MODIFIES_ERRNO)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

dnl Define a new macro to check for the existence of a file under /proc/<pid>
dnl The first argument is the name of the file to check for (e.g., ctl)
dnl The second argument is the mode to use to open the file (e.g., O_WRONLY)
define([check_procfs_file], [[
    #include <fcntl.h>
    #include <stdlib.h>
    #include <stdio.h>
    #include <unistd.h>

    int main(void) {
        int fd;
    #ifdef PATH_MAX
        char path[PATH_MAX];
    #elif defined(MAXPATHLEN)
        char path[MAXPATHLEN];
    #else
        char path[1024];
    #endif
        
        sprintf(path, "/proc/%u/$1", getpid());
        fd = open(path, $2);
        if (fd == -1) {
            exit(1);
        }
        exit(0);
    }
]])

AC_MSG_CHECKING(whether /proc/<pid>/ctl is supported)
AC_TRY_RUN(check_procfs_file([ctl], [O_WRONLY]),
    has_procfs_ctl=yes, has_procfs_ctl=no, has_procfs_ctl=no)
if test $has_procfs_ctl = yes; then
    AC_DEFINE(HAVE_PROCFS_CTL)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

if test $has_procfs_ctl = yes; then
    AC_MSG_CHECKING(if memory is accessed through /proc/<pid>/as)
    AC_TRY_RUN(check_procfs_file([as], [O_RDONLY]),
        has_procfs_as=yes, has_procfs_as=no, has_procfs_as=no)
    if test $has_procfs_as = yes; then
        AC_DEFINE(PROCFS_MEM_NAME,["as"])
        AC_MSG_RESULT(yes)
    else
        AC_MSG_RESULT(no)
        AC_MSG_CHECKING(if memory is accessed through /proc/<pid>/mem)
        AC_TRY_RUN(check_procfs_file([mem], [O_RDONLY]),
            has_procfs_mem=yes, has_procfs_mem=no, has_procfs_mem=no)
        if test $has_procfs_mem = yes; then
            AC_DEFINE(PROCFS_MEM_NAME,["mem"])
            AC_MSG_RESULT(yes)
        else
            AC_MSG_RESULT(no)
        fi
    fi
elif test $ac_has_vm_read_overwrite = no; then
    dnl Check for ttrace. If it exists we'll use it in preference to ptrace,
    dnl which is not supported on HP-UX/IA64.
    AC_CHECK_FUNC(ttrace, ac_has_ttrace=yes, ac_has_ttrace=no)
    if test $ac_has_ttrace = yes; then
        AC_DEFINE(HAVE_TTRACE)
    fi
fi

AC_MSG_CHECKING(whether exp of 1.0 is exactly e)
AC_TRY_RUN([
#include <math.h>
#include <stdlib.h>

int main(void) {
    double d = exp(1.0), e = M_E;

    /* Used memcmp rather than == to test that the doubles are equal to
    prevent gcc's optimizer from using its 80 bit internal long
    doubles. If you use ==, then on BSD you get a false negative since
    exp(1.0) == M_E to 64 bits, but not 80.
     */
        
    if (memcmp (&d, &e, sizeof (double)) == 0) {
        exit(0);
    }
    exit(1);
}
], has_compatible_exp=yes, has_compatible_exp=no, has_compatible_exp=yes)
if test $has_compatible_exp = yes; then
    AC_DEFINE(HAVE_COMPATIBLE_EXP)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

AC_MSG_CHECKING(whether acos returns NaN on invalid input)
AC_TRY_RUN([
#include <math.h>
#include <stdlib.h>

int main(void) {
    if (!isnan(acos(10))) {
        exit(1);
    }
    exit(0);
}
], has_compatible_acos=yes, has_compatible_acos=no, has_compatible_acos=yes)
if test $has_compatible_acos = yes; then
    AC_DEFINE(HAVE_COMPATIBLE_ACOS)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

AC_MSG_CHECKING(whether asin returns NaN on invalid input)
AC_TRY_RUN([
#include <math.h>
#include <stdlib.h>

int main(void) {
    if (!isnan(asin(10))) {
        exit(1);
    }
    exit(0);
}
], has_compatible_asin=yes, has_compatible_asin=no, has_compatible_asin=yes)
if test $has_compatible_asin = yes; then
    AC_DEFINE(HAVE_COMPATIBLE_ASIN)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

AC_MSG_CHECKING(whether pow returns expected results for edge cases)
AC_TRY_RUN([
#include <math.h>
#include <stdlib.h>

int main(void) {
    double infinity = 1.0 / 0.0;
    if (!isnan(pow(1.0, infinity))) {
        exit(1);
    }
    if (pow(0.0, -1) != infinity) {
        exit(1);
    }
    exit(0);
}
], has_compatible_pow=yes, has_compatible_pow=no, has_compatible_pow=yes)
if test $has_compatible_pow = yes; then
    AC_DEFINE(HAVE_COMPATIBLE_POW)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

AC_MSG_CHECKING(whether pow correctly handles x**y for negative x and large magnitude odd y)
AC_TRY_RUN([
#include <math.h>
#include <stdlib.h>

int main(int argc, char **argv) {
    double result;

    result = pow(-3.2e-10, -5e14 + 1);
    if (result != -1.0 / 0.0) {
        exit(1);
    }
    exit(0);
}
], has_valid_negative_inf_pow=yes, has_valid_negative_inf_pow=no)
if test $has_valid_negative_inf_pow = yes; then
    AC_DEFINE(HAVE_VALID_NEGATIVE_INF_POW)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

AC_MSG_CHECKING(whether pow correctly handles x**y for negative x and large magnitude even y)
AC_TRY_RUN([
#include <math.h>
#include <stdlib.h>

int main(int argc, char **argv) {
    double result;

    result = pow(-3.5, 3e100);
    if (result != 1.0 / 0.0) {
        exit(1);
    }
    exit(0);
}
], has_valid_positive_inf_pow=yes, has_valid_positive_inf_pow=no)
if test $has_valid_positive_inf_pow = yes; then
    AC_DEFINE(HAVE_VALID_POSITIVE_INF_POW)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

AC_MSG_CHECKING(atan2 boundary conditions are same as on windows)
AC_TRY_RUN([
#include <math.h>
#include <stdlib.h>

int main(void) {
    double pi = 3.14159265358979323846;
    double result;
    
    result = atan2(0.0, -0.0);
    if (fabs(pi - result) > 0.0000001) {
        exit(1);
    }

    result = atan2(-0.0, -0.0);
    if (fabs(-pi - result) > 0.0000001) {
        exit(1);
    }

    result = atan2 (-0.0, 0.0);
    if (result != 0.0 || copysign (1.0, result) > 0) {
        exit(1);
    }

    result = atan2 (0.0, 0.0);
    if (result != 0.0 || copysign (1.0, result) < 0) {
        exit(1);
    }

    exit (0);
}
], has_compatible_atan2=yes, has_compatible_atan2=no,
   has_compatible_atan2=yes)
if test $has_compatible_atan2 = yes; then
    AC_DEFINE(HAVE_COMPATIBLE_ATAN2)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

AC_MSG_CHECKING(whether log returns NaN when x is negative)
AC_TRY_RUN([
#include <math.h>
#include <stdlib.h>

int main(void) {
    if (!isnan(log(-10000))) {
        exit(1);
    }
    exit(0);
}
], has_compatible_log=yes, has_compatible_log=no, has_compatible_log=yes)
if test $has_compatible_log = yes; then
    AC_DEFINE(HAVE_COMPATIBLE_LOG)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

AC_MSG_CHECKING(whether log10 returns NaN when x is negative)
AC_TRY_RUN([
#include <math.h>
#include <stdlib.h>

int main(void) {
    if (!isnan(log10(-10000))) {
        exit(1);
    }
    exit(0);
}
], has_compatible_log10=yes, has_compatible_log10=no,
   has_compatible_log10=yes)
if test $has_compatible_log10 = yes; then
    AC_DEFINE(HAVE_COMPATIBLE_LOG10)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

AC_MSG_CHECKING(whether ungetc does not return EOF on write-only file)
AC_TRY_RUN([
#include <stdio.h>

int main(void)
{
    char* szFileName;
    FILE* pFile = NULL;
    int ret = 0;

    szFileName = tempnam(".", "tmp");

    /* open the file write-only */
    pFile = fopen(szFileName, "a");
    if (pFile == NULL)
    {
        exit(1);
    }
    if (ungetc('A', pFile) != EOF)
    {
        ret = 1;
    }
    unlink(szFileName);
    exit(ret);
}
], ungetc_not_return_eof=no, ungetc_not_return_eof=yes,
   ungetc_not_return_eof=no)
if test $ungetc_not_return_eof = yes; then
    AC_DEFINE(UNGETC_NOT_RETURN_EOF)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

AC_MSG_CHECKING(whether malloc(0) returns NULL)
AC_TRY_RUN([
#include <stdlib.h>

int main(void)
{
    void *p;

    p = malloc(0);

    if (p == NULL)
    {
        exit(0);
    }

    exit(1);
}
], malloc_zero_returns_null=yes, malloc_zero_returns_null=no,
   malloc_zero_returns_null=yes)
if test $malloc_zero_returns_null = yes; then
    AC_DEFINE(MALLOC_ZERO_RETURNS_NULL)
    AC_MSG_RESULT(yes)
else
    AC_MSG_RESULT(no)
fi

dnl Define a new macro to check locale name
dnl The first argument of this macro is the locale name to be checked.
define([check_locale_name], [
    #include <locale.h>
    
    int main(void) {
        char *locale;
        
        locale = setlocale(LC_CTYPE, "$1");
        /* locale is NULL if the locale is not supported. */
        exit(locale == NULL);
    }
])

dnl Check the the name of ISO locale.
dnl The known acceptable format are:
dnl FreeBSD 4.4: en_US.ISO_8859-1
dnl FreeBSD 4.5 or later: en_US.ISO_8859-1 or en_US.ISO8859-1
dnl MacOSX, Solaris, AIX: en_US.ISO8859-1
dnl HPUX: en_US.iso88591
AC_MSG_CHECKING(for the name of ISO locale)
AC_TRY_RUN(check_locale_name([en_US.ISO8859-1]),
    ac_has_standard_iso_name=yes, ac_has_standard_iso_name=no,
    ac_has_standard_iso_name=no)
if test $ac_has_standard_iso_name = yes; then
    AC_MSG_RESULT(en_US.ISO8859-1)
else
    AC_TRY_RUN(check_locale_name([en_US.iso88591]),
        ac_has_lowercase_iso_name=yes, ac_has_lowercase_iso_name=no,
        ac_has_lowercase_iso_name=no)
    if test $ac_has_lowercase_iso_name = yes; then
        AC_DEFINE(HAVE_LOWERCASE_ISO_NAME)
        AC_MSG_RESULT(en_US.iso88591)
    else
        AC_TRY_RUN(check_locale_name([en_US.ISO_8859-1]),
            ac_has_underscore_iso_name=yes, ac_has_underscore_iso_name=no,
            ac_has_underscore_iso_name=no)
        if test $ac_has_underscore_iso_name = yes; then
            AC_DEFINE(HAVE_UNDERSCORE_ISO_NAME)
            AC_MSG_RESULT(en_US.ISO_8859-1)
        else
            AC_MSG_RESULT(cannot find en_US.ISO8859-1 locale)
        fi
    fi           
fi

AC_MSG_CHECKING(for the name of the Shift-JIS locale)
AC_TRY_RUN(check_locale_name([ja_JP.SJIS]),
    ac_has_shift_jis=yes, ac_has_shift_jis=no, ac_has_shift_jis=no)
if test $ac_has_shift_jis = yes; then
    AC_DEFINE(JA_JP_LOCALE_NAME,["ja_JP.SJIS"])    
    AC_MSG_RESULT(ja_JP.SJIS)
else
    AC_TRY_RUN(check_locale_name([ja_JP.PCK]),
        ac_has_ja_jp_pck=yes, ac_has_ja_jp_pck=no, ac_has_ja_jp_pck=no)
    if test $ac_has_ja_jp_pck = yes; then
        AC_DEFINE(JA_JP_LOCALE_NAME,["ja_JP.PCK"]) 
        AC_MSG_RESULT(ja_JP.PCK)
    else
        AC_DEFINE(JA_JP_LOCALE_NAME,["ja_JP_LOCALE_NOT_FOUND"])        
        AC_MSG_RESULT(cannot find ja_JP locale)
    fi
fi

AC_MSG_CHECKING(for the name of the ko_KR locale)
AC_TRY_RUN(check_locale_name([ko_KR.eucKR]),
    ac_has_ko_euc_kr=yes, ac_has_ko_euc_kr=no, ac_has_ko_euc_kr=no)
if test $ac_has_ko_euc_kr = yes; then
    AC_DEFINE(KO_KR_LOCALE_NAME,["ko_KR.eucKR"]) 
    AC_MSG_RESULT(ko_KR.eucKR)
else
    AC_TRY_RUN(check_locale_name([ko_KR.EUC]),
        ac_has_ko_euc=yes, ac_has_ko_euc=no, ac_has_ko_euc=no)
    if test $ac_has_ko_euc = yes; then
        AC_DEFINE(KO_KR_LOCALE_NAME,["ko_KR.EUC"]) 
        AC_MSG_RESULT(ko_KR.EUC)
    else
        AC_DEFINE(KO_KR_LOCALE_NAME,["ko_KR_LOCALE_NOT_FOUND"])        
        AC_MSG_RESULT(cannot find ko_KR locale)    
    fi
fi

AC_MSG_CHECKING(for the name of the Big 5 locale)
AC_TRY_RUN(check_locale_name([zh_TW.BIG5]),
    ac_has_caps_big5=yes, ac_has_caps_big5=no, ac_has_caps_big5=no)
if test $ac_has_caps_big5 = yes; then
    AC_DEFINE(ZH_TW_LOCALE_NAME,["zh_TW.BIG5"]) 
    AC_MSG_RESULT(zh_TW.BIG5)
else
    AC_TRY_RUN(check_locale_name([zh_TW.big5]),
    ac_has_lowercase_big5=yes, ac_has_lowercase_big5=no, ac_has_lowercase_big5=no)
    if test $ac_has_lowercase_big5 = yes; then 
        AC_DEFINE(ZH_TW_LOCALE_NAME,["zh_TW.big5"]) 
        AC_MSG_RESULT(zh_TW.big5)
    else
        AC_TRY_RUN(check_locale_name([zh_TW.Big5]),
        ac_has_titlecase_big5=yes, ac_has_titlecase_big5=no, ac_has_titlecase_big5=no)
        if test $ac_has_titlecase_big5 = yes; then 
            AC_DEFINE(ZH_TW_LOCALE_NAME,["zh_TW.Big5"]) 
            AC_MSG_RESULT(zh_TW.Big5)
        else    
            AC_DEFINE(ZH_TW_LOCALE_NAME,["zh_TW_LOCALE_NOT_FOUND"])        
            AC_MSG_RESULT(cannot find zh_TW locale)
        fi
    fi    
fi


dnl !!!!  The absolute paths in the AC_OUTPUT must stay there, if you use relative paths instead (like ../..) the files will be generated at the right
dnl   place, but they will contain wrong values for some variables (especially TOP_SRC_DIR). The only way to work this around I was able to find
dnl   is by using the absolute paths. The only disadvantage of this is, that during the configure run it will output error emssages that it can't
dnl   go to some subdirectories (it will try to add this absolute path to the current directory path), but that's no problem since
dnl   even these messages all works fine.

AC_OUTPUT([
makefile:../../makefile.in
makefile.common:../../makefile.common.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/arch/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../arch/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/arch/$ARCH_DIR/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../arch/$ARCH_DIR/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/cruntime/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../cruntime/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/debug/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../debug/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/dlcompat/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../dlcompat/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/exception/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../exception/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/file/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../file/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/handlemgr/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../handlemgr/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/loader/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../loader/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/locale/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../locale/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/map/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../map/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/memory/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../memory/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/misc/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../misc/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/init/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../init/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/poll/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../poll/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/shmemory/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../shmemory/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/socket/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../socket/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/sync/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../sync/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/thread/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../thread/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/examples/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../examples/makefile.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/build_tools/obj${BUILD_ALT_DIR}/${_BUILDARCH}/mdtool_gcc:../../build_tools/mdtool_gcc.in
$ROTOR_DIR/pal/$PAL_UNIX_DIR/build_tools/obj${BUILD_ALT_DIR}/${_BUILDARCH}/makefile:../../build_tools/makefile.in ])

dnl mdtool_gcc is a shell script; it needs to be executable.
AC_OUTPUT_COMMANDS([ chmod +x $ROTOR_DIR/pal/$PAL_UNIX_DIR/build_tools/obj${BUILD_ALT_DIR}/${_BUILDARCH}/mdtool_gcc ])

dnl put the path of all output files to config.output_files
dnl for checkconfig.pl to read.
echo $ac_config_headers > config.output_files
echo $ac_config_files >> config.output_files

echo
echo "Configure finished.  Do 'make depend && make' to compile the PAL."
echo
