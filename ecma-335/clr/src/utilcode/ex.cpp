// ==++==
// 
//   
//    Copyright (c) 2006 Microsoft Corporation.  All rights reserved.
//   
//    The use and distribution terms for this software are contained in the file
//    named license.txt, which can be found in the root of this distribution.
//    By using this software in any fashion, you are agreeing to be bound by the
//    terms of this license.
//   
//    You must not remove this notice, or any other, from this software.
//   
// 
// ==--==
// ---------------------------------------------------------------------------
// Ex.cpp
// ---------------------------------------------------------------------------

#include "stdafx.h"
#include "string.h"
#include "ex.h"
#include "holder.h"

// error codes
#include "corerror.h"

#include "../dlls/mscorrc/resource.h"


#define MAX_EXCEPTION_MSG   200


// Helper function to get an exception object from outside the exception.  In
//  the CLR, it may be from the Thread object.  Non-CLR users have no thread object,
//  and it will do nothing.                                                    
void GetLastThrownObjectExceptionFromThread(void **ppvException);

//------------------------------------------------------------------------------
// class OutOfMemoryException
//
//   While there could be any number of instances of this class, there is one
//    special instance, the pre-allocated OOM exception.  Storage for that 
//    instance is allocated in the image, so we can always obtain it, even
//    in low memory situations.
//   Note that, in fact, there is only one instance.
//------------------------------------------------------------------------------
class OutOfMemoryException : public Exception
{  
 private:
    static const int c_type = 0x4F4F4D20;   // 'OOM '
    BOOL    bIsPreallocated;

 public:
     OutOfMemoryException() : bIsPreallocated(FALSE) {}
     OutOfMemoryException(BOOL b) : bIsPreallocated(b) {}

    // Dynamic type query for catchers
    static int GetType() {LEAF_CONTRACT;  return c_type; }
    virtual int GetInstanceType() { LEAF_CONTRACT; return c_type; }
    BOOL IsType(int type) { WRAPPER_CONTRACT; return type == c_type || Exception::IsType(type);  }
    
    HRESULT GetHR() {LEAF_CONTRACT;  return E_OUTOFMEMORY; }
    void GetMessage(SString &result) { WRAPPER_CONTRACT; result.SetASCII("Out Of Memory"); }

    virtual Exception *Clone();
    
    virtual BOOL IsPreallocatedException() { return bIsPreallocated; }
};

Exception *Exception::g_OOMException = NULL;

// avoid global constructors
static BYTE g_OOMExceptionInstance[sizeof(OutOfMemoryException)];

Exception * Exception::GetOOMException()
{
    LEAF_CONTRACT;
    
    if (!g_OOMException) {
        // Create a local copy on the stack and then copy it over to the static instance.
        // This avoids race conditions caused by multiple initializations of vtable in the constructor       

        OutOfMemoryException local(TRUE);  // Construct a "preallocated" instance.
        memcpy(&g_OOMExceptionInstance, &local, sizeof(OutOfMemoryException));           

        g_OOMException = (OutOfMemoryException*)&g_OOMExceptionInstance;
    }

    return g_OOMException;
}

/*virtual*/ Exception *OutOfMemoryException::Clone()
{
    LEAF_CONTRACT;

    return GetOOMException();
}

//------------------------------------------------------------------------------
// class StackOverflowException
//
//   While there can be any number of instances of this class, there is one
//    special instance, the pre-allocated SO exception.  Storage for that 
//    instance is allocated in the image, so we can always obtain it, even
//    in low memory or true stack-overflow situations.
//   Note that, in fact, there is only one instance.
//------------------------------------------------------------------------------
StackOverflowException::StackOverflowException() : bIsPreallocated(FALSE) {}
StackOverflowException::StackOverflowException(BOOL b) : bIsPreallocated(b) {}
    
// Dynamic type query for catchers
int StackOverflowException::GetType() {LEAF_CONTRACT;  return c_type; }
int StackOverflowException::GetInstanceType() { LEAF_CONTRACT; return c_type; }
BOOL StackOverflowException::IsType(int type) { WRAPPER_CONTRACT; return type == c_type || Exception::IsType(type);  }
HRESULT StackOverflowException::GetHR() {LEAF_CONTRACT;  return COR_E_STACKOVERFLOW; }
void StackOverflowException::GetMessage(SString &result) { WRAPPER_CONTRACT; result.SetASCII("Stack Overflow"); }
Exception *StackOverflowException::Clone()
{
    LEAF_CONTRACT;

    return GetSOException();
}
BOOL StackOverflowException::IsPreallocatedException() { return bIsPreallocated; }


Exception *Exception::g_SOException = NULL;

// avoid global constructors
static BYTE g_SOExceptionInstance[sizeof(StackOverflowException)];

Exception * Exception::GetSOException()
{
    LEAF_CONTRACT;
    
    if (!g_SOException) {
        // Create a local copy on the stack and then copy it over to the static instance.
        // This avoids race conditions caused by multiple initializations of vtable in the constructor       

        StackOverflowException local(TRUE);  // Construct a "preallocated" instance.
        memcpy(&g_SOExceptionInstance, &local, sizeof(StackOverflowException));           

        g_SOException = (StackOverflowException*)&g_SOExceptionInstance;
    }

    return g_SOException;
}




//------------------------------------------------------------------------------
void Exception::Delete(Exception* pvMemory)
{
    CONTRACTL
    {
        GC_NOTRIGGER;
        NOTHROW;
    }
    CONTRACTL_END;

    if ((pvMemory == 0) || pvMemory->IsPreallocatedException())
    {
        return;
    }

    ::delete((Exception *) pvMemory);
}

void Exception::GetMessage(SString &result)
{
    WRAPPER_CONTRACT;
    
    return GenerateTopLevelHRExceptionMessage(GetHR(), result);
}

void HRMsgException::GetMessage(SString &result)
{
    WRAPPER_CONTRACT;
    
    if (m_msg.IsEmpty())
        HRException::GetMessage(result);
    else
        result = m_msg;
}

Exception *Exception::Clone()
{
    CONTRACTL
    {
        GC_NOTRIGGER;
        THROWS;
    }
    CONTRACTL_END;
    
    NewHolder<Exception> retExcep(CloneHelper());
    if (m_innerException)
    {
        retExcep->m_innerException = m_innerException->Clone();
    }

    retExcep.SuppressRelease();
    return retExcep;
}

Exception *Exception::CloneHelper()
{
    StackSString s;
    GetMessage(s);
    return new HRMsgException(GetHR(), s);
}

Exception *Exception::DomainBoundClone()
{
    CONTRACTL
    {
        GC_NOTRIGGER;
        THROWS;
    }
    CONTRACTL_END;

    NewHolder<Exception> retExcep(DomainBoundCloneHelper());
    if (m_innerException)
    {
        retExcep->m_innerException = m_innerException->DomainBoundClone();
    }

    retExcep.SuppressRelease();
    return retExcep;
}

BOOL Exception::IsTerminal()
{
    CONTRACTL
    {
        GC_NOTRIGGER;
        NOTHROW;
    }
    CONTRACTL_END;
    
    HRESULT hr = GetHR();
    return (COR_E_THREADABORTED == hr);
}

BOOL Exception::IsTransient()
{
    WRAPPER_CONTRACT;

    return IsTransient(GetHR());
}

/* static */
BOOL Exception::IsTransient(HRESULT hr)
{
    LEAF_CONTRACT;
    
    return (hr == COR_E_THREADABORTED
            || hr == COR_E_THREADINTERRUPTED
            || hr == COR_E_THREADSTOP
            || hr == COR_E_APPDOMAINUNLOADED
            || hr == E_OUTOFMEMORY
            || hr == HRESULT_FROM_WIN32(ERROR_COMMITMENT_LIMIT) // ran out of room in pagefile
            || hr == HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY)
            || hr == (HRESULT)STATUS_NO_MEMORY
            || hr == COR_E_STACKOVERFLOW
            || hr == MSEE_E_ASSEMBLYLOADINPROGRESS);
}

//------------------------------------------------------------------------------
// Functions to manage the preallocated exceptions.
// Virtual 
BOOL Exception::IsPreallocatedException()
{   // Most exceptions can't be preallocated.  If they can be, their class
    //  should provide a virtual override of this function.
    return FALSE;
}

BOOL Exception::IsPreallocatedOOMException()
{   // This is the preallocated OOM if it is preallocated and is OOM.
    return IsPreallocatedException() && (GetInstanceType() == OutOfMemoryException::GetType());
}

BOOL Exception::IsPreallocatedSOException()
{   // This is the preallocated SO if it is preallocated and is SO.
    return IsPreallocatedException() && (GetInstanceType() == StackOverflowException::GetType());
}

//------------------------------------------------------------------------------
LPCSTR Exception::GetHRSymbolicName(HRESULT hr)
{
    LEAF_CONTRACT;

#define CASE_HRESULT(hrname) case hrname: return #hrname;

    switch (hr)
    {
        CASE_HRESULT(S_OK)//                             0x00000000L
        CASE_HRESULT(S_FALSE)//                          0x00000001L

        CASE_HRESULT(E_UNEXPECTED)//                     0x8000FFFFL
        CASE_HRESULT(E_NOTIMPL)//                        0x80004001L
        CASE_HRESULT(E_OUTOFMEMORY)//                    0x8007000EL
        CASE_HRESULT(E_INVALIDARG)//                     0x80070057L
        CASE_HRESULT(E_NOINTERFACE)//                    0x80004002L
        CASE_HRESULT(E_POINTER)//                        0x80004003L
        CASE_HRESULT(E_HANDLE)//                         0x80070006L
        CASE_HRESULT(E_ABORT)//                          0x80004004L
        CASE_HRESULT(E_FAIL)//                           0x80004005L
        CASE_HRESULT(E_ACCESSDENIED)//                   0x80070005L


#ifdef _DEBUG

    CASE_HRESULT(CEE_E_ENTRYPOINT)
    CASE_HRESULT(CEE_E_CVTRES_NOT_FOUND)
    CASE_HRESULT(MSEE_E_LOADLIBFAILED)
    CASE_HRESULT(MSEE_E_GETPROCFAILED)
    CASE_HRESULT(MSEE_E_MULTCOPIESLOADED)
    CASE_HRESULT(COR_E_APPDOMAINUNLOADED)
    CASE_HRESULT(COR_E_CANNOTUNLOADAPPDOMAIN)
    CASE_HRESULT(MSEE_E_ASSEMBLYLOADINPROGRESS)
    CASE_HRESULT(MSEE_E_CANNOTCREATEAPPDOMAIN)
    CASE_HRESULT(COR_E_FIXUPSINEXE)
    CASE_HRESULT(COR_E_NO_LOADLIBRARY_ALLOWED)
    CASE_HRESULT(COR_E_MODULE_HASH_CHECK_FAILED)
    CASE_HRESULT(FUSION_E_REF_DEF_MISMATCH)
    CASE_HRESULT(FUSION_E_INVALID_PRIVATE_ASM_LOCATION)
    CASE_HRESULT(FUSION_E_ASM_MODULE_MISSING)
    CASE_HRESULT(FUSION_E_UNEXPECTED_MODULE_FOUND)
    CASE_HRESULT(FUSION_E_PRIVATE_ASM_DISALLOWED)
    CASE_HRESULT(FUSION_E_SIGNATURE_CHECK_FAILED)
    CASE_HRESULT(FUSION_E_DATABASE_ERROR)
    CASE_HRESULT(FUSION_E_INVALID_NAME)
    CASE_HRESULT(FUSION_E_CODE_DOWNLOAD_DISABLED)
    CASE_HRESULT(FUSION_E_UNINSTALL_DISALLOWED)
    CASE_HRESULT(CLDB_E_FILE_BADREAD)
    CASE_HRESULT(CLDB_E_FILE_BADWRITE)
    CASE_HRESULT(CLDB_E_FILE_READONLY)
    CASE_HRESULT(CLDB_E_NAME_ERROR)
    CASE_HRESULT(CLDB_S_TRUNCATION)
    CASE_HRESULT(CLDB_E_TRUNCATION)
    CASE_HRESULT(CLDB_E_FILE_OLDVER)
    CASE_HRESULT(CLDB_E_RELOCATED)
    CASE_HRESULT(CLDB_S_NULL)
    CASE_HRESULT(CLDB_E_SMDUPLICATE)
    CASE_HRESULT(CLDB_E_NO_DATA)
    CASE_HRESULT(CLDB_E_READONLY)
    CASE_HRESULT(CLDB_E_INCOMPATIBLE)
    CASE_HRESULT(CLDB_E_FILE_CORRUPT)
    CASE_HRESULT(CLDB_E_SCHEMA_VERNOTFOUND)
    CASE_HRESULT(CLDB_E_BADUPDATEMODE)
    CASE_HRESULT(CLDB_E_INDEX_NONULLKEYS)
    CASE_HRESULT(CLDB_E_INDEX_DUPLICATE)
    CASE_HRESULT(CLDB_E_INDEX_BADTYPE)
    CASE_HRESULT(CLDB_E_INDEX_NOTFOUND)
    CASE_HRESULT(CLDB_S_INDEX_TABLESCANREQUIRED)
    CASE_HRESULT(CLDB_E_RECORD_NOTFOUND)
    CASE_HRESULT(CLDB_E_RECORD_OVERFLOW)
    CASE_HRESULT(CLDB_E_RECORD_DUPLICATE)
    CASE_HRESULT(CLDB_E_RECORD_PKREQUIRED)
    CASE_HRESULT(CLDB_E_RECORD_DELETED)
    CASE_HRESULT(CLDB_E_RECORD_OUTOFORDER)
    CASE_HRESULT(CLDB_E_COLUMN_OVERFLOW)
    CASE_HRESULT(CLDB_E_COLUMN_READONLY)
    CASE_HRESULT(CLDB_E_COLUMN_SPECIALCOL)
    CASE_HRESULT(CLDB_E_COLUMN_PKNONULLS)
    CASE_HRESULT(CLDB_E_TABLE_CANTDROP)
    CASE_HRESULT(CLDB_E_OBJECT_NOTFOUND)
    CASE_HRESULT(CLDB_E_OBJECT_COLNOTFOUND)
    CASE_HRESULT(CLDB_E_VECTOR_BADINDEX)
    CASE_HRESULT(CLDB_E_TOO_BIG)
    CASE_HRESULT(META_E_DUPLICATE)
    CASE_HRESULT(META_E_GUID_REQUIRED)
    CASE_HRESULT(META_E_TYPEDEF_MISMATCH)
    CASE_HRESULT(META_E_MERGE_COLLISION)
    CASE_HRESULT(META_E_METHD_NOT_FOUND)
    CASE_HRESULT(META_E_FIELD_NOT_FOUND)
    CASE_HRESULT(META_S_PARAM_MISMATCH)
    CASE_HRESULT(META_E_PARAM_MISMATCH)
    CASE_HRESULT(META_E_BADMETADATA)
    CASE_HRESULT(META_E_INTFCEIMPL_NOT_FOUND)
    CASE_HRESULT(META_E_CLASS_LAYOUT_INCONSISTENT)
    CASE_HRESULT(META_E_FIELD_MARSHAL_NOT_FOUND)
    CASE_HRESULT(META_E_METHODSEM_NOT_FOUND)
    CASE_HRESULT(META_E_EVENT_NOT_FOUND)
    CASE_HRESULT(META_E_PROP_NOT_FOUND)
    CASE_HRESULT(META_E_BAD_SIGNATURE)
    CASE_HRESULT(META_E_BAD_INPUT_PARAMETER)
    CASE_HRESULT(META_E_METHDIMPL_INCONSISTENT)
    CASE_HRESULT(META_E_MD_INCONSISTENCY)
    CASE_HRESULT(META_E_CANNOTRESOLVETYPEREF)
    CASE_HRESULT(META_S_DUPLICATE)
    CASE_HRESULT(META_E_STRINGSPACE_FULL)
    CASE_HRESULT(META_E_UNEXPECTED_REMAP)
    CASE_HRESULT(META_E_HAS_UNMARKALL)
    CASE_HRESULT(META_E_MUST_CALL_UNMARKALL)
    CASE_HRESULT(TLBX_E_CANT_LOAD_MODULE)
    CASE_HRESULT(TLBX_E_CANT_LOAD_CLASS)
    CASE_HRESULT(TLBX_E_NULL_MODULE)
    CASE_HRESULT(TLBX_E_NO_CLSID_KEY)
    CASE_HRESULT(TLBX_E_CIRCULAR_EXPORT)
    CASE_HRESULT(TLBX_E_CIRCULAR_EXPORT2)
    CASE_HRESULT(TLBX_E_CIRCULAR_IMPORT)
    CASE_HRESULT(TLBX_E_BAD_NATIVETYPE)
    CASE_HRESULT(TLBX_E_BAD_VTABLE)
    CASE_HRESULT(TLBX_E_CRM_NON_STATIC)
    CASE_HRESULT(TLBX_E_CRM_INVALID_SIG)
    CASE_HRESULT(TLBX_E_CLASS_LOAD_EXCEPTION)
    CASE_HRESULT(TLBX_E_UNKNOWN_SIGNATURE)
    CASE_HRESULT(TLBX_E_REFERENCED_TYPELIB)
    CASE_HRESULT(TLBX_S_REFERENCED_TYPELIB)
    CASE_HRESULT(TLBX_E_INVALID_NAMESPACE)
    CASE_HRESULT(TLBX_E_LAYOUT_ERROR)
    CASE_HRESULT(TLBX_E_NOTIUNKNOWN)
    CASE_HRESULT(TLBX_E_NONVISIBLEVALUECLASS)
    CASE_HRESULT(TLBX_E_LPTSTR_NOT_ALLOWED)
    CASE_HRESULT(TLBX_E_AUTO_CS_NOT_ALLOWED)
    CASE_HRESULT(TLBX_S_NOSTDINTERFACE)
    CASE_HRESULT(TLBX_S_DUPLICATE_DISPID)
    CASE_HRESULT(TLBX_E_ENUM_VALUE_INVALID)
    CASE_HRESULT(TLBX_W_ENUM_VALUE_TOOBIG)
    CASE_HRESULT(TLBX_E_DUPLICATE_IID)
    CASE_HRESULT(TLBX_E_NO_NESTED_ARRAYS)
    CASE_HRESULT(TLBX_E_PARAM_ERROR_NAMED)
    CASE_HRESULT(TLBX_E_PARAM_ERROR_UNNAMED)
    CASE_HRESULT(TLBX_E_AGNOST_SIGNATURE)
    CASE_HRESULT(TLBX_E_CONVERT_FAIL)
    CASE_HRESULT(TLBX_W_DUAL_NOT_DISPATCH)
    CASE_HRESULT(TLBX_E_BAD_SIGNATURE)
    CASE_HRESULT(TLBX_E_ARRAY_NEEDS_NT_FIXED)
    CASE_HRESULT(TLBX_E_CLASS_NEEDS_NT_INTF)
    CASE_HRESULT(TLBX_E_INVALID_TYPEINFO)
    CASE_HRESULT(TLBX_E_INVALID_TYPEINFO_UNNAMED)
    CASE_HRESULT(TLBX_E_CTX_NESTED)
    CASE_HRESULT(TLBX_E_ERROR_MESSAGE)
    CASE_HRESULT(TLBX_E_CANT_SAVE)
    CASE_HRESULT(TLBX_W_LIBNOTREGISTERED)
    CASE_HRESULT(TLBX_E_CANTLOADLIBRARY)
    CASE_HRESULT(TLBX_E_BAD_VT_TYPE)
    CASE_HRESULT(TLBX_E_NO_MSCOREE_TLB)
    CASE_HRESULT(TLBX_E_BAD_MSCOREE_TLB)
    CASE_HRESULT(TLBX_E_TLB_EXCEPTION)
    CASE_HRESULT(TLBX_E_MULTIPLE_LCIDS)
    CASE_HRESULT(TLBX_I_TYPEINFO_IMPORTED)
    CASE_HRESULT(TLBX_E_AMBIGUOUS_RETURN)
    CASE_HRESULT(TLBX_E_PROPGET_WITHOUT_RETURN)
    CASE_HRESULT(TLBX_E_DUPLICATE_TYPE_NAME)
    CASE_HRESULT(TLBX_I_USEIUNKNOWN)
    CASE_HRESULT(TLBX_I_UNCONVERTABLE_ARGS)
    CASE_HRESULT(TLBX_I_UNCONVERTABLE_FIELD)
    CASE_HRESULT(TLBX_I_NONSEQUENTIALSTRUCT)
    CASE_HRESULT(TLBX_W_WARNING_MESSAGE)
    CASE_HRESULT(TLBX_I_RESOLVEREFFAILED)
    CASE_HRESULT(TLBX_E_ASANY)
    CASE_HRESULT(TLBX_E_INVALIDLCIDPARAM)
    CASE_HRESULT(TLBX_E_LCIDONDISPONLYITF)
    CASE_HRESULT(TLBX_E_NONPUBLIC_FIELD)
    CASE_HRESULT(TLBX_I_TYPE_EXPORTED)
    CASE_HRESULT(TLBX_I_DUPLICATE_DISPID)
    CASE_HRESULT(TLBX_E_BAD_NAMES)
    CASE_HRESULT(TLBX_E_BITNESS_MISMATCH)
    CASE_HRESULT(TLBX_I_REF_TYPE_AS_STRUCT)
    CASE_HRESULT(TLBX_E_GENERICINST_SIGNATURE)
    CASE_HRESULT(TLBX_E_GENERICPAR_SIGNATURE)
    CASE_HRESULT(TLBX_I_GENERIC_TYPE)
    CASE_HRESULT(TLBX_W_EXPORTING_AUTO_LAYOUT)
    CASE_HRESULT(TLBX_E_TYPED_REF)
    CASE_HRESULT(TLBX_W_DEFAULT_INTF_NOT_VISIBLE)
    CASE_HRESULT(TLBX_W_NON_INTEGRAL_CA_TYPE)
    CASE_HRESULT(TLBX_W_IENUM_CA_ON_IUNK)
    CASE_HRESULT(TLBX_E_NO_SAFEHANDLE_ARRAYS)
    CASE_HRESULT(TLBX_W_NO_PROPS_IN_EVENTS)
    CASE_HRESULT(META_E_CA_INVALID_TARGET)
    CASE_HRESULT(META_E_CA_INVALID_VALUE)
    CASE_HRESULT(META_E_CA_INVALID_BLOB)
    CASE_HRESULT(META_E_CA_REPEATED_ARG)
    CASE_HRESULT(META_E_CA_UNKNOWN_ARGUMENT)
    CASE_HRESULT(META_E_CA_VARIANT_NYI)
    CASE_HRESULT(META_E_CA_ARRAY_NYI)
    CASE_HRESULT(META_E_CA_UNEXPECTED_TYPE)
    CASE_HRESULT(META_E_CA_INVALID_ARGTYPE)
    CASE_HRESULT(META_E_CA_INVALID_ARG_FOR_TYPE)
    CASE_HRESULT(META_E_CA_INVALID_UUID)
    CASE_HRESULT(META_E_CA_INVALID_MARSHALAS_FIELDS)
    CASE_HRESULT(META_E_CA_NT_FIELDONLY)
    CASE_HRESULT(META_E_CA_NEGATIVE_PARAMINDEX)
    CASE_HRESULT(META_E_CA_NEGATIVE_MULTIPLIER)
    CASE_HRESULT(META_E_CA_NEGATIVE_CONSTSIZE)
    CASE_HRESULT(META_E_CA_FIXEDSTR_SIZE_REQUIRED)
    CASE_HRESULT(META_E_CA_CUSTMARSH_TYPE_REQUIRED)
    CASE_HRESULT(META_E_CA_FILENAME_REQUIRED)
    CASE_HRESULT(VLDTR_S_WRN)
    CASE_HRESULT(VLDTR_S_ERR)
    CASE_HRESULT(VLDTR_S_WRNERR)
    CASE_HRESULT(VLDTR_E_RID_OUTOFRANGE)
    CASE_HRESULT(VLDTR_E_CDTKN_OUTOFRANGE)
    CASE_HRESULT(VLDTR_E_CDRID_OUTOFRANGE)
    CASE_HRESULT(VLDTR_E_STRING_INVALID)
    CASE_HRESULT(VLDTR_E_GUID_INVALID)
    CASE_HRESULT(VLDTR_E_BLOB_INVALID)
    CASE_HRESULT(VLDTR_E_MOD_MULTI)
    CASE_HRESULT(VLDTR_E_MOD_NULLMVID)
    CASE_HRESULT(VLDTR_E_TR_NAMENULL)
    CASE_HRESULT(VLDTR_E_TR_DUP)
    CASE_HRESULT(VLDTR_E_TD_NAMENULL)
    CASE_HRESULT(VLDTR_E_TD_DUPNAME)
    CASE_HRESULT(VLDTR_E_TD_DUPGUID)
    CASE_HRESULT(VLDTR_E_TD_NOTIFACEOBJEXTNULL)
    CASE_HRESULT(VLDTR_E_TD_OBJEXTENDSNONNULL)
    CASE_HRESULT(VLDTR_E_TD_EXTENDSSEALED)
    CASE_HRESULT(VLDTR_E_TD_DLTNORTSPCL)
    CASE_HRESULT(VLDTR_E_TD_RTSPCLNOTDLT)
    CASE_HRESULT(VLDTR_E_MI_DECLPRIV)
    CASE_HRESULT(VLDTR_E_AS_BADNAME)
    CASE_HRESULT(VLDTR_E_FILE_SYSNAME)
    CASE_HRESULT(VLDTR_E_MI_BODYSTATIC)
    CASE_HRESULT(VLDTR_E_TD_IFACENOTABS)
    CASE_HRESULT(VLDTR_E_TD_IFACEPARNOTNIL)
    CASE_HRESULT(VLDTR_E_TD_IFACEGUIDNULL)
    CASE_HRESULT(VLDTR_E_MI_DECLFINAL)
    CASE_HRESULT(VLDTR_E_TD_VTNOTSEAL)
    CASE_HRESULT(VLDTR_E_PD_BADFLAGS)
    CASE_HRESULT(VLDTR_E_IFACE_DUP)
    CASE_HRESULT(VLDTR_E_MR_NAMENULL)
    CASE_HRESULT(VLDTR_E_MR_VTBLNAME)
    CASE_HRESULT(VLDTR_E_MR_DELNAME)
    CASE_HRESULT(VLDTR_E_MR_PARNIL)
    CASE_HRESULT(VLDTR_E_MR_BADCALLINGCONV)
    CASE_HRESULT(VLDTR_E_MR_NOTVARARG)
    CASE_HRESULT(VLDTR_E_MR_NAMEDIFF)
    CASE_HRESULT(VLDTR_E_MR_SIGDIFF)
    CASE_HRESULT(VLDTR_E_MR_DUP)
    CASE_HRESULT(VLDTR_E_CL_TDAUTO)
    CASE_HRESULT(VLDTR_E_CL_BADPCKSZ)
    CASE_HRESULT(VLDTR_E_CL_DUP)
    CASE_HRESULT(VLDTR_E_FL_BADOFFSET)
    CASE_HRESULT(VLDTR_E_FL_TDNIL)
    CASE_HRESULT(VLDTR_E_FL_NOCL)
    CASE_HRESULT(VLDTR_E_FL_TDNOTEXPLCT)
    CASE_HRESULT(VLDTR_E_FL_FLDSTATIC)
    CASE_HRESULT(VLDTR_E_FL_DUP)
    CASE_HRESULT(VLDTR_E_MODREF_NAMENULL)
    CASE_HRESULT(VLDTR_E_MODREF_DUP)
    CASE_HRESULT(VLDTR_E_TR_BADSCOPE)
    CASE_HRESULT(VLDTR_E_TD_NESTEDNOENCL)
    CASE_HRESULT(VLDTR_E_TD_EXTTRRES)
    CASE_HRESULT(VLDTR_E_SIGNULL)
    CASE_HRESULT(VLDTR_E_SIGNODATA)
    CASE_HRESULT(VLDTR_E_MD_BADCALLINGCONV)
    CASE_HRESULT(VLDTR_E_MD_THISSTATIC)
    CASE_HRESULT(VLDTR_E_MD_NOTTHISNOTSTATIC)
    CASE_HRESULT(VLDTR_E_MD_NOARGCNT)
    CASE_HRESULT(VLDTR_E_SIG_MISSELTYPE)
    CASE_HRESULT(VLDTR_E_SIG_MISSTKN)
    CASE_HRESULT(VLDTR_E_SIG_TKNBAD)
    CASE_HRESULT(VLDTR_E_SIG_MISSFPTR)
    CASE_HRESULT(VLDTR_E_SIG_MISSFPTRARGCNT)
    CASE_HRESULT(VLDTR_E_SIG_MISSRANK)
    CASE_HRESULT(VLDTR_E_SIG_MISSNSIZE)
    CASE_HRESULT(VLDTR_E_SIG_MISSSIZE)
    CASE_HRESULT(VLDTR_E_SIG_MISSNLBND)
    CASE_HRESULT(VLDTR_E_SIG_MISSLBND)
    CASE_HRESULT(VLDTR_E_SIG_BADELTYPE)
    CASE_HRESULT(VLDTR_E_SIG_MISSVASIZE)
    CASE_HRESULT(VLDTR_E_FD_BADCALLINGCONV)
    CASE_HRESULT(VLDTR_E_MD_NAMENULL)
    CASE_HRESULT(VLDTR_E_MD_PARNIL)
    CASE_HRESULT(VLDTR_E_MD_DUP)
    CASE_HRESULT(VLDTR_E_FD_NAMENULL)
    CASE_HRESULT(VLDTR_E_FD_PARNIL)
    CASE_HRESULT(VLDTR_E_FD_DUP)
    CASE_HRESULT(VLDTR_E_AS_MULTI)
    CASE_HRESULT(VLDTR_E_AS_NAMENULL)
    CASE_HRESULT(VLDTR_E_SIG_TOKTYPEMISMATCH)
    CASE_HRESULT(VLDTR_E_CL_TDINTF)
    CASE_HRESULT(VLDTR_E_ASOS_OSPLTFRMIDINVAL)
    CASE_HRESULT(VLDTR_E_AR_NAMENULL)
    CASE_HRESULT(VLDTR_E_TD_ENCLNOTNESTED)
    CASE_HRESULT(VLDTR_E_AROS_OSPLTFRMIDINVAL)
    CASE_HRESULT(VLDTR_E_FILE_NAMENULL)
    CASE_HRESULT(VLDTR_E_CT_NAMENULL)
    CASE_HRESULT(VLDTR_E_TD_EXTENDSCHILD)
    CASE_HRESULT(VLDTR_E_MAR_NAMENULL)
    CASE_HRESULT(VLDTR_E_FILE_DUP)
    CASE_HRESULT(VLDTR_E_FILE_NAMEFULLQLFD)
    CASE_HRESULT(VLDTR_E_CT_DUP)
    CASE_HRESULT(VLDTR_E_MAR_DUP)
    CASE_HRESULT(VLDTR_E_MAR_NOTPUBPRIV)
    CASE_HRESULT(VLDTR_E_TD_ENUMNOVALUE)
    CASE_HRESULT(VLDTR_E_TD_ENUMVALSTATIC)
    CASE_HRESULT(VLDTR_E_TD_ENUMVALNOTSN)
    CASE_HRESULT(VLDTR_E_TD_ENUMFLDNOTST)
    CASE_HRESULT(VLDTR_E_TD_ENUMFLDNOTLIT)
    CASE_HRESULT(VLDTR_E_TD_ENUMNOLITFLDS)
    CASE_HRESULT(VLDTR_E_TD_ENUMFLDSIGMISMATCH)
    CASE_HRESULT(VLDTR_E_TD_ENUMVALNOT1ST)
    CASE_HRESULT(VLDTR_E_FD_NOTVALUERTSN)
    CASE_HRESULT(VLDTR_E_FD_VALUEPARNOTENUM)
    CASE_HRESULT(VLDTR_E_FD_INSTINIFACE)
    CASE_HRESULT(VLDTR_E_FD_NOTPUBINIFACE)
    CASE_HRESULT(VLDTR_E_FMD_GLOBALNOTPUBPRIVSC)
    CASE_HRESULT(VLDTR_E_FMD_GLOBALNOTSTATIC)
    CASE_HRESULT(VLDTR_E_FD_GLOBALNORVA)
    CASE_HRESULT(VLDTR_E_MD_CTORZERORVA)
    CASE_HRESULT(VLDTR_E_FD_MARKEDNOMARSHAL)
    CASE_HRESULT(VLDTR_E_FD_MARSHALNOTMARKED)
    CASE_HRESULT(VLDTR_E_FD_MARKEDNODEFLT)
    CASE_HRESULT(VLDTR_E_FD_DEFLTNOTMARKED)
    CASE_HRESULT(VLDTR_E_FMD_MARKEDNOSECUR)
    CASE_HRESULT(VLDTR_E_FMD_SECURNOTMARKED)
    CASE_HRESULT(VLDTR_E_FMD_PINVOKENOTSTATIC)
    CASE_HRESULT(VLDTR_E_FMD_MARKEDNOPINVOKE)
    CASE_HRESULT(VLDTR_E_FMD_PINVOKENOTMARKED)
    CASE_HRESULT(VLDTR_E_FMD_BADIMPLMAP)
    CASE_HRESULT(VLDTR_E_IMAP_BADMODREF)
    CASE_HRESULT(VLDTR_E_IMAP_BADMEMBER)
    CASE_HRESULT(VLDTR_E_IMAP_BADIMPORTNAME)
    CASE_HRESULT(VLDTR_E_IMAP_BADCALLCONV)
    CASE_HRESULT(VLDTR_E_FMD_BADACCESSFLAG)
    CASE_HRESULT(VLDTR_E_FD_INITONLYANDLITERAL)
    CASE_HRESULT(VLDTR_E_FD_LITERALNOTSTATIC)
    CASE_HRESULT(VLDTR_E_FMD_RTSNNOTSN)
    CASE_HRESULT(VLDTR_E_MD_ABSTPARNOTABST)
    CASE_HRESULT(VLDTR_E_MD_NOTSTATABSTININTF)
    CASE_HRESULT(VLDTR_E_MD_NOTPUBININTF)
    CASE_HRESULT(VLDTR_E_MD_CTORININTF)
    CASE_HRESULT(VLDTR_E_MD_GLOBALCTORCCTOR)
    CASE_HRESULT(VLDTR_E_MD_CTORSTATIC)
    CASE_HRESULT(VLDTR_E_MD_CTORNOTSNRTSN)
    CASE_HRESULT(VLDTR_E_MD_CTORVIRT)
    CASE_HRESULT(VLDTR_E_MD_CTORABST)
    CASE_HRESULT(VLDTR_E_MD_CCTORNOTSTATIC)
    CASE_HRESULT(VLDTR_E_MD_ZERORVA)
    CASE_HRESULT(VLDTR_E_MD_FINNOTVIRT)
    CASE_HRESULT(VLDTR_E_MD_STATANDFINORVIRT)
    CASE_HRESULT(VLDTR_E_MD_ABSTANDFINAL)
    CASE_HRESULT(VLDTR_E_MD_ABSTANDIMPL)
    CASE_HRESULT(VLDTR_E_MD_ABSTANDPINVOKE)
    CASE_HRESULT(VLDTR_E_MD_ABSTNOTVIRT)
    CASE_HRESULT(VLDTR_E_MD_NOTABSTNOTIMPL)
    CASE_HRESULT(VLDTR_E_MD_NOTABSTBADFLAGSRVA)
    CASE_HRESULT(VLDTR_E_MD_PRIVSCOPENORVA)
    CASE_HRESULT(VLDTR_E_MD_GLOBALABSTORVIRT)
    CASE_HRESULT(VLDTR_E_SIG_LONGFORM)
    CASE_HRESULT(VLDTR_E_MD_MULTIPLESEMANTICS)
    CASE_HRESULT(VLDTR_E_MD_INVALIDSEMANTICS)
    CASE_HRESULT(VLDTR_E_MD_SEMANTICSNOTEXIST)
    CASE_HRESULT(VLDTR_E_MI_DECLNOTVIRT)
    CASE_HRESULT(VLDTR_E_FMD_GLOBALITEM)
    CASE_HRESULT(VLDTR_E_MD_MULTSEMANTICFLAGS)
    CASE_HRESULT(VLDTR_E_MD_NOSEMANTICFLAGS)
    CASE_HRESULT(VLDTR_E_FD_FLDINIFACE)
    CASE_HRESULT(VLDTR_E_AS_HASHALGID)
    CASE_HRESULT(VLDTR_E_AS_PROCID)
    CASE_HRESULT(VLDTR_E_AR_PROCID)
    CASE_HRESULT(VLDTR_E_CN_PARENTRANGE)
    CASE_HRESULT(VLDTR_E_AS_BADFLAGS)
    CASE_HRESULT(VLDTR_E_TR_HASTYPEDEF)
    CASE_HRESULT(VLDTR_E_IFACE_BADIMPL)
    CASE_HRESULT(VLDTR_E_IFACE_BADIFACE)
    CASE_HRESULT(VLDTR_E_TD_SECURNOTMARKED)
    CASE_HRESULT(VLDTR_E_TD_MARKEDNOSECUR)
    CASE_HRESULT(VLDTR_E_MD_CCTORHASARGS)
    CASE_HRESULT(VLDTR_E_CT_BADIMPL)
    CASE_HRESULT(VLDTR_E_MI_ALIENBODY)
    CASE_HRESULT(VLDTR_E_MD_CCTORCALLCONV)
    CASE_HRESULT(VLDTR_E_MI_BADCLASS)
    CASE_HRESULT(VLDTR_E_MI_CLASSISINTF)
    CASE_HRESULT(VLDTR_E_MI_BADDECL)
    CASE_HRESULT(VLDTR_E_MI_BADBODY)
    CASE_HRESULT(VLDTR_E_MI_DUP)
    CASE_HRESULT(VLDTR_E_FD_BADPARENT)
    CASE_HRESULT(VLDTR_E_MD_PARAMOUTOFSEQ)
    CASE_HRESULT(VLDTR_E_MD_PARASEQTOOBIG)
    CASE_HRESULT(VLDTR_E_MD_PARMMARKEDNOMARSHAL)
    CASE_HRESULT(VLDTR_E_MD_PARMMARSHALNOTMARKED)
    CASE_HRESULT(VLDTR_E_MD_PARMMARKEDNODEFLT)
    CASE_HRESULT(VLDTR_E_MD_PARMDEFLTNOTMARKED)
    CASE_HRESULT(VLDTR_E_PR_BADSCOPE)
    CASE_HRESULT(VLDTR_E_PR_NONAME)
    CASE_HRESULT(VLDTR_E_PR_NOSIG)
    CASE_HRESULT(VLDTR_E_PR_DUP)
    CASE_HRESULT(VLDTR_E_PR_BADCALLINGCONV)
    CASE_HRESULT(VLDTR_E_PR_MARKEDNODEFLT)
    CASE_HRESULT(VLDTR_E_PR_DEFLTNOTMARKED)
    CASE_HRESULT(VLDTR_E_PR_BADSEMANTICS)
    CASE_HRESULT(VLDTR_E_PR_BADMETHOD)
    CASE_HRESULT(VLDTR_E_PR_ALIENMETHOD)
    CASE_HRESULT(VLDTR_E_CN_BLOBNOTNULL)
    CASE_HRESULT(VLDTR_E_CN_BLOBNULL)
    CASE_HRESULT(VLDTR_E_EV_BADSCOPE)
    CASE_HRESULT(VLDTR_E_EV_NONAME)
    CASE_HRESULT(VLDTR_E_EV_DUP)
    CASE_HRESULT(VLDTR_E_EV_BADEVTYPE)
    CASE_HRESULT(VLDTR_E_EV_EVTYPENOTCLASS)
    CASE_HRESULT(VLDTR_E_EV_BADSEMANTICS)
    CASE_HRESULT(VLDTR_E_EV_BADMETHOD)
    CASE_HRESULT(VLDTR_E_EV_ALIENMETHOD)
    CASE_HRESULT(VLDTR_E_EV_NOADDON)
    CASE_HRESULT(VLDTR_E_EV_NOREMOVEON)
    CASE_HRESULT(VLDTR_E_CT_DUPTDNAME)
    CASE_HRESULT(VLDTR_E_MAR_BADOFFSET)
    CASE_HRESULT(VLDTR_E_DS_BADOWNER)
    CASE_HRESULT(VLDTR_E_DS_BADFLAGS)
    CASE_HRESULT(VLDTR_E_DS_NOBLOB)
    CASE_HRESULT(VLDTR_E_MAR_BADIMPL)
    CASE_HRESULT(VLDTR_E_MR_VARARGCALLINGCONV)
    CASE_HRESULT(VLDTR_E_MD_CTORNOTVOID)
    CASE_HRESULT(VLDTR_E_EV_FIRENOTVOID)
    CASE_HRESULT(VLDTR_E_AS_BADLOCALE)
    CASE_HRESULT(VLDTR_E_CN_PARENTTYPE)
    CASE_HRESULT(VLDTR_E_SIG_SENTINMETHODDEF)
    CASE_HRESULT(VLDTR_E_SIG_SENTMUSTVARARG)
    CASE_HRESULT(VLDTR_E_SIG_MULTSENTINELS)
    CASE_HRESULT(VLDTR_E_SIG_LASTSENTINEL)
    CASE_HRESULT(VLDTR_E_SIG_MISSARG)
    CASE_HRESULT(VLDTR_E_SIG_BYREFINFIELD)
    CASE_HRESULT(VLDTR_E_MD_SYNCMETHODINVTYPE)
    CASE_HRESULT(VLDTR_E_TD_NAMETOOLONG)
    CASE_HRESULT(VLDTR_E_AS_PROCDUP)
    CASE_HRESULT(VLDTR_E_ASOS_DUP)
    CASE_HRESULT(VLDTR_E_MAR_BADFLAGS)
    CASE_HRESULT(VLDTR_E_CT_NOTYPEDEFID)
    CASE_HRESULT(VLDTR_E_FILE_BADFLAGS)
    CASE_HRESULT(VLDTR_E_FILE_NULLHASH)
    CASE_HRESULT(VLDTR_E_MOD_NONAME)
    CASE_HRESULT(VLDTR_E_MOD_NAMEFULLQLFD)
    CASE_HRESULT(VLDTR_E_TD_RTSPCLNOTSPCL)
    CASE_HRESULT(VLDTR_E_TD_EXTENDSIFACE)
    CASE_HRESULT(VLDTR_E_MD_CTORPINVOKE)
    CASE_HRESULT(VLDTR_E_TD_SYSENUMNOTCLASS)
    CASE_HRESULT(VLDTR_E_TD_SYSENUMNOTEXTVTYPE)
    CASE_HRESULT(VLDTR_E_MI_SIGMISMATCH)
    CASE_HRESULT(VLDTR_E_TD_ENUMHASMETHODS)
    CASE_HRESULT(VLDTR_E_TD_ENUMIMPLIFACE)
    CASE_HRESULT(VLDTR_E_TD_ENUMHASPROP)
    CASE_HRESULT(VLDTR_E_TD_ENUMHASEVENT)
    CASE_HRESULT(VLDTR_E_TD_BADMETHODLST)
    CASE_HRESULT(VLDTR_E_TD_BADFIELDLST)
    CASE_HRESULT(VLDTR_E_CN_BADTYPE)
    CASE_HRESULT(VLDTR_E_TD_ENUMNOINSTFLD)
    CASE_HRESULT(VLDTR_E_TD_ENUMMULINSTFLD)
    CASE_HRESULT(VLDTR_E_INTERRUPTED)
    CASE_HRESULT(VLDTR_E_NOTINIT)
    CASE_HRESULT(VLDTR_E_IFACE_NOTIFACE)
    CASE_HRESULT(VLDTR_E_FD_RVAHASNORVA)
    CASE_HRESULT(VLDTR_E_FD_RVAHASZERORVA)
    CASE_HRESULT(VLDTR_E_MD_RVAANDIMPLMAP)
    CASE_HRESULT(VLDTR_E_TD_EXTRAFLAGS)
    CASE_HRESULT(VLDTR_E_TD_EXTENDSITSELF)
    CASE_HRESULT(VLDTR_E_TD_SYSVTNOTEXTOBJ)
    CASE_HRESULT(VLDTR_E_TD_EXTTYPESPEC)
    CASE_HRESULT(VLDTR_E_TD_VTNOSIZE)
    CASE_HRESULT(VLDTR_E_TD_IFACESEALED)
    CASE_HRESULT(VLDTR_E_NC_BADNESTED)
    CASE_HRESULT(VLDTR_E_NC_BADENCLOSER)
    CASE_HRESULT(VLDTR_E_NC_DUP)
    CASE_HRESULT(VLDTR_E_NC_DUPENCLOSER)
    CASE_HRESULT(VLDTR_E_FRVA_ZERORVA)
    CASE_HRESULT(VLDTR_E_FRVA_BADFIELD)
    CASE_HRESULT(VLDTR_E_FRVA_DUPRVA)
    CASE_HRESULT(VLDTR_E_FRVA_DUPFIELD)
    CASE_HRESULT(VLDTR_E_EP_BADTOKEN)
    CASE_HRESULT(VLDTR_E_EP_INSTANCE)
    CASE_HRESULT(VLDTR_E_TD_ENUMFLDBADTYPE)
    CASE_HRESULT(VLDTR_E_MD_BADRVA)
    CASE_HRESULT(VLDTR_E_FD_LITERALNODEFAULT)
    CASE_HRESULT(VLDTR_E_IFACE_METHNOTIMPL)
    CASE_HRESULT(VLDTR_E_CA_BADPARENT)
    CASE_HRESULT(VLDTR_E_CA_BADTYPE)
    CASE_HRESULT(VLDTR_E_CA_NOTCTOR)
    CASE_HRESULT(VLDTR_E_CA_BADSIG)
    CASE_HRESULT(VLDTR_E_CA_NOSIG)
    CASE_HRESULT(VLDTR_E_CA_BADPROLOG)
    CASE_HRESULT(VLDTR_E_MD_BADLOCALSIGTOK)
    CASE_HRESULT(VLDTR_E_MD_BADHEADER)
    CASE_HRESULT(VLDTR_E_EP_TOOMANYARGS)
    CASE_HRESULT(VLDTR_E_EP_BADRET)
    CASE_HRESULT(VLDTR_E_EP_BADARG)
    CASE_HRESULT(VLDTR_E_SIG_BADVOID)
    CASE_HRESULT(CORDBG_E_UNRECOVERABLE_ERROR)
    CASE_HRESULT(CORDBG_E_PROCESS_TERMINATED)
    CASE_HRESULT(CORDBG_E_PROCESS_NOT_SYNCHRONIZED)
    CASE_HRESULT(CORDBG_E_CLASS_NOT_LOADED)
    CASE_HRESULT(CORDBG_E_IL_VAR_NOT_AVAILABLE)
    CASE_HRESULT(CORDBG_E_BAD_REFERENCE_VALUE)
    CASE_HRESULT(CORDBG_E_FIELD_NOT_AVAILABLE)
    CASE_HRESULT(CORDBG_E_NON_NATIVE_FRAME)
    CASE_HRESULT(CORDBG_E_NONCONTINUABLE_EXCEPTION)
    CASE_HRESULT(CORDBG_E_CODE_NOT_AVAILABLE)
    CASE_HRESULT(CORDBG_E_FUNCTION_NOT_IL)
    CASE_HRESULT(CORDBG_S_BAD_START_SEQUENCE_POINT)
    CASE_HRESULT(CORDBG_S_BAD_END_SEQUENCE_POINT)
    CASE_HRESULT(CORDBG_S_INSUFFICIENT_INFO_FOR_SET_IP)
    CASE_HRESULT(CORDBG_E_CANT_SET_IP_INTO_FINALLY)
    CASE_HRESULT(CORDBG_E_CANT_SET_IP_OUT_OF_FINALLY)
    CASE_HRESULT(CORDBG_E_CANT_SET_IP_INTO_CATCH)
    CASE_HRESULT(CORDBG_E_SET_IP_NOT_ALLOWED_ON_NONLEAF_FRAME)
    CASE_HRESULT(CORDBG_E_SET_IP_IMPOSSIBLE)
    CASE_HRESULT(CORDBG_E_FUNC_EVAL_BAD_START_POINT)
    CASE_HRESULT(CORDBG_E_INVALID_OBJECT)
    CASE_HRESULT(CORDBG_E_FUNC_EVAL_NOT_COMPLETE)
    CASE_HRESULT(CORDBG_S_FUNC_EVAL_HAS_NO_RESULT)
    CASE_HRESULT(CORDBG_S_VALUE_POINTS_TO_VOID)
    CASE_HRESULT(CORDBG_E_INPROC_NOT_IMPL)
    CASE_HRESULT(CORDBG_S_FUNC_EVAL_ABORTED)
    CASE_HRESULT(CORDBG_E_STATIC_VAR_NOT_AVAILABLE)
    CASE_HRESULT(CORDBG_E_OBJECT_IS_NOT_COPYABLE_VALUE_CLASS)
    CASE_HRESULT(CORDBG_E_CANT_SETIP_INTO_OR_OUT_OF_FILTER)
    CASE_HRESULT(CORDBG_E_CANT_CHANGE_JIT_SETTING_FOR_ZAP_MODULE)
    CASE_HRESULT(CORDBG_E_REMOTE_CONNECTION_CONN_RESET)
    CASE_HRESULT(CORDBG_E_REMOTE_CONNECTION_KEEP_ALIVE)
    CASE_HRESULT(CORDBG_E_REMOTE_CONNECTION_FATAL_ERROR)
    CASE_HRESULT(CORDBG_E_CANT_SET_TO_JMC)
    CASE_HRESULT(CORDBG_E_BAD_THREAD_STATE)
    CASE_HRESULT(CORDBG_E_DEBUGGER_ALREADY_ATTACHED)
    CASE_HRESULT(CORDBG_E_SUPERFLOUS_CONTINUE)
    CASE_HRESULT(CORDBG_E_SET_VALUE_NOT_ALLOWED_ON_NONLEAF_FRAME)
    CASE_HRESULT(CORDBG_E_ENC_EH_MAX_NESTING_LEVEL_CANT_INCREASE)
    CASE_HRESULT(CORDBG_E_ENC_MODULE_NOT_ENC_ENABLED)
    CASE_HRESULT(CORDBG_E_SET_IP_NOT_ALLOWED_ON_EXCEPTION)
    CASE_HRESULT(CORDBG_E_VARIABLE_IS_ACTUALLY_LITERAL)
    CASE_HRESULT(CORDBG_E_PROCESS_DETACHED)
    CASE_HRESULT(CORDBG_E_ENC_METHOD_SIG_CHANGED)
    CASE_HRESULT(CORDBG_E_ENC_METHOD_NO_LOCAL_SIG)
    CASE_HRESULT(CORDBG_E_ENC_CANT_ADD_FIELD_TO_VALUE_OR_LAYOUT_CLASS)
    CASE_HRESULT(CORDBG_E_ENC_CANT_CHANGE_FIELD)
    CASE_HRESULT(CORDBG_E_ENC_CANT_ADD_NON_PRIVATE_MEMBER)
    CASE_HRESULT(CORDBG_E_FIELD_NOT_STATIC)
    CASE_HRESULT(CORDBG_E_FIELD_NOT_INSTANCE)
    CASE_HRESULT(CORDBG_E_ENC_ZAPPED_WITHOUT_ENC)
    CASE_HRESULT(CORDBG_E_ENC_BAD_METHOD_INFO)
    CASE_HRESULT(CORDBG_E_ENC_JIT_CANT_UPDATE)
    CASE_HRESULT(CORDBG_E_ENC_MISSING_CLASS)
    CASE_HRESULT(CORDBG_E_ENC_INTERNAL_ERROR)
    CASE_HRESULT(CORDBG_E_ENC_HANGING_FIELD)
    CASE_HRESULT(CORDBG_E_MODULE_NOT_LOADED)
    CASE_HRESULT(CORDBG_E_ENC_CANT_CHANGE_SUPERCLASS)
    CASE_HRESULT(CORDBG_E_UNABLE_TO_SET_BREAKPOINT)
    CASE_HRESULT(CORDBG_E_DEBUGGING_NOT_POSSIBLE)
    CASE_HRESULT(CORDBG_E_KERNEL_DEBUGGER_ENABLED)
    CASE_HRESULT(CORDBG_E_KERNEL_DEBUGGER_PRESENT)
    CASE_HRESULT(CORDBG_E_HELPER_THREAD_DEAD)
    CASE_HRESULT(CORDBG_E_INTERFACE_INHERITANCE_CANT_CHANGE)
    CASE_HRESULT(CORDBG_E_INCOMPATIBLE_PROTOCOL)
    CASE_HRESULT(CORDBG_E_TOO_MANY_PROCESSES)
    CASE_HRESULT(CORDBG_E_INTEROP_NOT_SUPPORTED)
    CASE_HRESULT(CORDBG_E_NO_REMAP_BREAKPIONT)
    CASE_HRESULT(CORDBG_E_OBJECT_NEUTERED)
    CASE_HRESULT(CORPROF_E_FUNCTION_NOT_COMPILED)
    CASE_HRESULT(CORPROF_E_DATAINCOMPLETE)
    CASE_HRESULT(CORPROF_E_NOT_REJITABLE_METHODS)
    CASE_HRESULT(CORPROF_E_CANNOT_UPDATE_METHOD)
    CASE_HRESULT(CORPROF_E_FUNCTION_NOT_IL)
    CASE_HRESULT(CORPROF_E_NOT_MANAGED_THREAD)
    CASE_HRESULT(CORPROF_E_CALL_ONLY_FROM_INIT)
    CASE_HRESULT(CORPROF_E_INPROC_NOT_ENABLED)
    CASE_HRESULT(CORPROF_E_JITMAPS_NOT_ENABLED)
    CASE_HRESULT(CORPROF_E_INPROC_ALREADY_BEGUN)
    CASE_HRESULT(CORPROF_E_INPROC_NOT_AVAILABLE)
    CASE_HRESULT(CORPROF_E_NOT_YET_AVAILABLE)
    CASE_HRESULT(SECURITY_E_XML_TO_ASN_ENCODING)
    CASE_HRESULT(SECURITY_E_INCOMPATIBLE_SHARE)
    CASE_HRESULT(SECURITY_E_UNVERIFIABLE)
    CASE_HRESULT(SECURITY_E_INCOMPATIBLE_EVIDENCE)
    CASE_HRESULT(CLDB_E_INTERNALERROR)
    CASE_HRESULT(CORSEC_E_DECODE_SET)
    CASE_HRESULT(CORSEC_E_ENCODE_SET)
    CASE_HRESULT(CORSEC_E_UNSUPPORTED_FORMAT)
    CASE_HRESULT(SN_CRYPTOAPI_CALL_FAILED)
    CASE_HRESULT(SN_NO_SUITABLE_CSP)
    CASE_HRESULT(CORSEC_E_INVALID_ATTR)
    CASE_HRESULT(CORSEC_E_POLICY_EXCEPTION)
    CASE_HRESULT(CORSEC_E_MIN_GRANT_FAIL)
    CASE_HRESULT(CORSEC_E_NO_EXEC_PERM)
    CASE_HRESULT(CORSEC_E_XMLSYNTAX)
    CASE_HRESULT(CORSEC_E_INVALID_STRONGNAME)
    CASE_HRESULT(CORSEC_E_MISSING_STRONGNAME)
    CASE_HRESULT(CORSEC_E_CONTAINER_NOT_FOUND)
    CASE_HRESULT(CORSEC_E_INVALID_IMAGE_FORMAT)
    CASE_HRESULT(CORSEC_E_CRYPTO)
    CASE_HRESULT(CORSEC_E_CRYPTO_UNEX_OPER)
    CASE_HRESULT(CORSECATTR_E_BAD_ATTRIBUTE)
    CASE_HRESULT(CORSECATTR_E_MISSING_CONSTRUCTOR)
    CASE_HRESULT(CORSECATTR_E_FAILED_TO_CREATE_PERM)
    CASE_HRESULT(CORSECATTR_E_BAD_ACTION_ASM)
    CASE_HRESULT(CORSECATTR_E_BAD_ACTION_OTHER)
    CASE_HRESULT(CORSECATTR_E_BAD_PARENT)
    CASE_HRESULT(CORSECATTR_E_TRUNCATED)
    CASE_HRESULT(CORSECATTR_E_BAD_VERSION)
    CASE_HRESULT(CORSECATTR_E_BAD_ACTION)
    CASE_HRESULT(CORSECATTR_E_NO_SELF_REF)
    CASE_HRESULT(CORSECATTR_E_BAD_NONCAS)
    CASE_HRESULT(CORSECATTR_E_ASSEMBLY_LOAD_FAILED)
    CASE_HRESULT(CORSECATTR_E_ASSEMBLY_LOAD_FAILED_EX)
    CASE_HRESULT(CORSECATTR_E_TYPE_LOAD_FAILED)
    CASE_HRESULT(CORSECATTR_E_TYPE_LOAD_FAILED_EX)
    CASE_HRESULT(CORSECATTR_E_ABSTRACT)
    CASE_HRESULT(CORSECATTR_E_UNSUPPORTED_TYPE)
    CASE_HRESULT(CORSECATTR_E_UNSUPPORTED_ENUM_TYPE)
    CASE_HRESULT(CORSECATTR_E_NO_FIELD)
    CASE_HRESULT(CORSECATTR_E_NO_PROPERTY)
    CASE_HRESULT(CORSECATTR_E_EXCEPTION)
    CASE_HRESULT(CORSECATTR_E_EXCEPTION_HR)
    CASE_HRESULT(ISS_E_ISOSTORE)
    CASE_HRESULT(ISS_E_OPEN_STORE_FILE)
    CASE_HRESULT(ISS_E_OPEN_FILE_MAPPING)
    CASE_HRESULT(ISS_E_MAP_VIEW_OF_FILE)
    CASE_HRESULT(ISS_E_GET_FILE_SIZE)
    CASE_HRESULT(ISS_E_CREATE_MUTEX)
    CASE_HRESULT(ISS_E_LOCK_FAILED)
    CASE_HRESULT(ISS_E_FILE_WRITE)
    CASE_HRESULT(ISS_E_SET_FILE_POINTER)
    CASE_HRESULT(ISS_E_CREATE_DIR)
    CASE_HRESULT(ISS_E_STORE_NOT_OPEN)
    CASE_HRESULT(ISS_E_CORRUPTED_STORE_FILE)
    CASE_HRESULT(ISS_E_STORE_VERSION)
    CASE_HRESULT(ISS_E_FILE_NOT_MAPPED)
    CASE_HRESULT(ISS_E_BLOCK_SIZE_TOO_SMALL)
    CASE_HRESULT(ISS_E_ALLOC_TOO_LARGE)
    CASE_HRESULT(ISS_E_USAGE_WILL_EXCEED_QUOTA)
    CASE_HRESULT(ISS_E_TABLE_ROW_NOT_FOUND)
    CASE_HRESULT(ISS_E_DEPRECATE)
    CASE_HRESULT(ISS_E_CALLER)
    CASE_HRESULT(ISS_E_PATH_LENGTH)
    CASE_HRESULT(ISS_E_MACHINE)
    CASE_HRESULT(ISS_E_MACHINE_DACL)
    CASE_HRESULT(ISS_E_ISOSTORE_END)
    CASE_HRESULT(COR_E_APPLICATION)
    CASE_HRESULT(COR_E_ARGUMENTOUTOFRANGE)
    CASE_HRESULT(COR_E_ARITHMETIC)
    CASE_HRESULT(COR_E_ARRAYTYPEMISMATCH)
    CASE_HRESULT(COR_E_CONTEXTMARSHAL)
    CASE_HRESULT(COR_E_TIMEOUT)
    CASE_HRESULT(COR_E_DEVICESNOTSUPPORTED)
    CASE_HRESULT(COR_E_DIVIDEBYZERO)
    CASE_HRESULT(COR_E_EXCEPTION)
    CASE_HRESULT(COR_E_EXECUTIONENGINE)
    CASE_HRESULT(COR_E_FIELDACCESS)
    CASE_HRESULT(COR_E_FORMAT)
    CASE_HRESULT(COR_E_BADIMAGEFORMAT)
    CASE_HRESULT(COR_E_ASSEMBLYEXPECTED)
    CASE_HRESULT(COR_E_TYPEUNLOADED)
    CASE_HRESULT(COR_E_INDEXOUTOFRANGE)
    CASE_HRESULT(COR_E_INVALIDOPERATION)
    CASE_HRESULT(COR_E_INVALIDPROGRAM)
    CASE_HRESULT(COR_E_MEMBERACCESS)
    CASE_HRESULT(COR_E_METHODACCESS)
    CASE_HRESULT(COR_E_MISSINGFIELD)
    CASE_HRESULT(COR_E_MISSINGMANIFESTRESOURCE)
    CASE_HRESULT(COR_E_MISSINGMEMBER)
    CASE_HRESULT(COR_E_MISSINGMETHOD)
    CASE_HRESULT(COR_E_MULTICASTNOTSUPPORTED)
    CASE_HRESULT(COR_E_NOTFINITENUMBER)
    CASE_HRESULT(COR_E_DUPLICATEWAITOBJECT)
    CASE_HRESULT(COR_E_PLATFORMNOTSUPPORTED)
    CASE_HRESULT(COR_E_NOTSUPPORTED)
    CASE_HRESULT(COR_E_OVERFLOW)
    CASE_HRESULT(COR_E_RANK)
    CASE_HRESULT(COR_E_REMOTING)
    CASE_HRESULT(COR_E_SERVER)
    CASE_HRESULT(COR_E_SERVICEDCOMPONENT)
    CASE_HRESULT(COR_E_SECURITY)
    CASE_HRESULT(COR_E_SERIALIZATION)
    CASE_HRESULT(COR_E_STACKOVERFLOW)
    CASE_HRESULT(COR_E_SYNCHRONIZATIONLOCK)
    CASE_HRESULT(COR_E_SYSTEM)
    CASE_HRESULT(COR_E_THREADABORTED)
    CASE_HRESULT(COR_E_THREADINTERRUPTED)
    CASE_HRESULT(COR_E_THREADSTATE)
    CASE_HRESULT(COR_E_THREADSTOP)
    CASE_HRESULT(COR_E_TYPEINITIALIZATION)
    CASE_HRESULT(COR_E_TYPELOAD)
    CASE_HRESULT(COR_E_ENTRYPOINTNOTFOUND)
    CASE_HRESULT(COR_E_DLLNOTFOUND)
    CASE_HRESULT(COR_E_VERIFICATION)
    CASE_HRESULT(COR_E_INVALIDCOMOBJECT)
    CASE_HRESULT(COR_E_MARSHALDIRECTIVE)
    CASE_HRESULT(COR_E_INVALIDOLEVARIANTTYPE)
    CASE_HRESULT(COR_E_SAFEARRAYTYPEMISMATCH)
    CASE_HRESULT(COR_E_SAFEARRAYRANKMISMATCH)
    CASE_HRESULT(COR_E_INVALIDFILTERCRITERIA)
    CASE_HRESULT(COR_E_REFLECTIONTYPELOAD)
    CASE_HRESULT(COR_E_TARGET)
    CASE_HRESULT(COR_E_TARGETINVOCATION)
    CASE_HRESULT(COR_E_CUSTOMATTRIBUTEFORMAT)
    CASE_HRESULT(COR_E_ENDOFSTREAM)
    CASE_HRESULT(COR_E_FILELOAD)
    CASE_HRESULT(COR_E_FILENOTFOUND)
    CASE_HRESULT(COR_E_BAD_PATHNAME)
    CASE_HRESULT(COR_E_IO)
    CASE_HRESULT(COR_E_DIRECTORYNOTFOUND)
    CASE_HRESULT(COR_E_PATHTOOLONG)
    CASE_HRESULT(COR_E_OBJECTDISPOSED)
    CASE_HRESULT(COR_E_NEWER_RUNTIME)
    CASE_HRESULT(CLR_E_SHIM_RUNTIMELOAD)
    CASE_HRESULT(CLR_E_SHIM_RUNTIMEEXPORT)
    CASE_HRESULT(CLR_E_SHIM_INSTALLROOT)
    CASE_HRESULT(CLR_E_SHIM_INSTALLCOMP)
    CASE_HRESULT(VER_E_HRESULT)
    CASE_HRESULT(VER_E_OFFSET)
    CASE_HRESULT(VER_E_OPCODE)
    CASE_HRESULT(VER_E_OPERAND)
    CASE_HRESULT(VER_E_TOKEN)
    CASE_HRESULT(VER_E_EXCEPT)
    CASE_HRESULT(VER_E_STACK_SLOT)
    CASE_HRESULT(VER_E_LOC)
    CASE_HRESULT(VER_E_ARG)
    CASE_HRESULT(VER_E_FOUND)
    CASE_HRESULT(VER_E_EXPECTED)
    CASE_HRESULT(VER_E_UNKNOWN_OPCODE)
    CASE_HRESULT(VER_E_SIG_CALLCONV)
    CASE_HRESULT(VER_E_SIG_ELEMTYPE)
    CASE_HRESULT(VER_E_RET_SIG)
    CASE_HRESULT(VER_E_FIELD_SIG)
    CASE_HRESULT(VER_E_INTERNAL)
    CASE_HRESULT(VER_E_STACK_TOO_LARGE)
    CASE_HRESULT(VER_E_ARRAY_NAME_LONG)
    CASE_HRESULT(VER_E_FALLTHRU)
    CASE_HRESULT(VER_E_TRY_GTEQ_END)
    CASE_HRESULT(VER_E_TRYEND_GT_CS)
    CASE_HRESULT(VER_E_HND_GTEQ_END)
    CASE_HRESULT(VER_E_HNDEND_GT_CS)
    CASE_HRESULT(VER_E_FLT_GTEQ_CS)
    CASE_HRESULT(VER_E_TRY_START)
    CASE_HRESULT(VER_E_HND_START)
    CASE_HRESULT(VER_E_FLT_START)
    CASE_HRESULT(VER_E_TRY_OVERLAP)
    CASE_HRESULT(VER_E_TRY_EQ_HND_FIL)
    CASE_HRESULT(VER_E_TRY_SHARE_FIN_FAL)
    CASE_HRESULT(VER_E_HND_OVERLAP)
    CASE_HRESULT(VER_E_HND_EQ)
    CASE_HRESULT(VER_E_FIL_OVERLAP)
    CASE_HRESULT(VER_E_FIL_EQ)
    CASE_HRESULT(VER_E_FIL_CONT_TRY)
    CASE_HRESULT(VER_E_FIL_CONT_HND)
    CASE_HRESULT(VER_E_FIL_CONT_FIL)
    CASE_HRESULT(VER_E_FIL_GTEQ_CS)
    CASE_HRESULT(VER_E_FIL_START)
    CASE_HRESULT(VER_E_FALLTHRU_EXCEP)
    CASE_HRESULT(VER_E_FALLTHRU_INTO_HND)
    CASE_HRESULT(VER_E_FALLTHRU_INTO_FIL)
    CASE_HRESULT(VER_E_LEAVE)
    CASE_HRESULT(VER_E_RETHROW)
    CASE_HRESULT(VER_E_ENDFINALLY)
    CASE_HRESULT(VER_E_ENDFILTER)
    CASE_HRESULT(VER_E_ENDFILTER_MISSING)
    CASE_HRESULT(VER_E_BR_INTO_TRY)
    CASE_HRESULT(VER_E_BR_INTO_HND)
    CASE_HRESULT(VER_E_BR_INTO_FIL)
    CASE_HRESULT(VER_E_BR_OUTOF_TRY)
    CASE_HRESULT(VER_E_BR_OUTOF_HND)
    CASE_HRESULT(VER_E_BR_OUTOF_FIL)
    CASE_HRESULT(VER_E_BR_OUTOF_FIN)
    CASE_HRESULT(VER_E_RET_FROM_TRY)
    CASE_HRESULT(VER_E_RET_FROM_HND)
    CASE_HRESULT(VER_E_RET_FROM_FIL)
    CASE_HRESULT(VER_E_BAD_JMP_TARGET)
    CASE_HRESULT(VER_E_PATH_LOC)
    CASE_HRESULT(VER_E_PATH_THIS)
    CASE_HRESULT(VER_E_PATH_STACK)
    CASE_HRESULT(VER_E_PATH_STACK_DEPTH)
    CASE_HRESULT(VER_E_THIS)
    CASE_HRESULT(VER_E_THIS_UNINIT_EXCEP)
    CASE_HRESULT(VER_E_THIS_UNINIT_STORE)
    CASE_HRESULT(VER_E_THIS_UNINIT_RET)
    CASE_HRESULT(VER_E_THIS_UNINIT_V_RET)
    CASE_HRESULT(VER_E_THIS_UNINIT_BR)
    CASE_HRESULT(VER_E_LDFTN_CTOR)
    CASE_HRESULT(VER_E_STACK_NOT_EQ)
    CASE_HRESULT(VER_E_STACK_UNEXPECTED)
    CASE_HRESULT(VER_E_STACK_EXCEPTION)
    CASE_HRESULT(VER_E_STACK_OVERFLOW)
    CASE_HRESULT(VER_E_STACK_UNDERFLOW)
    CASE_HRESULT(VER_E_STACK_EMPTY)
    CASE_HRESULT(VER_E_STACK_UNINIT)
    CASE_HRESULT(VER_E_STACK_I_I4_I8)
    CASE_HRESULT(VER_E_STACK_R_R4_R8)
    CASE_HRESULT(VER_E_STACK_NO_R_I8)
    CASE_HRESULT(VER_E_STACK_NUMERIC)
    CASE_HRESULT(VER_E_STACK_OBJREF)
    CASE_HRESULT(VER_E_STACK_P_OBJREF)
    CASE_HRESULT(VER_E_STACK_BYREF)
    CASE_HRESULT(VER_E_STACK_METHOD)
    CASE_HRESULT(VER_E_STACK_ARRAY_SD)
    CASE_HRESULT(VER_E_STACK_VALCLASS)
    CASE_HRESULT(VER_E_STACK_P_VALCLASS)
    CASE_HRESULT(VER_E_STACK_NO_VALCLASS)
    CASE_HRESULT(VER_E_LOC_DEAD)
    CASE_HRESULT(VER_E_LOC_NUM)
    CASE_HRESULT(VER_E_ARG_NUM)
    CASE_HRESULT(VER_E_TOKEN_RESOLVE)
    CASE_HRESULT(VER_E_TOKEN_TYPE)
    CASE_HRESULT(VER_E_TOKEN_TYPE_MEMBER)
    CASE_HRESULT(VER_E_TOKEN_TYPE_FIELD)
    CASE_HRESULT(VER_E_TOKEN_TYPE_SIG)
    CASE_HRESULT(VER_E_UNVERIFIABLE)
    CASE_HRESULT(VER_E_LDSTR_OPERAND)
    CASE_HRESULT(VER_E_RET_PTR_TO_STACK)
    CASE_HRESULT(VER_E_RET_VOID)
    CASE_HRESULT(VER_E_RET_MISSING)
    CASE_HRESULT(VER_E_RET_EMPTY)
    CASE_HRESULT(VER_E_RET_UNINIT)
    CASE_HRESULT(VER_E_ARRAY_ACCESS)
    CASE_HRESULT(VER_E_ARRAY_V_STORE)
    CASE_HRESULT(VER_E_ARRAY_SD)
    CASE_HRESULT(VER_E_ARRAY_SD_PTR)
    CASE_HRESULT(VER_E_ARRAY_FIELD)
    CASE_HRESULT(VER_E_ARGLIST)
    CASE_HRESULT(VER_E_VALCLASS)
    CASE_HRESULT(VER_E_METHOD_ACCESS)
    CASE_HRESULT(VER_E_FIELD_ACCESS)
    CASE_HRESULT(VER_E_DEAD)
    CASE_HRESULT(VER_E_FIELD_STATIC)
    CASE_HRESULT(VER_E_FIELD_NO_STATIC)
    CASE_HRESULT(VER_E_ADDR)
    CASE_HRESULT(VER_E_ADDR_BYREF)
    CASE_HRESULT(VER_E_ADDR_LITERAL)
    CASE_HRESULT(VER_E_INITONLY)
    CASE_HRESULT(VER_E_THROW)
    CASE_HRESULT(VER_E_CALLVIRT_VALCLASS)
    CASE_HRESULT(VER_E_CALL_SIG)
    CASE_HRESULT(VER_E_CALL_STATIC)
    CASE_HRESULT(VER_E_CTOR)
    CASE_HRESULT(VER_E_CTOR_VIRT)
    CASE_HRESULT(VER_E_CTOR_OR_SUPER)
    CASE_HRESULT(VER_E_CTOR_MUL_INIT)
    CASE_HRESULT(VER_E_SIG)
    CASE_HRESULT(VER_E_SIG_ARRAY)
    CASE_HRESULT(VER_E_SIG_ARRAY_PTR)
    CASE_HRESULT(VER_E_SIG_ARRAY_BYREF)
    CASE_HRESULT(VER_E_SIG_ELEM_PTR)
    CASE_HRESULT(VER_E_SIG_VARARG)
    CASE_HRESULT(VER_E_SIG_VOID)
    CASE_HRESULT(VER_E_SIG_BYREF_BYREF)
    CASE_HRESULT(VER_E_CODE_SIZE_ZERO)
    CASE_HRESULT(VER_E_BAD_VARARG)
    CASE_HRESULT(VER_E_TAIL_CALL)
    CASE_HRESULT(VER_E_TAIL_BYREF)
    CASE_HRESULT(VER_E_TAIL_RET)
    CASE_HRESULT(VER_E_TAIL_RET_VOID)
    CASE_HRESULT(VER_E_TAIL_RET_TYPE)
    CASE_HRESULT(VER_E_TAIL_STACK_EMPTY)
    CASE_HRESULT(VER_E_METHOD_END)
    CASE_HRESULT(VER_E_BAD_BRANCH)
    CASE_HRESULT(VER_E_FIN_OVERLAP)
    CASE_HRESULT(VER_E_LEXICAL_NESTING)
    CASE_HRESULT(VER_E_VOLATILE)
    CASE_HRESULT(VER_E_UNALIGNED)
    CASE_HRESULT(VER_E_INNERMOST_FIRST)
    CASE_HRESULT(VER_E_CALLI_VIRTUAL)
    CASE_HRESULT(VER_E_CALL_ABSTRACT)
    CASE_HRESULT(VER_E_STACK_UNEXP_ARRAY)
    CASE_HRESULT(VER_E_NOT_IN_GC_HEAP)
    CASE_HRESULT(VER_E_TRY_N_EMPTY_STACK)
    CASE_HRESULT(VER_E_DLGT_CTOR)
    CASE_HRESULT(VER_E_DLGT_BB)
    CASE_HRESULT(VER_E_DLGT_PATTERN)
    CASE_HRESULT(VER_E_DLGT_LDFTN)
    CASE_HRESULT(VER_E_FTN_ABSTRACT)
    CASE_HRESULT(VER_E_SIG_C_VC)
    CASE_HRESULT(VER_E_SIG_VC_C)
    CASE_HRESULT(VER_E_BOX_PTR_TO_STACK)
    CASE_HRESULT(VER_E_SIG_BYREF_TB_AH)
    CASE_HRESULT(VER_E_SIG_ARRAY_TB_AH)
    CASE_HRESULT(VER_E_ENDFILTER_STACK)
    CASE_HRESULT(VER_E_DLGT_SIG_I)
    CASE_HRESULT(VER_E_DLGT_SIG_O)
    CASE_HRESULT(VER_E_RA_PTR_TO_STACK)
    CASE_HRESULT(VER_E_CATCH_VALUE_TYPE)
    CASE_HRESULT(VER_E_CATCH_BYREF)
    CASE_HRESULT(VER_E_FIL_PRECEED_HND)
    CASE_HRESULT(VER_E_LDVIRTFTN_STATIC)
    CASE_HRESULT(VER_E_CALLVIRT_STATIC)
    CASE_HRESULT(VER_E_INITLOCALS)
    CASE_HRESULT(VER_E_BR_TO_EXCEPTION)
    CASE_HRESULT(VER_E_CALL_CTOR)
    CASE_HRESULT(VER_E_BAD_PE)
    CASE_HRESULT(VER_E_BAD_MD)
    CASE_HRESULT(VER_E_BAD_APPDOMAIN)
    CASE_HRESULT(VER_E_TYPELOAD)
    CASE_HRESULT(VER_E_PE_LOAD)
    CASE_HRESULT(VER_E_WRITE_RVA_STATIC)
    CASE_HRESULT(CORDBG_E_THREAD_NOT_SCHEDULED)
#endif

        default:
            return NULL;
    }
}


// ---------------------------------------------------------------------------
// HRException class.  Implements exception API for exceptions from HRESULTS
// ---------------------------------------------------------------------------

HRESULT HRException::GetHR()
{
    LEAF_CONTRACT;
    return m_hr; 
}

// ---------------------------------------------------------------------------
// COMException class. - moved to COMEx.cpp
// ---------------------------------------------------------------------------

// ---------------------------------------------------------------------------
// SEHException class.  Implements exception API for SEH exception info
// ---------------------------------------------------------------------------

HRESULT SEHException::GetHR()
{
    LEAF_CONTRACT;

    if (m_exception.ExceptionCode == 0xe0434f4d) // EE exception
        return (HRESULT) m_exception.ExceptionInformation[0];
    else
        return m_exception.ExceptionCode;
}

IErrorInfo *SEHException::GetErrorInfo() 
{
    LEAF_CONTRACT;
    return NULL;
}

void SEHException::GetMessage(SString &string)
{
    WRAPPER_CONTRACT;
    
    if (m_exception.ExceptionCode == 0xe0434f4d) // EE exception
    {
        GenerateTopLevelHRExceptionMessage(GetHR(), string);
    }
    else
    {
        if (m_exception.ExceptionCode != 0)
        {
            string.Printf("Exception code 0x%.8x", m_exception.ExceptionCode);
        }
        else
        {
            // If we don't have a valid exception code, then give a generic message that's a little nicer than
            // "code 0x00000000".
            string.Printf("Unknown exception");
        }
    }
}

//==============================================================================
// DelegatingException class.  Implements exception API for "foreign" exceptions.
//==============================================================================

DelegatingException::DelegatingException()
 : m_delegatedException((Exception*)DELEGATE_NOT_YET_SET)
{
    LEAF_CONTRACT;
} // DelegatingException::DelegatingException()

//------------------------------------------------------------------------------
DelegatingException::~DelegatingException()
{
    WRAPPER_CONTRACT;
    
    // If there is a valid delegate pointer (inited and non-NULL), delete it.
    if (IsDelegateValid())
        Delete(m_delegatedException);

    // Avoid confusion.
    m_delegatedException = NULL;
} // DelegatingException::~DelegatingException()

//------------------------------------------------------------------------------
// Retrieve the delegating exception, or get one from the Thread, or get NULL.
Exception* DelegatingException::GetDelegate()
{
    WRAPPER_CONTRACT;
    
    // If we haven't gotten the exception pointer before..
    if (!IsDelegateSet())
    {
        // .. get it now.  NULL in case there isn't one and we take default action.
        m_delegatedException = NULL;
        GetLastThrownObjectExceptionFromThread(reinterpret_cast<void**>(&m_delegatedException));
    }

    return m_delegatedException;
} // Exception* DelegatingException::GetDelegate()

//------------------------------------------------------------------------------
// Virtual overrides
HRESULT DelegatingException::GetHR()
{
    WRAPPER_CONTRACT;

    // Retrieve any delegating exception.
    Exception *pDelegate = GetDelegate();

    // If there is a delegate exception, defer to it.  Otherwise,
    //  default to E_FAIL.
    return pDelegate ? pDelegate->GetHR() : E_FAIL;

} // HRESULT DelegatingException::GetHR()

//------------------------------------------------------------------------------
IErrorInfo *DelegatingException::GetErrorInfo()
{
    WRAPPER_CONTRACT;
    
    // Retrieve any delegating exception.
    Exception *pDelegate = GetDelegate();

    // If there is a delegate exception, defer to it.  Otherwise,
    //  default to NULL.
    return pDelegate ? pDelegate->GetErrorInfo() : NULL;

} // IErrorInfo *DelegatingException::GetErrorInfo()

//------------------------------------------------------------------------------
void DelegatingException::GetMessage(SString &result)
{
    WRAPPER_CONTRACT;
    
    // Retrieve any delegating exception.
    Exception *pDelegate = GetDelegate();

    // If there is a delegate exception, defer to it.  Otherwise,
    //  default to a generic message.
    if (pDelegate)
    {
        pDelegate->GetMessage(result);
    }
    else
    {
        // If we don't have a valid exception code, then give a generic message 
        //  that's a little nicer than "code 0x00000000".
        result.Printf("Unknown exception");
    }
} // void DelegatingException::GetMessage()

//------------------------------------------------------------------------------
Exception *DelegatingException::Clone()
{
    WRAPPER_CONTRACT;

    // Clone the base exception, this will also take care of cloning the inner 
    // exception if there is one.
    NewHolder<DelegatingException> retExcep((DelegatingException*)Exception::Clone());
        
    // If there is a valid delegating exception...
    if (IsDelegateValid())
    {   // ... clone it.
        retExcep->m_delegatedException = m_delegatedException->Clone();
    }
    else
    {   // ... but if there is not, just copy -- either NULL or DELEGATE_NOT_YET_SET
        retExcep->m_delegatedException = m_delegatedException;
    }

    retExcep.SuppressRelease();
    return retExcep;
} // virtual Exception *DelegatingException::Clone()

//==============================================================================
//==============================================================================

void DECLSPEC_NORETURN ThrowHR(HRESULT hr)
{
    WRAPPER_CONTRACT;

    STRESS_LOG1(LF_EH, LL_INFO100, "ThrowHR: HR = %x\n", hr);
    
    if (hr == E_OUTOFMEMORY)
        ThrowOutOfMemory();

    if (hr == S_OK)
        hr = E_FAIL;

    EX_THROW(HRException, (hr));
}

void DECLSPEC_NORETURN ThrowHR(HRESULT hr, SString &msg)
{
    WRAPPER_CONTRACT;

    STRESS_LOG1(LF_EH, LL_INFO100, "ThrowHR: HR = %x\n", hr);
    
    if (hr == E_OUTOFMEMORY)
        ThrowOutOfMemory();

    if (hr == S_OK)
        hr = E_FAIL;

    EX_THROW(HRMsgException, (hr, msg));
}

void DECLSPEC_NORETURN ThrowHR(HRESULT hr, UINT uText)
{
    WRAPPER_CONTRACT;

    if (hr == E_OUTOFMEMORY)
        ThrowOutOfMemory();

    if (hr == S_OK)
        hr = E_FAIL;

    SString sExceptionText;

    // We won't check the return value here. If it fails, we'll just
    // throw the HR
    sExceptionText.LoadResource(uText, FALSE);

    EX_THROW(HRMsgException, (hr, sExceptionText));
}

void DECLSPEC_NORETURN ThrowWin32(DWORD err)
{
    WRAPPER_CONTRACT;
    if (err == ERROR_NOT_ENOUGH_MEMORY)
    {
        ThrowOutOfMemory();
    }
    else
    {
        ThrowHR(HRESULT_FROM_WIN32(err));
    }
}

void DECLSPEC_NORETURN ThrowLastError()
{
    WRAPPER_CONTRACT;
    ThrowWin32(GetLastError());
}

void DECLSPEC_NORETURN ThrowOutOfMemory()
{
    CONTRACTL
    {
        THROWS;
        GC_NOTRIGGER;
        SO_TOLERANT;
    }
    CONTRACTL_END;
    
    PAL_CPP_THROW(Exception *, Exception::GetOOMException());
}

void DECLSPEC_NORETURN ThrowStackOverflow()
{
    CONTRACTL
    {
        THROWS;
        GC_NOTRIGGER;
        SO_TOLERANT;
    }
    CONTRACTL_END;
    
    PAL_CPP_THROW(Exception *, Exception::GetSOException());
}

void DECLSPEC_NORETURN ThrowMessage(LPCSTR string, ...)
{
    CONTRACTL
    {
        THROWS;
        GC_NOTRIGGER;
        SO_TOLERANT;
    }
    CONTRACTL_END;
    
    StackSString message;

    va_list args;
    va_start(args, string);
    message.VPrintf(string, args);
    va_end(args);

    EX_THROW(HRMsgException, (E_FAIL, message));
}


//--------------------------------------------------------------------------------
// Helper for EX_THROW_WITH_INNER()
//
// Clones an exception into the current domain. Also handles special cases for
// OOM and other stuff. Making this a function so we don't inline all this logic
// every place we call EX_THROW_WITH_INNER.
//
// If the "inner" is a transient exception such as OOM or ThreadAbort, this function
// will just throw it rather than allow it to be wrapped in another exception.
//--------------------------------------------------------------------------------
Exception *ExThrowWithInnerHelper(Exception *inner)
{
    CONTRACTL
    {
        THROWS;
        GC_NOTRIGGER;
    }
    CONTRACTL_END

    // Yes, NULL is a legal case. Makes it easier to author uniform helpers for
    // both wrapped and normal exceptions.
    if (inner == NULL)
    {
        return NULL;
    }

    if (inner == Exception::GetOOMException())
    {
        // We don't want to do allocations if we're already throwing an OOM!
        PAL_CPP_THROW(Exception*, inner);
    }

    inner = inner->DomainBoundClone();

    // It isn't useful to wrap OOMs and StackOverflows in other exceptions. Just throw them now.
    // 
    if (inner->IsTransient())
    {
        PAL_CPP_THROW(Exception*, inner);
    }
    return inner;
}

#ifdef _DEBUG



void ExThrowTrap(const char *fcn, const char *file, int line, const char *szType, HRESULT hr, const char *args)
{
    return;
}
#endif




//-------------------------------------------------------------------------------------------
// This routine will generate the most descriptive possible error message for an hresult.
// It will generate at minimum the hex value. It will also try to generate the symbolic name
// (E_POINTER) and the friendly description (from the message tables.)
//
// bNoGeekStuff suppresses hex HR codes. Use this sparingly as most error strings generated by the
// CLR are aimed at developers, not end-users.
//-------------------------------------------------------------------------------------------
void GetHRMsg(HRESULT hr, SString &result, BOOL bNoGeekStuff/* = FALSE*/)
{
    CONTRACTL
    {
        GC_NOTRIGGER;
        THROWS;
    }
    CONTRACTL_END;

    result = L"";     // Make sure this routine isn't an inadvertent data-leak exploit!

    
    DWORD dwFlags = FORMAT_MESSAGE_FROM_SYSTEM;

    SString strDescr;
    BOOL    fHaveDescr = FALSE;

    if (FAILED(hr) && HRESULT_FACILITY(hr) == FACILITY_URT && HRESULT_CODE(hr) < MAX_URT_HRESULT_CODE)
    {
        fHaveDescr = strDescr.LoadResource(MSG_FOR_URT_HR(hr), /*bQuiet = */TRUE);
    }
    else
    {
        fHaveDescr = strDescr.FormatMessage(dwFlags, 0, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT));
    }

    LPCSTR name = Exception::GetHRSymbolicName(hr);

    // If we can't get a resource string, print the hresult regardless.
    if (!fHaveDescr)
    {
        bNoGeekStuff = FALSE;
    }

    if (fHaveDescr)
    {
        result.Append(strDescr);
    }

    if (!bNoGeekStuff)
    {
        if (fHaveDescr)
        {
            result.Append(L" (");
        }

        SString strExcepFromHR;
        strExcepFromHR.LoadResource(IDS_EE_EXCEPTION_FROM_HRESULT, TRUE);
        result.Append(strExcepFromHR);
        result.AppendPrintf(L"0x%.8X", hr);
        if (name != NULL)
        {
            result.AppendPrintf(L" (%S)", name);
        }


        if (fHaveDescr)
        {
            result.Append(L")");
        }

    }
}


//-------------------------------------------------------------------------------------------
// Similar to GetHRMsg but phrased for top-level exception message.
//-------------------------------------------------------------------------------------------
void GenerateTopLevelHRExceptionMessage(HRESULT hresult, SString &result)
{
    CONTRACTL
    {
        GC_NOTRIGGER;
        THROWS;
    }
    CONTRACTL_END;

    result = L"";     // Make sure this routine isn't an inadvertent data-leak exploit!

    GetHRMsg(hresult, result);
}

