; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\OSes\VERVE\verify\src\Trusted\BootLoader\SingLdrPc\blfat.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BlFatRootStart@@3KA				; BlFatRootStart
PUBLIC	?BlFatDriveId@@3EA				; BlFatDriveId
PUBLIC	?BlFatGetNextCluster@@3P6IEKPAK@ZA		; BlFatGetNextCluster
PUBLIC	?BlFatTotalSectorCount@@3KA			; BlFatTotalSectorCount
PUBLIC	?BlFatNumberOfDataClusters@@3KA			; BlFatNumberOfDataClusters
PUBLIC	?BlFatPartitionId@@3KA				; BlFatPartitionId
PUBLIC	?BlFatTableStart@@3KA				; BlFatTableStart
PUBLIC	?BlFatBytesPerCluster@@3KA			; BlFatBytesPerCluster
PUBLIC	?BlFatPartitionSize@@3KA			; BlFatPartitionSize
PUBLIC	?BlFatRootDirectory@@3PAU_FAT_DIRECTORY_ENTRY@@A ; BlFatRootDirectory
PUBLIC	?BlFatLinkTerminator@@3KA			; BlFatLinkTerminator
PUBLIC	?BlFatBootSector@@3U_FAT_BOOT_SECTOR@@A		; BlFatBootSector
PUBLIC	?BlFatNumberOfRootDirectoryEntries@@3KA		; BlFatNumberOfRootDirectoryEntries
PUBLIC	?BlFatMbr@@3U_MBR@@A				; BlFatMbr
PUBLIC	?BlFatDataStart@@3KA				; BlFatDataStart
PUBLIC	?BlFatDriveParameters@@3U_INT13_DRIVE_PARAMETERS@@A ; BlFatDriveParameters
PUBLIC	?BlFatSectorsPerCluster@@3KA			; BlFatSectorsPerCluster
PUBLIC	?BlFatTemporaryBlock@@3PAU_FAT_SECTOR@@A	; BlFatTemporaryBlock
PUBLIC	?BlFatPartitionStart@@3KA			; BlFatPartitionStart
PUBLIC	?BlFatTemporaryBlockCount@@3GA			; BlFatTemporaryBlockCount
_BSS	SEGMENT
?BlFatRootStart@@3KA DD 01H DUP (?)			; BlFatRootStart
?BlFatDriveId@@3EA DB 01H DUP (?)			; BlFatDriveId
	ALIGN	4

?BlFatGetNextCluster@@3P6IEKPAK@ZA DD 01H DUP (?)	; BlFatGetNextCluster
?BlFatTotalSectorCount@@3KA DD 01H DUP (?)		; BlFatTotalSectorCount
?BlFatNumberOfDataClusters@@3KA DD 01H DUP (?)		; BlFatNumberOfDataClusters
?BlFatPartitionId@@3KA DD 01H DUP (?)			; BlFatPartitionId
?BlFatTableStart@@3KA DD 01H DUP (?)			; BlFatTableStart
?BlFatBytesPerCluster@@3KA DD 01H DUP (?)		; BlFatBytesPerCluster
?BlFatPartitionSize@@3KA DD 01H DUP (?)			; BlFatPartitionSize
?BlFatRootDirectory@@3PAU_FAT_DIRECTORY_ENTRY@@A DD 01H DUP (?) ; BlFatRootDirectory
?BlFatLinkTerminator@@3KA DD 01H DUP (?)		; BlFatLinkTerminator
?BlFatBootSector@@3U_FAT_BOOT_SECTOR@@A DB 0200H DUP (?) ; BlFatBootSector
?BlFatNumberOfRootDirectoryEntries@@3KA DD 01H DUP (?)	; BlFatNumberOfRootDirectoryEntries
?BlFatMbr@@3U_MBR@@A DB 0200H DUP (?)			; BlFatMbr
?BlFatDataStart@@3KA DD 01H DUP (?)			; BlFatDataStart
?BlFatDriveParameters@@3U_INT13_DRIVE_PARAMETERS@@A DB 01aH DUP (?) ; BlFatDriveParameters
	ALIGN	4

?BlFatSectorsPerCluster@@3KA DD 01H DUP (?)		; BlFatSectorsPerCluster
?BlFatTemporaryBlock@@3PAU_FAT_SECTOR@@A DB 08000H DUP (?) ; BlFatTemporaryBlock
?BlFatPartitionStart@@3KA DD 01H DUP (?)		; BlFatPartitionStart
_BSS	ENDS
_DATA	SEGMENT
?BlFatTemporaryBlockCount@@3GA DW 040H			; BlFatTemporaryBlockCount
_DATA	ENDS
PUBLIC	??_C@_09PEGKEIOA@blfat?4cpp?$AA@		; `string'
PUBLIC	??_C@_0CA@LMKLIJFF@FAT?3?5Error?5reading?5disk?5image?$CB?6?$AA@ ; `string'
PUBLIC	?BlFatHaltInternal@@YIXK@Z			; BlFatHaltInternal
EXTRN	?BlRtlHaltInternal@@YIXPBDK@Z:PROC		; BlRtlHaltInternal
EXTRN	?BlRtlPrintf@@YAEPBDZZ:PROC			; BlRtlPrintf
;	COMDAT ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
; File d:\oses\verve\verify\src\trusted\bootloader\singldrpc\blfat.cpp
CONST	SEGMENT
??_C@_09PEGKEIOA@blfat?4cpp?$AA@ DB 'blfat.cpp', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@LMKLIJFF@FAT?3?5Error?5reading?5disk?5image?$CB?6?$AA@
CONST	SEGMENT
??_C@_0CA@LMKLIJFF@FAT?3?5Error?5reading?5disk?5image?$CB?6?$AA@ DB 'FAT:'
	DB	' Error reading disk image!', 0aH, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlFatHaltInternal@@YIXK@Z
_TEXT	SEGMENT
_Line$ = -4						; size = 4
?BlFatHaltInternal@@YIXK@Z PROC				; BlFatHaltInternal, COMDAT
; _Line$ = ecx

; 237  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _Line$[ebp], ecx

; 238  :     BlRtlPrintf("FAT: Error reading disk image!\n");

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@LMKLIJFF@FAT?3?5Error?5reading?5disk?5image?$CB?6?$AA@
  0000c	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00011	83 c4 04	 add	 esp, 4

; 239  :     BlRtlHaltInternal(__FILE__, Line);

  00014	8b 55 fc	 mov	 edx, DWORD PTR _Line$[ebp]
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  0001c	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal

; 240  : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
?BlFatHaltInternal@@YIXK@Z ENDP				; BlFatHaltInternal
_TEXT	ENDS
PUBLIC	?BlFatReadSector@@YIEKKPAU_FAT_SECTOR@@@Z	; BlFatReadSector
EXTRN	?BlRtlCopyMemory@@YIXPAXPBXK@Z:PROC		; BlRtlCopyMemory
EXTRN	?BlRtlReadDrive@@YIEE_KGPAX@Z:PROC		; BlRtlReadDrive
EXTRN	?BlRtlAssertFailed@@YIXPBDK@Z:PROC		; BlRtlAssertFailed
EXTRN	?BlRtlAssertFailedPtr@@YIXPBDKK@Z:PROC		; BlRtlAssertFailedPtr
; Function compile flags: /Odtp
;	COMDAT ?BlFatReadSector@@YIEKKPAU_FAT_SECTOR@@@Z
_TEXT	SEGMENT
_NumberOfSectors$ = -12					; size = 4
_FirstSector$ = -8					; size = 4
_StepSize$ = -4						; size = 2
_Buffer$ = 8						; size = 4
?BlFatReadSector@@YIEKKPAU_FAT_SECTOR@@@Z PROC		; BlFatReadSector, COMDAT
; _FirstSector$ = ecx
; _NumberOfSectors$ = edx

; 270  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 55 f4	 mov	 DWORD PTR _NumberOfSectors$[ebp], edx
  00009	89 4d f8	 mov	 DWORD PTR _FirstSector$[ebp], ecx

; 271  :     UINT16 StepSize;
; 272  : 
; 273  :     BLASSERT_PTR(FirstSector < BlFatTotalSectorCount, FirstSector);

  0000c	8b 45 f8	 mov	 eax, DWORD PTR _FirstSector$[ebp]
  0000f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  00015	72 13		 jb	 SHORT $LN9@BlFatReadS
  00017	8b 4d f8	 mov	 ecx, DWORD PTR _FirstSector$[ebp]
  0001a	51		 push	 ecx
  0001b	ba 11 01 00 00	 mov	 edx, 273		; 00000111H
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  00025	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN9@BlFatReadS:

; 274  : 
; 275  :     BLASSERT(NumberOfSectors > 0);

  0002a	83 7d f4 00	 cmp	 DWORD PTR _NumberOfSectors$[ebp], 0
  0002e	77 0f		 ja	 SHORT $LN8@BlFatReadS
  00030	ba 13 01 00 00	 mov	 edx, 275		; 00000113H
  00035	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  0003a	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN8@BlFatReadS:

; 276  : 
; 277  :     BLASSERT(FirstSector + NumberOfSectors > FirstSector);

  0003f	8b 55 f8	 mov	 edx, DWORD PTR _FirstSector$[ebp]
  00042	03 55 f4	 add	 edx, DWORD PTR _NumberOfSectors$[ebp]
  00045	3b 55 f8	 cmp	 edx, DWORD PTR _FirstSector$[ebp]
  00048	77 0f		 ja	 SHORT $LN7@BlFatReadS
  0004a	ba 15 01 00 00	 mov	 edx, 277		; 00000115H
  0004f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  00054	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN7@BlFatReadS:

; 278  : 
; 279  :     BLASSERT((FirstSector + NumberOfSectors) < BlFatTotalSectorCount);

  00059	8b 45 f8	 mov	 eax, DWORD PTR _FirstSector$[ebp]
  0005c	03 45 f4	 add	 eax, DWORD PTR _NumberOfSectors$[ebp]
  0005f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  00065	72 0f		 jb	 SHORT $LN5@BlFatReadS
  00067	ba 17 01 00 00	 mov	 edx, 279		; 00000117H
  0006c	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  00071	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN5@BlFatReadS:

; 280  : 
; 281  :     while (NumberOfSectors > 0) {

  00076	83 7d f4 00	 cmp	 DWORD PTR _NumberOfSectors$[ebp], 0
  0007a	0f 86 88 00 00
	00		 jbe	 $LN4@BlFatReadS

; 282  : 
; 283  :         if (NumberOfSectors < BlFatTemporaryBlockCount) {

  00080	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?BlFatTemporaryBlockCount@@3GA ; BlFatTemporaryBlockCount
  00087	39 4d f4	 cmp	 DWORD PTR _NumberOfSectors$[ebp], ecx
  0008a	73 0a		 jae	 SHORT $LN3@BlFatReadS

; 284  : 
; 285  :             StepSize = (UINT16) NumberOfSectors;

  0008c	66 8b 55 f4	 mov	 dx, WORD PTR _NumberOfSectors$[ebp]
  00090	66 89 55 fc	 mov	 WORD PTR _StepSize$[ebp], dx

; 286  : 
; 287  :         } else {

  00094	eb 0a		 jmp	 SHORT $LN2@BlFatReadS
$LN3@BlFatReadS:

; 288  : 
; 289  :             StepSize = BlFatTemporaryBlockCount;

  00096	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ?BlFatTemporaryBlockCount@@3GA ; BlFatTemporaryBlockCount
  0009c	66 89 45 fc	 mov	 WORD PTR _StepSize$[ebp], ax
$LN2@BlFatReadS:

; 290  :         }
; 291  : 
; 292  :         if (BlRtlReadDrive(BlFatDriveId,
; 293  :                            BlFatPartitionStart + FirstSector,
; 294  :                            StepSize,
; 295  :                            BlFatTemporaryBlock) == FALSE) {

  000a0	68 00 00 00 00	 push	 OFFSET ?BlFatTemporaryBlock@@3PAU_FAT_SECTOR@@A ; BlFatTemporaryBlock
  000a5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlFatPartitionStart@@3KA ; BlFatPartitionStart
  000ab	03 4d f8	 add	 ecx, DWORD PTR _FirstSector$[ebp]
  000ae	33 d2		 xor	 edx, edx
  000b0	52		 push	 edx
  000b1	51		 push	 ecx
  000b2	8b 55 fc	 mov	 edx, DWORD PTR _StepSize$[ebp]
  000b5	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?BlFatDriveId@@3EA ; BlFatDriveId
  000bb	e8 00 00 00 00	 call	 ?BlRtlReadDrive@@YIEE_KGPAX@Z ; BlRtlReadDrive
  000c0	0f b6 c0	 movzx	 eax, al
  000c3	85 c0		 test	 eax, eax
  000c5	75 04		 jne	 SHORT $LN1@BlFatReadS

; 296  : 
; 297  : #if FAT_VERBOSE
; 298  : 
; 299  :             BlRtlPrintf("FAT: I/O error reading sector %u on drive 0x%02x!\n",
; 300  :                         BlFatPartitionStart + FirstSector,
; 301  :                         BlFatDriveId);
; 302  : 
; 303  : #endif
; 304  : 
; 305  :             return FALSE;

  000c7	32 c0		 xor	 al, al
  000c9	eb 3f		 jmp	 SHORT $LN10@BlFatReadS
$LN1@BlFatReadS:

; 306  :         }
; 307  : 
; 308  :         BlRtlCopyMemory(Buffer,
; 309  :                         BlFatTemporaryBlock,
; 310  :                         StepSize * FAT_SECTOR_SIZE);

  000cb	0f b7 4d fc	 movzx	 ecx, WORD PTR _StepSize$[ebp]
  000cf	c1 e1 09	 shl	 ecx, 9
  000d2	51		 push	 ecx
  000d3	ba 00 00 00 00	 mov	 edx, OFFSET ?BlFatTemporaryBlock@@3PAU_FAT_SECTOR@@A ; BlFatTemporaryBlock
  000d8	8b 4d 08	 mov	 ecx, DWORD PTR _Buffer$[ebp]
  000db	e8 00 00 00 00	 call	 ?BlRtlCopyMemory@@YIXPAXPBXK@Z ; BlRtlCopyMemory

; 311  : 
; 312  :         FirstSector += StepSize;

  000e0	0f b7 55 fc	 movzx	 edx, WORD PTR _StepSize$[ebp]
  000e4	03 55 f8	 add	 edx, DWORD PTR _FirstSector$[ebp]
  000e7	89 55 f8	 mov	 DWORD PTR _FirstSector$[ebp], edx

; 313  :         NumberOfSectors -= StepSize;

  000ea	0f b7 45 fc	 movzx	 eax, WORD PTR _StepSize$[ebp]
  000ee	8b 4d f4	 mov	 ecx, DWORD PTR _NumberOfSectors$[ebp]
  000f1	2b c8		 sub	 ecx, eax
  000f3	89 4d f4	 mov	 DWORD PTR _NumberOfSectors$[ebp], ecx

; 314  :         Buffer += StepSize;

  000f6	0f b7 55 fc	 movzx	 edx, WORD PTR _StepSize$[ebp]
  000fa	c1 e2 09	 shl	 edx, 9
  000fd	03 55 08	 add	 edx, DWORD PTR _Buffer$[ebp]
  00100	89 55 08	 mov	 DWORD PTR _Buffer$[ebp], edx

; 315  :     }

  00103	e9 6e ff ff ff	 jmp	 $LN5@BlFatReadS
$LN4@BlFatReadS:

; 316  : 
; 317  :     return TRUE;

  00108	b0 01		 mov	 al, 1
$LN10@BlFatReadS:

; 318  : }

  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c2 04 00	 ret	 4
?BlFatReadSector@@YIEKKPAU_FAT_SECTOR@@@Z ENDP		; BlFatReadSector
_TEXT	ENDS
PUBLIC	?BlFatDirectoryEntryToName@@YIEPAU_FAT_DIRECTORY_ENTRY@@PAU_FAT_NAME@@0@Z ; BlFatDirectoryEntryToName
; Function compile flags: /Odtp
;	COMDAT ?BlFatDirectoryEntryToName@@YIEPAU_FAT_DIRECTORY_ENTRY@@PAU_FAT_NAME@@0@Z
_TEXT	SEGMENT
_Name$ = -28						; size = 4
_ShortEntry$ = -24					; size = 4
_Entry$ = -20						; size = 4
_LongNameComponentIndex$ = -13				; size = 1
_SourceIndex$ = -12					; size = 4
_TargetIndex$ = -8					; size = 4
_Character$ = -1					; size = 1
_TableStart$ = 8					; size = 4
?BlFatDirectoryEntryToName@@YIEPAU_FAT_DIRECTORY_ENTRY@@PAU_FAT_NAME@@0@Z PROC ; BlFatDirectoryEntryToName, COMDAT
; _ShortEntry$ = ecx
; _Name$ = edx

; 348  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 55 e4	 mov	 DWORD PTR _Name$[ebp], edx
  00009	89 4d e8	 mov	 DWORD PTR _ShortEntry$[ebp], ecx

; 349  :     UINT8 Character;
; 350  :     PFAT_DIRECTORY_ENTRY Entry;
; 351  :     UINT8 LongNameComponentIndex;
; 352  :     UINT32 SourceIndex;
; 353  :     UINT32 TargetIndex;
; 354  : 
; 355  :     if ((ShortEntry->u1.Short.Attribute & FAT_ATTRIBUTE_MASK) == FAT_ATTRIBUTE_LONG_NAME) {

  0000c	8b 45 e8	 mov	 eax, DWORD PTR _ShortEntry$[ebp]
  0000f	0f b6 48 0b	 movzx	 ecx, BYTE PTR [eax+11]
  00013	83 e1 3f	 and	 ecx, 63			; 0000003fH
  00016	83 f9 0f	 cmp	 ecx, 15			; 0000000fH
  00019	75 07		 jne	 SHORT $LN47@BlFatDirec

; 356  : 
; 357  :         return FALSE;

  0001b	32 c0		 xor	 al, al
  0001d	e9 de 04 00 00	 jmp	 $LN48@BlFatDirec
$LN47@BlFatDirec:

; 358  :     }
; 359  : 
; 360  :     //
; 361  :     // Extract short name.
; 362  :     //
; 363  : 
; 364  :     TargetIndex = 0;

  00022	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _TargetIndex$[ebp], 0

; 365  : 
; 366  :     for (SourceIndex = 0; SourceIndex < 8; SourceIndex += 1) {

  00029	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _SourceIndex$[ebp], 0
  00030	eb 09		 jmp	 SHORT $LN46@BlFatDirec
$LN45@BlFatDirec:
  00032	8b 55 f4	 mov	 edx, DWORD PTR _SourceIndex$[ebp]
  00035	83 c2 01	 add	 edx, 1
  00038	89 55 f4	 mov	 DWORD PTR _SourceIndex$[ebp], edx
$LN46@BlFatDirec:
  0003b	83 7d f4 08	 cmp	 DWORD PTR _SourceIndex$[ebp], 8
  0003f	73 49		 jae	 SHORT $LN44@BlFatDirec

; 367  : 
; 368  :         Character = ShortEntry->u1.Short.Name[SourceIndex];

  00041	8b 45 e8	 mov	 eax, DWORD PTR _ShortEntry$[ebp]
  00044	03 45 f4	 add	 eax, DWORD PTR _SourceIndex$[ebp]
  00047	8a 08		 mov	 cl, BYTE PTR [eax]
  00049	88 4d ff	 mov	 BYTE PTR _Character$[ebp], cl

; 369  : 
; 370  :         if (Character == ' ') {

  0004c	0f b6 55 ff	 movzx	 edx, BYTE PTR _Character$[ebp]
  00050	83 fa 20	 cmp	 edx, 32			; 00000020H
  00053	75 0f		 jne	 SHORT $LN43@BlFatDirec

; 371  : 
; 372  :             if (SourceIndex == 0) {

  00055	83 7d f4 00	 cmp	 DWORD PTR _SourceIndex$[ebp], 0
  00059	75 07		 jne	 SHORT $LN42@BlFatDirec

; 373  : 
; 374  :                 return FALSE;

  0005b	32 c0		 xor	 al, al
  0005d	e9 9e 04 00 00	 jmp	 $LN48@BlFatDirec
$LN42@BlFatDirec:

; 375  :             }
; 376  : 
; 377  :             break;

  00062	eb 26		 jmp	 SHORT $LN44@BlFatDirec
$LN43@BlFatDirec:

; 378  :         }
; 379  : 
; 380  :         if (Character == '.') {

  00064	0f b6 45 ff	 movzx	 eax, BYTE PTR _Character$[ebp]
  00068	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0006b	75 07		 jne	 SHORT $LN41@BlFatDirec

; 381  : 
; 382  :             return FALSE;

  0006d	32 c0		 xor	 al, al
  0006f	e9 8c 04 00 00	 jmp	 $LN48@BlFatDirec
$LN41@BlFatDirec:

; 383  :         }
; 384  : 
; 385  :         Name->ShortName[TargetIndex] = Character;

  00074	8b 4d e4	 mov	 ecx, DWORD PTR _Name$[ebp]
  00077	03 4d f8	 add	 ecx, DWORD PTR _TargetIndex$[ebp]
  0007a	8a 55 ff	 mov	 dl, BYTE PTR _Character$[ebp]
  0007d	88 11		 mov	 BYTE PTR [ecx], dl

; 386  :         TargetIndex += 1;

  0007f	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  00082	83 c0 01	 add	 eax, 1
  00085	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax

; 387  :     }

  00088	eb a8		 jmp	 SHORT $LN45@BlFatDirec
$LN44@BlFatDirec:

; 388  : 
; 389  :     if (ShortEntry->u1.Short.Name[8] != ' ') {

  0008a	8b 4d e8	 mov	 ecx, DWORD PTR _ShortEntry$[ebp]
  0008d	0f b6 51 08	 movzx	 edx, BYTE PTR [ecx+8]
  00091	83 fa 20	 cmp	 edx, 32			; 00000020H
  00094	74 66		 je	 SHORT $LN40@BlFatDirec

; 390  : 
; 391  :         Name->ShortName[TargetIndex] = '.';

  00096	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  00099	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  0009c	c6 00 2e	 mov	 BYTE PTR [eax], 46	; 0000002eH

; 392  :         TargetIndex += 1;

  0009f	8b 4d f8	 mov	 ecx, DWORD PTR _TargetIndex$[ebp]
  000a2	83 c1 01	 add	 ecx, 1
  000a5	89 4d f8	 mov	 DWORD PTR _TargetIndex$[ebp], ecx

; 393  : 
; 394  :         for (SourceIndex = 8; SourceIndex < 11; SourceIndex += 1) {

  000a8	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR _SourceIndex$[ebp], 8
  000af	eb 09		 jmp	 SHORT $LN39@BlFatDirec
$LN38@BlFatDirec:
  000b1	8b 55 f4	 mov	 edx, DWORD PTR _SourceIndex$[ebp]
  000b4	83 c2 01	 add	 edx, 1
  000b7	89 55 f4	 mov	 DWORD PTR _SourceIndex$[ebp], edx
$LN39@BlFatDirec:
  000ba	83 7d f4 0b	 cmp	 DWORD PTR _SourceIndex$[ebp], 11 ; 0000000bH
  000be	73 3c		 jae	 SHORT $LN40@BlFatDirec

; 395  : 
; 396  :             Character = ShortEntry->u1.Short.Name[SourceIndex];

  000c0	8b 45 e8	 mov	 eax, DWORD PTR _ShortEntry$[ebp]
  000c3	03 45 f4	 add	 eax, DWORD PTR _SourceIndex$[ebp]
  000c6	8a 08		 mov	 cl, BYTE PTR [eax]
  000c8	88 4d ff	 mov	 BYTE PTR _Character$[ebp], cl

; 397  : 
; 398  :             if (Character == ' ') {

  000cb	0f b6 55 ff	 movzx	 edx, BYTE PTR _Character$[ebp]
  000cf	83 fa 20	 cmp	 edx, 32			; 00000020H
  000d2	75 02		 jne	 SHORT $LN36@BlFatDirec

; 399  : 
; 400  :                 break;

  000d4	eb 26		 jmp	 SHORT $LN40@BlFatDirec
$LN36@BlFatDirec:

; 401  :             }
; 402  : 
; 403  :             if (Character == '.') {

  000d6	0f b6 45 ff	 movzx	 eax, BYTE PTR _Character$[ebp]
  000da	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  000dd	75 07		 jne	 SHORT $LN35@BlFatDirec

; 404  : 
; 405  :                 return FALSE;

  000df	32 c0		 xor	 al, al
  000e1	e9 1a 04 00 00	 jmp	 $LN48@BlFatDirec
$LN35@BlFatDirec:

; 406  :             }
; 407  : 
; 408  :             Name->ShortName[TargetIndex] = Character;

  000e6	8b 4d e4	 mov	 ecx, DWORD PTR _Name$[ebp]
  000e9	03 4d f8	 add	 ecx, DWORD PTR _TargetIndex$[ebp]
  000ec	8a 55 ff	 mov	 dl, BYTE PTR _Character$[ebp]
  000ef	88 11		 mov	 BYTE PTR [ecx], dl

; 409  :             TargetIndex += 1;

  000f1	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  000f4	83 c0 01	 add	 eax, 1
  000f7	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax

; 410  :         }

  000fa	eb b5		 jmp	 SHORT $LN38@BlFatDirec
$LN40@BlFatDirec:

; 411  :     }
; 412  : 
; 413  :     Name->ShortName[TargetIndex] = 0;

  000fc	8b 4d e4	 mov	 ecx, DWORD PTR _Name$[ebp]
  000ff	03 4d f8	 add	 ecx, DWORD PTR _TargetIndex$[ebp]
  00102	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 414  : 
; 415  :     //
; 416  :     // If there is a long name, extract it by walking backwards from the short entry.
; 417  :     // Otherwise, set long name to empty string.
; 418  :     //
; 419  : 
; 420  :     Name->LongName[0] = 0;

  00105	8b 55 e4	 mov	 edx, DWORD PTR _Name$[ebp]
  00108	c6 42 0d 00	 mov	 BYTE PTR [edx+13], 0

; 421  : 
; 422  :     Entry = ShortEntry - 1;

  0010c	8b 45 e8	 mov	 eax, DWORD PTR _ShortEntry$[ebp]
  0010f	83 e8 20	 sub	 eax, 32			; 00000020H
  00112	89 45 ec	 mov	 DWORD PTR _Entry$[ebp], eax

; 423  : 
; 424  :     if (Entry < TableStart) {

  00115	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00118	3b 4d 08	 cmp	 ecx, DWORD PTR _TableStart$[ebp]
  0011b	73 07		 jae	 SHORT $LN34@BlFatDirec

; 425  : 
; 426  :         return TRUE;

  0011d	b0 01		 mov	 al, 1
  0011f	e9 dc 03 00 00	 jmp	 $LN48@BlFatDirec
$LN34@BlFatDirec:

; 427  :     }
; 428  : 
; 429  :     if ((Entry->u1.Short.Attribute & FAT_ATTRIBUTE_MASK) != FAT_ATTRIBUTE_LONG_NAME) {

  00124	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  00127	0f b6 42 0b	 movzx	 eax, BYTE PTR [edx+11]
  0012b	83 e0 3f	 and	 eax, 63			; 0000003fH
  0012e	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00131	74 07		 je	 SHORT $LN33@BlFatDirec

; 430  : 
; 431  :         return TRUE;

  00133	b0 01		 mov	 al, 1
  00135	e9 c6 03 00 00	 jmp	 $LN48@BlFatDirec
$LN33@BlFatDirec:

; 432  :     }
; 433  : 
; 434  :     LongNameComponentIndex = 1;

  0013a	c6 45 f3 01	 mov	 BYTE PTR _LongNameComponentIndex$[ebp], 1

; 435  :     TargetIndex = 0;

  0013e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _TargetIndex$[ebp], 0
$LN32@BlFatDirec:

; 436  : 
; 437  :     for (;;) {
; 438  : 
; 439  :         if (TargetIndex == FAT_MAX_PATH) {

  00145	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  0014c	75 07		 jne	 SHORT $LN30@BlFatDirec

; 440  : 
; 441  :             return FALSE;

  0014e	32 c0		 xor	 al, al
  00150	e9 ab 03 00 00	 jmp	 $LN48@BlFatDirec
$LN30@BlFatDirec:

; 442  :         }
; 443  : 
; 444  :         if (Entry < TableStart) {

  00155	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00158	3b 4d 08	 cmp	 ecx, DWORD PTR _TableStart$[ebp]
  0015b	73 07		 jae	 SHORT $LN29@BlFatDirec

; 445  : 
; 446  :             return FALSE;

  0015d	32 c0		 xor	 al, al
  0015f	e9 9c 03 00 00	 jmp	 $LN48@BlFatDirec
$LN29@BlFatDirec:

; 447  :         }
; 448  : 
; 449  :         if ((Entry->u1.Long.Order & FAT_LONG_NAME_ORDER_MASK) != LongNameComponentIndex) {

  00164	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  00167	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0016a	83 e0 3f	 and	 eax, 63			; 0000003fH
  0016d	0f b6 4d f3	 movzx	 ecx, BYTE PTR _LongNameComponentIndex$[ebp]
  00171	3b c1		 cmp	 eax, ecx
  00173	74 07		 je	 SHORT $LN28@BlFatDirec

; 450  : 
; 451  :             return FALSE;

  00175	32 c0		 xor	 al, al
  00177	e9 84 03 00 00	 jmp	 $LN48@BlFatDirec
$LN28@BlFatDirec:

; 452  :         }
; 453  : 
; 454  : #define ADD_CHARACTER(C)                                \
; 455  :                                                         \
; 456  :         if (TargetIndex == FAT_MAX_PATH) {              \
; 457  :                                                         \
; 458  :             return FALSE;                               \
; 459  :         }                                               \
; 460  :                                                         \
; 461  :         if (((C) != 0) && ((C) != 0xFFFF)) {            \
; 462  :                                                         \
; 463  :             Name->LongName[TargetIndex] = (UINT8) (C);  \
; 464  :             TargetIndex += 1;                           \
; 465  :         }
; 466  : 
; 467  :         ADD_CHARACTER(Entry->u1.Long.NameW1_5[0]);

  0017c	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  00183	75 07		 jne	 SHORT $LN27@BlFatDirec
  00185	32 c0		 xor	 al, al
  00187	e9 74 03 00 00	 jmp	 $LN48@BlFatDirec
$LN27@BlFatDirec:
  0018c	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  0018f	0f b7 42 01	 movzx	 eax, WORD PTR [edx+1]
  00193	85 c0		 test	 eax, eax
  00195	74 27		 je	 SHORT $LN26@BlFatDirec
  00197	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0019a	0f b7 51 01	 movzx	 edx, WORD PTR [ecx+1]
  0019e	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  001a4	74 18		 je	 SHORT $LN26@BlFatDirec
  001a6	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  001a9	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  001ac	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  001af	8a 51 01	 mov	 dl, BYTE PTR [ecx+1]
  001b2	88 50 0d	 mov	 BYTE PTR [eax+13], dl
  001b5	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  001b8	83 c0 01	 add	 eax, 1
  001bb	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax
$LN26@BlFatDirec:

; 468  :         ADD_CHARACTER(Entry->u1.Long.NameW1_5[1]);

  001be	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  001c5	75 07		 jne	 SHORT $LN25@BlFatDirec
  001c7	32 c0		 xor	 al, al
  001c9	e9 32 03 00 00	 jmp	 $LN48@BlFatDirec
$LN25@BlFatDirec:
  001ce	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  001d1	0f b7 51 03	 movzx	 edx, WORD PTR [ecx+3]
  001d5	85 d2		 test	 edx, edx
  001d7	74 27		 je	 SHORT $LN24@BlFatDirec
  001d9	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  001dc	0f b7 48 03	 movzx	 ecx, WORD PTR [eax+3]
  001e0	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  001e6	74 18		 je	 SHORT $LN24@BlFatDirec
  001e8	8b 55 e4	 mov	 edx, DWORD PTR _Name$[ebp]
  001eb	03 55 f8	 add	 edx, DWORD PTR _TargetIndex$[ebp]
  001ee	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  001f1	8a 48 03	 mov	 cl, BYTE PTR [eax+3]
  001f4	88 4a 0d	 mov	 BYTE PTR [edx+13], cl
  001f7	8b 55 f8	 mov	 edx, DWORD PTR _TargetIndex$[ebp]
  001fa	83 c2 01	 add	 edx, 1
  001fd	89 55 f8	 mov	 DWORD PTR _TargetIndex$[ebp], edx
$LN24@BlFatDirec:

; 469  :         ADD_CHARACTER(Entry->u1.Long.NameW1_5[2]);

  00200	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  00207	75 07		 jne	 SHORT $LN23@BlFatDirec
  00209	32 c0		 xor	 al, al
  0020b	e9 f0 02 00 00	 jmp	 $LN48@BlFatDirec
$LN23@BlFatDirec:
  00210	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00213	0f b7 48 05	 movzx	 ecx, WORD PTR [eax+5]
  00217	85 c9		 test	 ecx, ecx
  00219	74 26		 je	 SHORT $LN22@BlFatDirec
  0021b	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  0021e	0f b7 42 05	 movzx	 eax, WORD PTR [edx+5]
  00222	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00227	74 18		 je	 SHORT $LN22@BlFatDirec
  00229	8b 4d e4	 mov	 ecx, DWORD PTR _Name$[ebp]
  0022c	03 4d f8	 add	 ecx, DWORD PTR _TargetIndex$[ebp]
  0022f	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  00232	8a 42 05	 mov	 al, BYTE PTR [edx+5]
  00235	88 41 0d	 mov	 BYTE PTR [ecx+13], al
  00238	8b 4d f8	 mov	 ecx, DWORD PTR _TargetIndex$[ebp]
  0023b	83 c1 01	 add	 ecx, 1
  0023e	89 4d f8	 mov	 DWORD PTR _TargetIndex$[ebp], ecx
$LN22@BlFatDirec:

; 470  :         ADD_CHARACTER(Entry->u1.Long.NameW1_5[3]);

  00241	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  00248	75 07		 jne	 SHORT $LN21@BlFatDirec
  0024a	32 c0		 xor	 al, al
  0024c	e9 af 02 00 00	 jmp	 $LN48@BlFatDirec
$LN21@BlFatDirec:
  00251	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  00254	0f b7 42 07	 movzx	 eax, WORD PTR [edx+7]
  00258	85 c0		 test	 eax, eax
  0025a	74 27		 je	 SHORT $LN20@BlFatDirec
  0025c	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0025f	0f b7 51 07	 movzx	 edx, WORD PTR [ecx+7]
  00263	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  00269	74 18		 je	 SHORT $LN20@BlFatDirec
  0026b	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  0026e	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  00271	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00274	8a 51 07	 mov	 dl, BYTE PTR [ecx+7]
  00277	88 50 0d	 mov	 BYTE PTR [eax+13], dl
  0027a	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  0027d	83 c0 01	 add	 eax, 1
  00280	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax
$LN20@BlFatDirec:

; 471  :         ADD_CHARACTER(Entry->u1.Long.NameW1_5[4]);

  00283	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  0028a	75 07		 jne	 SHORT $LN19@BlFatDirec
  0028c	32 c0		 xor	 al, al
  0028e	e9 6d 02 00 00	 jmp	 $LN48@BlFatDirec
$LN19@BlFatDirec:
  00293	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00296	0f b7 51 09	 movzx	 edx, WORD PTR [ecx+9]
  0029a	85 d2		 test	 edx, edx
  0029c	74 27		 je	 SHORT $LN18@BlFatDirec
  0029e	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  002a1	0f b7 48 09	 movzx	 ecx, WORD PTR [eax+9]
  002a5	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  002ab	74 18		 je	 SHORT $LN18@BlFatDirec
  002ad	8b 55 e4	 mov	 edx, DWORD PTR _Name$[ebp]
  002b0	03 55 f8	 add	 edx, DWORD PTR _TargetIndex$[ebp]
  002b3	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  002b6	8a 48 09	 mov	 cl, BYTE PTR [eax+9]
  002b9	88 4a 0d	 mov	 BYTE PTR [edx+13], cl
  002bc	8b 55 f8	 mov	 edx, DWORD PTR _TargetIndex$[ebp]
  002bf	83 c2 01	 add	 edx, 1
  002c2	89 55 f8	 mov	 DWORD PTR _TargetIndex$[ebp], edx
$LN18@BlFatDirec:

; 472  :         ADD_CHARACTER(Entry->u1.Long.NameW6_11[0]);

  002c5	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  002cc	75 07		 jne	 SHORT $LN17@BlFatDirec
  002ce	32 c0		 xor	 al, al
  002d0	e9 2b 02 00 00	 jmp	 $LN48@BlFatDirec
$LN17@BlFatDirec:
  002d5	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  002d8	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  002dc	85 c9		 test	 ecx, ecx
  002de	74 26		 je	 SHORT $LN16@BlFatDirec
  002e0	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  002e3	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  002e7	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  002ec	74 18		 je	 SHORT $LN16@BlFatDirec
  002ee	8b 4d e4	 mov	 ecx, DWORD PTR _Name$[ebp]
  002f1	03 4d f8	 add	 ecx, DWORD PTR _TargetIndex$[ebp]
  002f4	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  002f7	8a 42 0e	 mov	 al, BYTE PTR [edx+14]
  002fa	88 41 0d	 mov	 BYTE PTR [ecx+13], al
  002fd	8b 4d f8	 mov	 ecx, DWORD PTR _TargetIndex$[ebp]
  00300	83 c1 01	 add	 ecx, 1
  00303	89 4d f8	 mov	 DWORD PTR _TargetIndex$[ebp], ecx
$LN16@BlFatDirec:

; 473  :         ADD_CHARACTER(Entry->u1.Long.NameW6_11[1]);

  00306	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  0030d	75 07		 jne	 SHORT $LN15@BlFatDirec
  0030f	32 c0		 xor	 al, al
  00311	e9 ea 01 00 00	 jmp	 $LN48@BlFatDirec
$LN15@BlFatDirec:
  00316	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  00319	0f b7 42 10	 movzx	 eax, WORD PTR [edx+16]
  0031d	85 c0		 test	 eax, eax
  0031f	74 27		 je	 SHORT $LN14@BlFatDirec
  00321	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00324	0f b7 51 10	 movzx	 edx, WORD PTR [ecx+16]
  00328	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  0032e	74 18		 je	 SHORT $LN14@BlFatDirec
  00330	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  00333	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  00336	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00339	8a 51 10	 mov	 dl, BYTE PTR [ecx+16]
  0033c	88 50 0d	 mov	 BYTE PTR [eax+13], dl
  0033f	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  00342	83 c0 01	 add	 eax, 1
  00345	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax
$LN14@BlFatDirec:

; 474  :         ADD_CHARACTER(Entry->u1.Long.NameW6_11[2]);

  00348	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  0034f	75 07		 jne	 SHORT $LN13@BlFatDirec
  00351	32 c0		 xor	 al, al
  00353	e9 a8 01 00 00	 jmp	 $LN48@BlFatDirec
$LN13@BlFatDirec:
  00358	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0035b	0f b7 51 12	 movzx	 edx, WORD PTR [ecx+18]
  0035f	85 d2		 test	 edx, edx
  00361	74 27		 je	 SHORT $LN12@BlFatDirec
  00363	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00366	0f b7 48 12	 movzx	 ecx, WORD PTR [eax+18]
  0036a	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  00370	74 18		 je	 SHORT $LN12@BlFatDirec
  00372	8b 55 e4	 mov	 edx, DWORD PTR _Name$[ebp]
  00375	03 55 f8	 add	 edx, DWORD PTR _TargetIndex$[ebp]
  00378	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  0037b	8a 48 12	 mov	 cl, BYTE PTR [eax+18]
  0037e	88 4a 0d	 mov	 BYTE PTR [edx+13], cl
  00381	8b 55 f8	 mov	 edx, DWORD PTR _TargetIndex$[ebp]
  00384	83 c2 01	 add	 edx, 1
  00387	89 55 f8	 mov	 DWORD PTR _TargetIndex$[ebp], edx
$LN12@BlFatDirec:

; 475  :         ADD_CHARACTER(Entry->u1.Long.NameW6_11[3]);

  0038a	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  00391	75 07		 jne	 SHORT $LN11@BlFatDirec
  00393	32 c0		 xor	 al, al
  00395	e9 66 01 00 00	 jmp	 $LN48@BlFatDirec
$LN11@BlFatDirec:
  0039a	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  0039d	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  003a1	85 c9		 test	 ecx, ecx
  003a3	74 26		 je	 SHORT $LN10@BlFatDirec
  003a5	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  003a8	0f b7 42 14	 movzx	 eax, WORD PTR [edx+20]
  003ac	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  003b1	74 18		 je	 SHORT $LN10@BlFatDirec
  003b3	8b 4d e4	 mov	 ecx, DWORD PTR _Name$[ebp]
  003b6	03 4d f8	 add	 ecx, DWORD PTR _TargetIndex$[ebp]
  003b9	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  003bc	8a 42 14	 mov	 al, BYTE PTR [edx+20]
  003bf	88 41 0d	 mov	 BYTE PTR [ecx+13], al
  003c2	8b 4d f8	 mov	 ecx, DWORD PTR _TargetIndex$[ebp]
  003c5	83 c1 01	 add	 ecx, 1
  003c8	89 4d f8	 mov	 DWORD PTR _TargetIndex$[ebp], ecx
$LN10@BlFatDirec:

; 476  :         ADD_CHARACTER(Entry->u1.Long.NameW6_11[4]);

  003cb	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  003d2	75 07		 jne	 SHORT $LN9@BlFatDirec
  003d4	32 c0		 xor	 al, al
  003d6	e9 25 01 00 00	 jmp	 $LN48@BlFatDirec
$LN9@BlFatDirec:
  003db	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  003de	0f b7 42 16	 movzx	 eax, WORD PTR [edx+22]
  003e2	85 c0		 test	 eax, eax
  003e4	74 27		 je	 SHORT $LN8@BlFatDirec
  003e6	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  003e9	0f b7 51 16	 movzx	 edx, WORD PTR [ecx+22]
  003ed	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  003f3	74 18		 je	 SHORT $LN8@BlFatDirec
  003f5	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  003f8	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  003fb	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  003fe	8a 51 16	 mov	 dl, BYTE PTR [ecx+22]
  00401	88 50 0d	 mov	 BYTE PTR [eax+13], dl
  00404	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  00407	83 c0 01	 add	 eax, 1
  0040a	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax
$LN8@BlFatDirec:

; 477  :         ADD_CHARACTER(Entry->u1.Long.NameW6_11[5]);

  0040d	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  00414	75 07		 jne	 SHORT $LN7@BlFatDirec
  00416	32 c0		 xor	 al, al
  00418	e9 e3 00 00 00	 jmp	 $LN48@BlFatDirec
$LN7@BlFatDirec:
  0041d	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00420	0f b7 51 18	 movzx	 edx, WORD PTR [ecx+24]
  00424	85 d2		 test	 edx, edx
  00426	74 27		 je	 SHORT $LN6@BlFatDirec
  00428	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  0042b	0f b7 48 18	 movzx	 ecx, WORD PTR [eax+24]
  0042f	81 f9 ff ff 00
	00		 cmp	 ecx, 65535		; 0000ffffH
  00435	74 18		 je	 SHORT $LN6@BlFatDirec
  00437	8b 55 e4	 mov	 edx, DWORD PTR _Name$[ebp]
  0043a	03 55 f8	 add	 edx, DWORD PTR _TargetIndex$[ebp]
  0043d	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00440	8a 48 18	 mov	 cl, BYTE PTR [eax+24]
  00443	88 4a 0d	 mov	 BYTE PTR [edx+13], cl
  00446	8b 55 f8	 mov	 edx, DWORD PTR _TargetIndex$[ebp]
  00449	83 c2 01	 add	 edx, 1
  0044c	89 55 f8	 mov	 DWORD PTR _TargetIndex$[ebp], edx
$LN6@BlFatDirec:

; 478  :         ADD_CHARACTER(Entry->u1.Long.NameW12_13[0]);

  0044f	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  00456	75 07		 jne	 SHORT $LN5@BlFatDirec
  00458	32 c0		 xor	 al, al
  0045a	e9 a1 00 00 00	 jmp	 $LN48@BlFatDirec
$LN5@BlFatDirec:
  0045f	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00462	0f b7 48 1c	 movzx	 ecx, WORD PTR [eax+28]
  00466	85 c9		 test	 ecx, ecx
  00468	74 26		 je	 SHORT $LN4@BlFatDirec
  0046a	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  0046d	0f b7 42 1c	 movzx	 eax, WORD PTR [edx+28]
  00471	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00476	74 18		 je	 SHORT $LN4@BlFatDirec
  00478	8b 4d e4	 mov	 ecx, DWORD PTR _Name$[ebp]
  0047b	03 4d f8	 add	 ecx, DWORD PTR _TargetIndex$[ebp]
  0047e	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  00481	8a 42 1c	 mov	 al, BYTE PTR [edx+28]
  00484	88 41 0d	 mov	 BYTE PTR [ecx+13], al
  00487	8b 4d f8	 mov	 ecx, DWORD PTR _TargetIndex$[ebp]
  0048a	83 c1 01	 add	 ecx, 1
  0048d	89 4d f8	 mov	 DWORD PTR _TargetIndex$[ebp], ecx
$LN4@BlFatDirec:

; 479  :         ADD_CHARACTER(Entry->u1.Long.NameW12_13[1]);

  00490	81 7d f8 ff 00
	00 00		 cmp	 DWORD PTR _TargetIndex$[ebp], 255 ; 000000ffH
  00497	75 04		 jne	 SHORT $LN3@BlFatDirec
  00499	32 c0		 xor	 al, al
  0049b	eb 63		 jmp	 SHORT $LN48@BlFatDirec
$LN3@BlFatDirec:
  0049d	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  004a0	0f b7 42 1e	 movzx	 eax, WORD PTR [edx+30]
  004a4	85 c0		 test	 eax, eax
  004a6	74 27		 je	 SHORT $LN2@BlFatDirec
  004a8	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  004ab	0f b7 51 1e	 movzx	 edx, WORD PTR [ecx+30]
  004af	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  004b5	74 18		 je	 SHORT $LN2@BlFatDirec
  004b7	8b 45 e4	 mov	 eax, DWORD PTR _Name$[ebp]
  004ba	03 45 f8	 add	 eax, DWORD PTR _TargetIndex$[ebp]
  004bd	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  004c0	8a 51 1e	 mov	 dl, BYTE PTR [ecx+30]
  004c3	88 50 0d	 mov	 BYTE PTR [eax+13], dl
  004c6	8b 45 f8	 mov	 eax, DWORD PTR _TargetIndex$[ebp]
  004c9	83 c0 01	 add	 eax, 1
  004cc	89 45 f8	 mov	 DWORD PTR _TargetIndex$[ebp], eax
$LN2@BlFatDirec:

; 480  : 
; 481  : #undef ADD_CHARACTER
; 482  : 
; 483  :         if ((Entry->u1.Long.Order & FAT_LONG_NAME_TERMINATOR)) {

  004cf	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  004d2	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  004d5	83 e2 40	 and	 edx, 64			; 00000040H
  004d8	74 02		 je	 SHORT $LN1@BlFatDirec

; 484  : 
; 485  :             break;

  004da	eb 18		 jmp	 SHORT $LN31@BlFatDirec
$LN1@BlFatDirec:

; 486  :         }
; 487  : 
; 488  :         Entry -= 1;

  004dc	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  004df	83 e8 20	 sub	 eax, 32			; 00000020H
  004e2	89 45 ec	 mov	 DWORD PTR _Entry$[ebp], eax

; 489  :         LongNameComponentIndex += 1;

  004e5	0f b6 4d f3	 movzx	 ecx, BYTE PTR _LongNameComponentIndex$[ebp]
  004e9	83 c1 01	 add	 ecx, 1
  004ec	88 4d f3	 mov	 BYTE PTR _LongNameComponentIndex$[ebp], cl

; 490  :     }

  004ef	e9 51 fc ff ff	 jmp	 $LN32@BlFatDirec
$LN31@BlFatDirec:

; 491  : 
; 492  :     Name->LongName[TargetIndex] = 0;

  004f4	8b 55 e4	 mov	 edx, DWORD PTR _Name$[ebp]
  004f7	03 55 f8	 add	 edx, DWORD PTR _TargetIndex$[ebp]
  004fa	c6 42 0d 00	 mov	 BYTE PTR [edx+13], 0

; 493  : 
; 494  :     return TRUE;

  004fe	b0 01		 mov	 al, 1
$LN48@BlFatDirec:

; 495  : }

  00500	8b e5		 mov	 esp, ebp
  00502	5d		 pop	 ebp
  00503	c2 04 00	 ret	 4
?BlFatDirectoryEntryToName@@YIEPAU_FAT_DIRECTORY_ENTRY@@PAU_FAT_NAME@@0@Z ENDP ; BlFatDirectoryEntryToName
_TEXT	ENDS
PUBLIC	?BlFatFindDirectoryTableEntry@@YIPAU_FAT_DIRECTORY_ENTRY@@PAU1@KPBD@Z ; BlFatFindDirectoryTableEntry
EXTRN	?BlRtlEqualStringI@@YIEPBD0@Z:PROC		; BlRtlEqualStringI
; Function compile flags: /Odtp
;	COMDAT ?BlFatFindDirectoryTableEntry@@YIPAU_FAT_DIRECTORY_ENTRY@@PAU1@KPBD@Z
_TEXT	SEGMENT
_NumberOfEntries$ = -292				; size = 4
_Table$ = -288						; size = 4
_Entry$ = -284						; size = 4
_EntryName$ = -280					; size = 269
_Limit$ = -4						; size = 4
_Name$ = 8						; size = 4
?BlFatFindDirectoryTableEntry@@YIPAU_FAT_DIRECTORY_ENTRY@@PAU1@KPBD@Z PROC ; BlFatFindDirectoryTableEntry, COMDAT
; _Table$ = ecx
; _NumberOfEntries$ = edx

; 525  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 24 01 00
	00		 sub	 esp, 292		; 00000124H
  00009	89 95 dc fe ff
	ff		 mov	 DWORD PTR _NumberOfEntries$[ebp], edx
  0000f	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _Table$[ebp], ecx

; 526  :     PFAT_DIRECTORY_ENTRY Entry;
; 527  :     FAT_NAME EntryName;
; 528  :     PFAT_DIRECTORY_ENTRY Limit;
; 529  : 
; 530  :     BLASSERT(Name[0] != 0);

  00015	8b 45 08	 mov	 eax, DWORD PTR _Name$[ebp]
  00018	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 0f		 jne	 SHORT $LN11@BlFatFindD
  0001f	ba 12 02 00 00	 mov	 edx, 530		; 00000212H
  00024	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  00029	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN11@BlFatFindD:

; 531  : 
; 532  :     Limit = Table + NumberOfEntries;

  0002e	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _NumberOfEntries$[ebp]
  00034	c1 e2 05	 shl	 edx, 5
  00037	03 95 e0 fe ff
	ff		 add	 edx, DWORD PTR _Table$[ebp]
  0003d	89 55 fc	 mov	 DWORD PTR _Limit$[ebp], edx

; 533  : 
; 534  :     for (Entry = Table; Entry != Limit; Entry += 1) {

  00040	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _Table$[ebp]
  00046	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _Entry$[ebp], eax
  0004c	eb 0f		 jmp	 SHORT $LN10@BlFatFindD
$LN9@BlFatFindD:
  0004e	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _Entry$[ebp]
  00054	83 c1 20	 add	 ecx, 32			; 00000020H
  00057	89 8d e4 fe ff
	ff		 mov	 DWORD PTR _Entry$[ebp], ecx
$LN10@BlFatFindD:
  0005d	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _Entry$[ebp]
  00063	3b 55 fc	 cmp	 edx, DWORD PTR _Limit$[ebp]
  00066	0f 84 9c 00 00
	00		 je	 $LN8@BlFatFindD

; 535  : 
; 536  :         if (Entry->u1.Short.Name[0] == FAT_DIRECTORY_ENTRY_FREE) {

  0006c	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _Entry$[ebp]
  00072	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00075	81 f9 e5 00 00
	00		 cmp	 ecx, 229		; 000000e5H
  0007b	75 02		 jne	 SHORT $LN7@BlFatFindD

; 537  : 
; 538  :             continue;

  0007d	eb cf		 jmp	 SHORT $LN9@BlFatFindD
$LN7@BlFatFindD:

; 539  :         }
; 540  : 
; 541  :         if (Entry->u1.Short.Name[0] == FAT_DIRECTORY_ENTRY_LAST) {

  0007f	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR _Entry$[ebp]
  00085	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00088	85 c0		 test	 eax, eax
  0008a	75 02		 jne	 SHORT $LN6@BlFatFindD

; 542  : 
; 543  :             break;

  0008c	eb 7a		 jmp	 SHORT $LN8@BlFatFindD
$LN6@BlFatFindD:

; 544  :         }
; 545  : 
; 546  :         if (Entry->u1.Short.Name[0] == '.') {

  0008e	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _Entry$[ebp]
  00094	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00097	83 fa 2e	 cmp	 edx, 46			; 0000002eH
  0009a	75 02		 jne	 SHORT $LN5@BlFatFindD

; 547  : 
; 548  :             continue;

  0009c	eb b0		 jmp	 SHORT $LN9@BlFatFindD
$LN5@BlFatFindD:

; 549  :         }
; 550  : 
; 551  :         if ((Entry->u1.Short.Attribute & FAT_ATTRIBUTE_MASK) == FAT_ATTRIBUTE_VOLUME_ID) {

  0009e	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _Entry$[ebp]
  000a4	0f b6 48 0b	 movzx	 ecx, BYTE PTR [eax+11]
  000a8	83 e1 3f	 and	 ecx, 63			; 0000003fH
  000ab	83 f9 08	 cmp	 ecx, 8
  000ae	75 02		 jne	 SHORT $LN4@BlFatFindD

; 552  : 
; 553  :             continue;

  000b0	eb 9c		 jmp	 SHORT $LN9@BlFatFindD
$LN4@BlFatFindD:

; 554  :         }
; 555  : 
; 556  :         if (BlFatDirectoryEntryToName(Entry,
; 557  :                                       &EntryName,
; 558  :                                       Table) != FALSE) {

  000b2	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR _Table$[ebp]
  000b8	52		 push	 edx
  000b9	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _EntryName$[ebp]
  000bf	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _Entry$[ebp]
  000c5	e8 00 00 00 00	 call	 ?BlFatDirectoryEntryToName@@YIEPAU_FAT_DIRECTORY_ENTRY@@PAU_FAT_NAME@@0@Z ; BlFatDirectoryEntryToName
  000ca	0f b6 c0	 movzx	 eax, al
  000cd	85 c0		 test	 eax, eax
  000cf	74 32		 je	 SHORT $LN3@BlFatFindD

; 559  : 
; 560  :             if ((BlRtlEqualStringI(Name, (PCSTR) EntryName.ShortName) != FALSE) ||
; 561  :                 (BlRtlEqualStringI(Name, (PCSTR) EntryName.LongName) != FALSE)) {

  000d1	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR _EntryName$[ebp]
  000d7	8b 4d 08	 mov	 ecx, DWORD PTR _Name$[ebp]
  000da	e8 00 00 00 00	 call	 ?BlRtlEqualStringI@@YIEPBD0@Z ; BlRtlEqualStringI
  000df	0f b6 c8	 movzx	 ecx, al
  000e2	85 c9		 test	 ecx, ecx
  000e4	75 15		 jne	 SHORT $LN1@BlFatFindD
  000e6	8d 95 f5 fe ff
	ff		 lea	 edx, DWORD PTR _EntryName$[ebp+13]
  000ec	8b 4d 08	 mov	 ecx, DWORD PTR _Name$[ebp]
  000ef	e8 00 00 00 00	 call	 ?BlRtlEqualStringI@@YIEPBD0@Z ; BlRtlEqualStringI
  000f4	0f b6 d0	 movzx	 edx, al
  000f7	85 d2		 test	 edx, edx
  000f9	74 08		 je	 SHORT $LN3@BlFatFindD
$LN1@BlFatFindD:

; 562  : 
; 563  :                 return Entry;

  000fb	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _Entry$[ebp]
  00101	eb 07		 jmp	 SHORT $LN12@BlFatFindD
$LN3@BlFatFindD:

; 564  :             }
; 565  :         }
; 566  :     }

  00103	e9 46 ff ff ff	 jmp	 $LN9@BlFatFindD
$LN8@BlFatFindD:

; 567  : 
; 568  :     return NULL;

  00108	33 c0		 xor	 eax, eax
$LN12@BlFatFindD:

; 569  : }

  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	c2 04 00	 ret	 4
?BlFatFindDirectoryTableEntry@@YIPAU_FAT_DIRECTORY_ENTRY@@PAU1@KPBD@Z ENDP ; BlFatFindDirectoryTableEntry
_TEXT	ENDS
PUBLIC	?BlFatGetLengthClusterChain@@YIEKPAK@Z		; BlFatGetLengthClusterChain
; Function compile flags: /Odtp
;	COMDAT ?BlFatGetLengthClusterChain@@YIEKPAK@Z
_TEXT	SEGMENT
tv67 = -12						; size = 4
_Length$ = -8						; size = 4
_Cluster$ = -4						; size = 4
?BlFatGetLengthClusterChain@@YIEKPAK@Z PROC		; BlFatGetLengthClusterChain, COMDAT
; _Cluster$ = ecx
; _Length$ = edx

; 596  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 55 f8	 mov	 DWORD PTR _Length$[ebp], edx
  00009	89 4d fc	 mov	 DWORD PTR _Cluster$[ebp], ecx

; 597  :     *Length = 0;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR _Length$[ebp]
  0000f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN5@BlFatGetLe:

; 598  : 
; 599  :     do {
; 600  : 
; 601  :         if (FAT_IS_DATA_CLUSTER(Cluster) == FALSE) {

  00015	83 7d fc 02	 cmp	 DWORD PTR _Cluster$[ebp], 2
  00019	72 17		 jb	 SHORT $LN8@BlFatGetLe
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _Cluster$[ebp]
  0001e	83 e9 02	 sub	 ecx, 2
  00021	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?BlFatNumberOfDataClusters@@3KA ; BlFatNumberOfDataClusters
  00027	73 09		 jae	 SHORT $LN8@BlFatGetLe
  00029	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00030	eb 07		 jmp	 SHORT $LN9@BlFatGetLe
$LN8@BlFatGetLe:
  00032	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN9@BlFatGetLe:
  00039	83 7d f4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0003d	75 04		 jne	 SHORT $LN2@BlFatGetLe

; 602  : 
; 603  :             return FALSE;

  0003f	32 c0		 xor	 al, al
  00041	eb 31		 jmp	 SHORT $LN6@BlFatGetLe
$LN2@BlFatGetLe:

; 604  :         }
; 605  : 
; 606  :         if (BlFatGetNextCluster(Cluster, &Cluster) == FALSE) {

  00043	8d 55 fc	 lea	 edx, DWORD PTR _Cluster$[ebp]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _Cluster$[ebp]
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR ?BlFatGetNextCluster@@3P6IEKPAK@ZA ; BlFatGetNextCluster
  0004f	0f b6 d0	 movzx	 edx, al
  00052	85 d2		 test	 edx, edx
  00054	75 04		 jne	 SHORT $LN1@BlFatGetLe

; 607  : 
; 608  :             return FALSE;

  00056	32 c0		 xor	 al, al
  00058	eb 1a		 jmp	 SHORT $LN6@BlFatGetLe
$LN1@BlFatGetLe:

; 609  :         }
; 610  : 
; 611  :         *Length += 1;

  0005a	8b 45 f8	 mov	 eax, DWORD PTR _Length$[ebp]
  0005d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005f	83 c1 01	 add	 ecx, 1
  00062	8b 55 f8	 mov	 edx, DWORD PTR _Length$[ebp]
  00065	89 0a		 mov	 DWORD PTR [edx], ecx

; 612  : 
; 613  :     } while (Cluster != BlFatLinkTerminator);

  00067	8b 45 fc	 mov	 eax, DWORD PTR _Cluster$[ebp]
  0006a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatLinkTerminator@@3KA ; BlFatLinkTerminator
  00070	75 a3		 jne	 SHORT $LN5@BlFatGetLe

; 614  : 
; 615  :     return TRUE;

  00072	b0 01		 mov	 al, 1
$LN6@BlFatGetLe:

; 616  : }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
?BlFatGetLengthClusterChain@@YIEKPAK@Z ENDP		; BlFatGetLengthClusterChain
_TEXT	ENDS
PUBLIC	?BlFatReadClusterChain@@YIEKKPAX@Z		; BlFatReadClusterChain
EXTRN	?BlPoolFreeBlock@@YIXPAX@Z:PROC			; BlPoolFreeBlock
EXTRN	?BlPoolAllocateBlock@@YIPAXK@Z:PROC		; BlPoolAllocateBlock
; Function compile flags: /Odtp
;	COMDAT ?BlFatReadClusterChain@@YIEKKPAX@Z
_TEXT	SEGMENT
tv78 = -28						; size = 4
tv67 = -24						; size = 4
_BytesToRead$ = -20					; size = 4
_Cluster$ = -16						; size = 4
_Next$ = -12						; size = 4
_Sector$ = -8						; size = 4
_ClusterData$ = -4					; size = 4
_Buffer$ = 8						; size = 4
?BlFatReadClusterChain@@YIEKKPAX@Z PROC			; BlFatReadClusterChain, COMDAT
; _Cluster$ = ecx
; _BytesToRead$ = edx

; 646  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 55 ec	 mov	 DWORD PTR _BytesToRead$[ebp], edx
  00009	89 4d f0	 mov	 DWORD PTR _Cluster$[ebp], ecx

; 647  :     PVOID ClusterData;
; 648  :     PUINT8 Next;
; 649  :     UINT32 Sector;
; 650  : 
; 651  :     BLASSERT_PTR(FAT_IS_DATA_CLUSTER(Cluster) != FALSE, Cluster);

  0000c	83 7d f0 02	 cmp	 DWORD PTR _Cluster$[ebp], 2
  00010	72 17		 jb	 SHORT $LN13@BlFatReadC
  00012	8b 45 f0	 mov	 eax, DWORD PTR _Cluster$[ebp]
  00015	83 e8 02	 sub	 eax, 2
  00018	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatNumberOfDataClusters@@3KA ; BlFatNumberOfDataClusters
  0001e	73 09		 jae	 SHORT $LN13@BlFatReadC
  00020	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00027	eb 07		 jmp	 SHORT $LN14@BlFatReadC
$LN13@BlFatReadC:
  00029	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN14@BlFatReadC:
  00030	83 7d e8 00	 cmp	 DWORD PTR tv67[ebp], 0
  00034	75 13		 jne	 SHORT $LN10@BlFatReadC
  00036	8b 4d f0	 mov	 ecx, DWORD PTR _Cluster$[ebp]
  00039	51		 push	 ecx
  0003a	ba 8b 02 00 00	 mov	 edx, 651		; 0000028bH
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  00044	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN10@BlFatReadC:

; 652  : 
; 653  :     BLASSERT(BytesToRead > 0);

  00049	83 7d ec 00	 cmp	 DWORD PTR _BytesToRead$[ebp], 0
  0004d	77 0f		 ja	 SHORT $LN9@BlFatReadC
  0004f	ba 8d 02 00 00	 mov	 edx, 653		; 0000028dH
  00054	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  00059	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN9@BlFatReadC:

; 654  : 
; 655  :     Next = (PUINT8) Buffer;

  0005e	8b 55 08	 mov	 edx, DWORD PTR _Buffer$[ebp]
  00061	89 55 f4	 mov	 DWORD PTR _Next$[ebp], edx
$LN8@BlFatReadC:

; 656  : 
; 657  :     for (;;) {
; 658  : 
; 659  :         //
; 660  :         // If the cluster number is not within the valid data range, then fail the read operation.
; 661  :         //
; 662  : 
; 663  :         if (FAT_IS_DATA_CLUSTER(Cluster) == FALSE) {

  00064	83 7d f0 02	 cmp	 DWORD PTR _Cluster$[ebp], 2
  00068	72 17		 jb	 SHORT $LN15@BlFatReadC
  0006a	8b 45 f0	 mov	 eax, DWORD PTR _Cluster$[ebp]
  0006d	83 e8 02	 sub	 eax, 2
  00070	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatNumberOfDataClusters@@3KA ; BlFatNumberOfDataClusters
  00076	73 09		 jae	 SHORT $LN15@BlFatReadC
  00078	c7 45 e4 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  0007f	eb 07		 jmp	 SHORT $LN16@BlFatReadC
$LN15@BlFatReadC:
  00081	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN16@BlFatReadC:
  00088	83 7d e4 00	 cmp	 DWORD PTR tv78[ebp], 0
  0008c	75 07		 jne	 SHORT $LN6@BlFatReadC

; 664  : 
; 665  : #if FAT_VERBOSE
; 666  : 
; 667  :             BlRtlPrintf("FAT: ReadClusterChain: Cluster %u is out of range!\n", Cluster);
; 668  : 
; 669  : #endif
; 670  : 
; 671  :             return FALSE;

  0008e	32 c0		 xor	 al, al
  00090	e9 d6 00 00 00	 jmp	 $LN11@BlFatReadC
$LN6@BlFatReadC:

; 672  :         }
; 673  : 
; 674  :         //
; 675  :         // Calculate the first sector in the cluster.
; 676  :         //
; 677  : 
; 678  :         Sector = FAT_DATA_CLUSTER_TO_SECTOR(Cluster);

  00095	8b 4d f0	 mov	 ecx, DWORD PTR _Cluster$[ebp]
  00098	83 e9 02	 sub	 ecx, 2
  0009b	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR ?BlFatSectorsPerCluster@@3KA ; BlFatSectorsPerCluster
  000a2	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?BlFatDataStart@@3KA ; BlFatDataStart
  000a8	89 4d f8	 mov	 DWORD PTR _Sector$[ebp], ecx

; 679  : 
; 680  :         //
; 681  :         // If remaining bytes to read is less than the cluster size, then read it using a
; 682  :         // temporary buffer, since the caller provided buffer is not necessarily a multiple
; 683  :         // of cluster size.
; 684  :         //
; 685  : 
; 686  :         if (BytesToRead < BlFatBytesPerCluster) {

  000ab	8b 55 ec	 mov	 edx, DWORD PTR _BytesToRead$[ebp]
  000ae	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  000b4	73 5a		 jae	 SHORT $LN5@BlFatReadC

; 687  : 
; 688  :             ClusterData = BlPoolAllocateBlock(BlFatBytesPerCluster);

  000b6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  000bc	e8 00 00 00 00	 call	 ?BlPoolAllocateBlock@@YIPAXK@Z ; BlPoolAllocateBlock
  000c1	89 45 fc	 mov	 DWORD PTR _ClusterData$[ebp], eax

; 689  : 
; 690  :             if (BlFatReadSector(Sector,
; 691  :                                 ROUND_UP_TO_POWER2(BytesToRead, FAT_SECTOR_SIZE) / FAT_SECTOR_SIZE,
; 692  :                                 (PFAT_SECTOR) ClusterData) == FALSE) {

  000c4	8b 45 fc	 mov	 eax, DWORD PTR _ClusterData$[ebp]
  000c7	50		 push	 eax
  000c8	8b 55 ec	 mov	 edx, DWORD PTR _BytesToRead$[ebp]
  000cb	81 c2 ff 01 00
	00		 add	 edx, 511		; 000001ffH
  000d1	81 e2 00 fe ff
	ff		 and	 edx, -512		; fffffe00H
  000d7	c1 ea 09	 shr	 edx, 9
  000da	8b 4d f8	 mov	 ecx, DWORD PTR _Sector$[ebp]
  000dd	e8 00 00 00 00	 call	 ?BlFatReadSector@@YIEKKPAU_FAT_SECTOR@@@Z ; BlFatReadSector
  000e2	0f b6 c8	 movzx	 ecx, al
  000e5	85 c9		 test	 ecx, ecx
  000e7	75 0c		 jne	 SHORT $LN4@BlFatReadC

; 693  : 
; 694  :                 BlPoolFreeBlock(ClusterData);

  000e9	8b 4d fc	 mov	 ecx, DWORD PTR _ClusterData$[ebp]
  000ec	e8 00 00 00 00	 call	 ?BlPoolFreeBlock@@YIXPAX@Z ; BlPoolFreeBlock

; 695  : 
; 696  :                 return FALSE;

  000f1	32 c0		 xor	 al, al
  000f3	eb 76		 jmp	 SHORT $LN11@BlFatReadC
$LN4@BlFatReadC:

; 697  :             }
; 698  : 
; 699  :             BlRtlCopyMemory(Next,
; 700  :                             ClusterData,
; 701  :                             BytesToRead);

  000f5	8b 55 ec	 mov	 edx, DWORD PTR _BytesToRead$[ebp]
  000f8	52		 push	 edx
  000f9	8b 55 fc	 mov	 edx, DWORD PTR _ClusterData$[ebp]
  000fc	8b 4d f4	 mov	 ecx, DWORD PTR _Next$[ebp]
  000ff	e8 00 00 00 00	 call	 ?BlRtlCopyMemory@@YIXPAXPBXK@Z ; BlRtlCopyMemory

; 702  : 
; 703  :             BlPoolFreeBlock(ClusterData);

  00104	8b 4d fc	 mov	 ecx, DWORD PTR _ClusterData$[ebp]
  00107	e8 00 00 00 00	 call	 ?BlPoolFreeBlock@@YIXPAX@Z ; BlPoolFreeBlock

; 704  : 
; 705  :             return TRUE;

  0010c	b0 01		 mov	 al, 1
  0010e	eb 5b		 jmp	 SHORT $LN11@BlFatReadC
$LN5@BlFatReadC:

; 706  :         }
; 707  : 
; 708  :         //
; 709  :         // Otherwise, read the entire cluster and advance by full cluster size.
; 710  :         //
; 711  : 
; 712  :         if (BlFatReadSector(Sector,
; 713  :                             BlFatSectorsPerCluster,
; 714  :                             (PFAT_SECTOR) Next) == FALSE) {

  00110	8b 45 f4	 mov	 eax, DWORD PTR _Next$[ebp]
  00113	50		 push	 eax
  00114	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?BlFatSectorsPerCluster@@3KA ; BlFatSectorsPerCluster
  0011a	8b 4d f8	 mov	 ecx, DWORD PTR _Sector$[ebp]
  0011d	e8 00 00 00 00	 call	 ?BlFatReadSector@@YIEKKPAU_FAT_SECTOR@@@Z ; BlFatReadSector
  00122	0f b6 c8	 movzx	 ecx, al
  00125	85 c9		 test	 ecx, ecx
  00127	75 04		 jne	 SHORT $LN3@BlFatReadC

; 715  : 
; 716  :             return FALSE;

  00129	32 c0		 xor	 al, al
  0012b	eb 3e		 jmp	 SHORT $LN11@BlFatReadC
$LN3@BlFatReadC:

; 717  :         }
; 718  : 
; 719  :         BytesToRead -= BlFatBytesPerCluster;

  0012d	8b 55 ec	 mov	 edx, DWORD PTR _BytesToRead$[ebp]
  00130	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  00136	89 55 ec	 mov	 DWORD PTR _BytesToRead$[ebp], edx

; 720  :         Next += BlFatBytesPerCluster;

  00139	8b 45 f4	 mov	 eax, DWORD PTR _Next$[ebp]
  0013c	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  00142	89 45 f4	 mov	 DWORD PTR _Next$[ebp], eax

; 721  : 
; 722  :         if (BytesToRead == 0) {

  00145	83 7d ec 00	 cmp	 DWORD PTR _BytesToRead$[ebp], 0
  00149	75 04		 jne	 SHORT $LN2@BlFatReadC

; 723  : 
; 724  :             return TRUE;

  0014b	b0 01		 mov	 al, 1
  0014d	eb 1c		 jmp	 SHORT $LN11@BlFatReadC
$LN2@BlFatReadC:

; 725  :         }
; 726  : 
; 727  :         //
; 728  :         // Get the next cluster index.
; 729  :         //
; 730  : 
; 731  :         if (BlFatGetNextCluster(Cluster, &Cluster) == FALSE) {

  0014f	8d 55 f0	 lea	 edx, DWORD PTR _Cluster$[ebp]
  00152	8b 4d f0	 mov	 ecx, DWORD PTR _Cluster$[ebp]
  00155	ff 15 00 00 00
	00		 call	 DWORD PTR ?BlFatGetNextCluster@@3P6IEKPAK@ZA ; BlFatGetNextCluster
  0015b	0f b6 c8	 movzx	 ecx, al
  0015e	85 c9		 test	 ecx, ecx
  00160	75 04		 jne	 SHORT $LN1@BlFatReadC

; 732  : 
; 733  :             return FALSE;

  00162	32 c0		 xor	 al, al
  00164	eb 05		 jmp	 SHORT $LN11@BlFatReadC
$LN1@BlFatReadC:

; 734  :         }
; 735  :     }

  00166	e9 f9 fe ff ff	 jmp	 $LN8@BlFatReadC
$LN11@BlFatReadC:

; 736  : }

  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c2 04 00	 ret	 4
?BlFatReadClusterChain@@YIEKKPAX@Z ENDP			; BlFatReadClusterChain
_TEXT	ENDS
PUBLIC	?BlFatFindFileEntry@@YIEPBDPAU_FAT_DIRECTORY_ENTRY@@@Z ; BlFatFindFileEntry
EXTRN	?BlRtlZeroMemory@@YIXPAXK@Z:PROC		; BlRtlZeroMemory
EXTRN	?BlRtlStringLength@@YIKPBD@Z:PROC		; BlRtlStringLength
; Function compile flags: /Odtp
;	COMDAT ?BlFatFindFileEntry@@YIEPBDPAU_FAT_DIRECTORY_ENTRY@@@Z
_TEXT	SEGMENT
_FileEntry$ = -332					; size = 4
_Path$ = -328						; size = 4
_TableSize$ = -324					; size = 4
_Token$ = -320						; size = 255
_Match$ = -60						; size = 4
_Next$ = -56						; size = 4
_Depth$ = -52						; size = 4
_Table$ = -48						; size = 4
_Entry$ = -44						; size = 32
_TokenIndex$ = -12					; size = 4
_DirectoryCluster$ = -8					; size = 4
_DirectoryClusterCount$ = -4				; size = 4
?BlFatFindFileEntry@@YIEPBDPAU_FAT_DIRECTORY_ENTRY@@@Z PROC ; BlFatFindFileEntry, COMDAT
; _Path$ = ecx
; _FileEntry$ = edx

; 763  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 4c 01 00
	00		 sub	 esp, 332		; 0000014cH
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	89 95 b4 fe ff
	ff		 mov	 DWORD PTR _FileEntry$[ebp], edx
  00011	89 8d b8 fe ff
	ff		 mov	 DWORD PTR _Path$[ebp], ecx

; 764  :     UINT32 DirectoryCluster;
; 765  :     UINT32 DirectoryClusterCount;
; 766  :     UINT32 Depth;
; 767  :     FAT_DIRECTORY_ENTRY Entry;
; 768  :     PFAT_DIRECTORY_ENTRY Match;
; 769  :     PCSTR Next;
; 770  :     PFAT_DIRECTORY_ENTRY Table;
; 771  :     UINT32 TableSize;
; 772  :     UINT8 Token[FAT_MAX_PATH];
; 773  :     UINT32 TokenIndex;
; 774  : 
; 775  :     if ((Path[0] == 0) ||
; 776  :         (Path[0] == '/') ||
; 777  :         (BlRtlStringLength(Path) >= FAT_MAX_PATH)) {

  00017	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _Path$[ebp]
  0001d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00020	85 c9		 test	 ecx, ecx
  00022	74 20		 je	 SHORT $LN18@BlFatFindF
  00024	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR _Path$[ebp]
  0002a	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0002d	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00030	74 12		 je	 SHORT $LN18@BlFatFindF
  00032	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _Path$[ebp]
  00038	e8 00 00 00 00	 call	 ?BlRtlStringLength@@YIKPBD@Z ; BlRtlStringLength
  0003d	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00042	72 07		 jb	 SHORT $LN19@BlFatFindF
$LN18@BlFatFindF:

; 778  : 
; 779  :         return FALSE;

  00044	32 c0		 xor	 al, al
  00046	e9 b9 01 00 00	 jmp	 $LN20@BlFatFindF
$LN19@BlFatFindF:

; 780  :     }
; 781  : 
; 782  :     Next = Path;

  0004b	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _Path$[ebp]
  00051	89 4d c8	 mov	 DWORD PTR _Next$[ebp], ecx

; 783  :     Depth = 0;

  00054	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _Depth$[ebp], 0

; 784  : 
; 785  :     SATISFY_OVERZEALOUS_COMPILER(BlRtlZeroMemory(&Entry, sizeof(Entry)));

  0005b	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00060	8d 4d d4	 lea	 ecx, DWORD PTR _Entry$[ebp]
  00063	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory
$LN17@BlFatFindF:

; 786  : 
; 787  :     for (;;) {
; 788  : 
; 789  :         if (*Next == 0) {

  00068	8b 55 c8	 mov	 edx, DWORD PTR _Next$[ebp]
  0006b	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0006e	85 c0		 test	 eax, eax
  00070	75 27		 jne	 SHORT $LN15@BlFatFindF

; 790  : 
; 791  :             if ((Entry.u1.Short.Attribute & FAT_ATTRIBUTE_DIRECTORY) != 0) {

  00072	0f b6 4d df	 movzx	 ecx, BYTE PTR _Entry$[ebp+11]
  00076	83 e1 10	 and	 ecx, 16			; 00000010H
  00079	74 07		 je	 SHORT $LN14@BlFatFindF

; 792  : 
; 793  : #if FAT_VERBOSE
; 794  : 
; 795  :                 BlRtlPrintf("FAT: FindFileEntry: %s is a directory!\n", Path);
; 796  : 
; 797  : #endif
; 798  : 
; 799  :                 return FALSE;

  0007b	32 c0		 xor	 al, al
  0007d	e9 82 01 00 00	 jmp	 $LN20@BlFatFindF
$LN14@BlFatFindF:

; 800  :             }
; 801  : 
; 802  :             *FileEntry = Entry;

  00082	b9 08 00 00 00	 mov	 ecx, 8
  00087	8d 75 d4	 lea	 esi, DWORD PTR _Entry$[ebp]
  0008a	8b bd b4 fe ff
	ff		 mov	 edi, DWORD PTR _FileEntry$[ebp]
  00090	f3 a5		 rep movsd

; 803  : 
; 804  :             return TRUE;

  00092	b0 01		 mov	 al, 1
  00094	e9 6b 01 00 00	 jmp	 $LN20@BlFatFindF
$LN15@BlFatFindF:

; 805  :         }
; 806  : 
; 807  :         //
; 808  :         // If the next token is empty (i.e. back to back separators), then this is a malformed path.
; 809  :         //
; 810  : 
; 811  :         if (*Next == '/') {

  00099	8b 55 c8	 mov	 edx, DWORD PTR _Next$[ebp]
  0009c	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0009f	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  000a2	75 07		 jne	 SHORT $LN13@BlFatFindF

; 812  : 
; 813  : #if FAT_VERBOSE
; 814  : 
; 815  :             BlRtlPrintf("FAT: FindFileEntry: %s is a malformed path!\n", Path);
; 816  : 
; 817  : #endif
; 818  : 
; 819  :             return FALSE;

  000a4	32 c0		 xor	 al, al
  000a6	e9 59 01 00 00	 jmp	 $LN20@BlFatFindF
$LN13@BlFatFindF:

; 820  :         }
; 821  : 
; 822  :         //
; 823  :         // Extract the next token.
; 824  :         //
; 825  : 
; 826  :         TokenIndex = 0;

  000ab	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _TokenIndex$[ebp], 0
$LN12@BlFatFindF:

; 827  : 
; 828  :         for (;;) {
; 829  : 
; 830  :             if (*Next == 0) {

  000b2	8b 4d c8	 mov	 ecx, DWORD PTR _Next$[ebp]
  000b5	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000b8	85 d2		 test	 edx, edx
  000ba	75 02		 jne	 SHORT $LN10@BlFatFindF

; 831  : 
; 832  :                 break;

  000bc	eb 39		 jmp	 SHORT $LN11@BlFatFindF
$LN10@BlFatFindF:

; 833  :             }
; 834  : 
; 835  :             if (*Next == '/') {

  000be	8b 45 c8	 mov	 eax, DWORD PTR _Next$[ebp]
  000c1	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000c4	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  000c7	75 0b		 jne	 SHORT $LN9@BlFatFindF

; 836  : 
; 837  :                 Next += 1;

  000c9	8b 55 c8	 mov	 edx, DWORD PTR _Next$[ebp]
  000cc	83 c2 01	 add	 edx, 1
  000cf	89 55 c8	 mov	 DWORD PTR _Next$[ebp], edx

; 838  : 
; 839  :                 break;

  000d2	eb 23		 jmp	 SHORT $LN11@BlFatFindF
$LN9@BlFatFindF:

; 840  :             }
; 841  : 
; 842  :             Token[TokenIndex] = *Next;

  000d4	8b 45 f4	 mov	 eax, DWORD PTR _TokenIndex$[ebp]
  000d7	8b 4d c8	 mov	 ecx, DWORD PTR _Next$[ebp]
  000da	8a 11		 mov	 dl, BYTE PTR [ecx]
  000dc	88 94 05 c0 fe
	ff ff		 mov	 BYTE PTR _Token$[ebp+eax], dl

; 843  :             TokenIndex += 1;

  000e3	8b 45 f4	 mov	 eax, DWORD PTR _TokenIndex$[ebp]
  000e6	83 c0 01	 add	 eax, 1
  000e9	89 45 f4	 mov	 DWORD PTR _TokenIndex$[ebp], eax

; 844  :             Next += 1;

  000ec	8b 4d c8	 mov	 ecx, DWORD PTR _Next$[ebp]
  000ef	83 c1 01	 add	 ecx, 1
  000f2	89 4d c8	 mov	 DWORD PTR _Next$[ebp], ecx

; 845  :         }

  000f5	eb bb		 jmp	 SHORT $LN12@BlFatFindF
$LN11@BlFatFindF:

; 846  : 
; 847  :         BLASSERT(TokenIndex > 0);

  000f7	83 7d f4 00	 cmp	 DWORD PTR _TokenIndex$[ebp], 0
  000fb	77 0f		 ja	 SHORT $LN8@BlFatFindF
  000fd	ba 4f 03 00 00	 mov	 edx, 847		; 0000034fH
  00102	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  00107	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN8@BlFatFindF:

; 848  : 
; 849  :         Token[TokenIndex] = 0;

  0010c	8b 55 f4	 mov	 edx, DWORD PTR _TokenIndex$[ebp]
  0010f	c6 84 15 c0 fe
	ff ff 00	 mov	 BYTE PTR _Token$[ebp+edx], 0

; 850  : 
; 851  :         if (Depth == 0) {

  00117	83 7d cc 00	 cmp	 DWORD PTR _Depth$[ebp], 0
  0011b	75 16		 jne	 SHORT $LN7@BlFatFindF

; 852  : 
; 853  :             Table = BlFatRootDirectory;

  0011d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatRootDirectory@@3PAU_FAT_DIRECTORY_ENTRY@@A ; BlFatRootDirectory
  00122	89 45 d0	 mov	 DWORD PTR _Table$[ebp], eax

; 854  :             TableSize = BlFatNumberOfRootDirectoryEntries;

  00125	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlFatNumberOfRootDirectoryEntries@@3KA ; BlFatNumberOfRootDirectoryEntries
  0012b	89 8d bc fe ff
	ff		 mov	 DWORD PTR _TableSize$[ebp], ecx

; 855  : 
; 856  :         } else {

  00131	eb 6e		 jmp	 SHORT $LN6@BlFatFindF
$LN7@BlFatFindF:

; 857  : 
; 858  :             DirectoryCluster = Entry.u1.Short.FirstClusterLow;

  00133	0f b7 55 ee	 movzx	 edx, WORD PTR _Entry$[ebp+26]
  00137	89 55 f8	 mov	 DWORD PTR _DirectoryCluster$[ebp], edx

; 859  : 
; 860  :             if (BlFatGetLengthClusterChain(DirectoryCluster, &DirectoryClusterCount) == FALSE) {

  0013a	8d 55 fc	 lea	 edx, DWORD PTR _DirectoryClusterCount$[ebp]
  0013d	8b 4d f8	 mov	 ecx, DWORD PTR _DirectoryCluster$[ebp]
  00140	e8 00 00 00 00	 call	 ?BlFatGetLengthClusterChain@@YIEKPAK@Z ; BlFatGetLengthClusterChain
  00145	0f b6 c0	 movzx	 eax, al
  00148	85 c0		 test	 eax, eax
  0014a	75 07		 jne	 SHORT $LN5@BlFatFindF

; 861  : 
; 862  :                 return FALSE;

  0014c	32 c0		 xor	 al, al
  0014e	e9 b1 00 00 00	 jmp	 $LN20@BlFatFindF
$LN5@BlFatFindF:

; 863  :             }
; 864  : 
; 865  :             Table = (PFAT_DIRECTORY_ENTRY)
; 866  :                 BlPoolAllocateBlock(DirectoryClusterCount * BlFatBytesPerCluster);

  00153	8b 4d fc	 mov	 ecx, DWORD PTR _DirectoryClusterCount$[ebp]
  00156	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  0015d	e8 00 00 00 00	 call	 ?BlPoolAllocateBlock@@YIPAXK@Z ; BlPoolAllocateBlock
  00162	89 45 d0	 mov	 DWORD PTR _Table$[ebp], eax

; 867  : 
; 868  :             if (BlFatReadClusterChain(DirectoryCluster,
; 869  :                                       DirectoryClusterCount * BlFatBytesPerCluster,
; 870  :                                       Table) == FALSE) {

  00165	8b 4d d0	 mov	 ecx, DWORD PTR _Table$[ebp]
  00168	51		 push	 ecx
  00169	8b 55 fc	 mov	 edx, DWORD PTR _DirectoryClusterCount$[ebp]
  0016c	0f af 15 00 00
	00 00		 imul	 edx, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  00173	8b 4d f8	 mov	 ecx, DWORD PTR _DirectoryCluster$[ebp]
  00176	e8 00 00 00 00	 call	 ?BlFatReadClusterChain@@YIEKKPAX@Z ; BlFatReadClusterChain
  0017b	0f b6 d0	 movzx	 edx, al
  0017e	85 d2		 test	 edx, edx
  00180	75 0c		 jne	 SHORT $LN4@BlFatFindF

; 871  : 
; 872  :                 BlPoolFreeBlock(Table);

  00182	8b 4d d0	 mov	 ecx, DWORD PTR _Table$[ebp]
  00185	e8 00 00 00 00	 call	 ?BlPoolFreeBlock@@YIXPAX@Z ; BlPoolFreeBlock

; 873  : 
; 874  :                 return FALSE;

  0018a	32 c0		 xor	 al, al
  0018c	eb 76		 jmp	 SHORT $LN20@BlFatFindF
$LN4@BlFatFindF:

; 875  :             }
; 876  : 
; 877  :             TableSize = (DirectoryClusterCount * BlFatBytesPerCluster) / sizeof(FAT_DIRECTORY_ENTRY);

  0018e	8b 45 fc	 mov	 eax, DWORD PTR _DirectoryClusterCount$[ebp]
  00191	0f af 05 00 00
	00 00		 imul	 eax, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  00198	c1 e8 05	 shr	 eax, 5
  0019b	89 85 bc fe ff
	ff		 mov	 DWORD PTR _TableSize$[ebp], eax
$LN6@BlFatFindF:

; 878  :         }
; 879  : 
; 880  :         //
; 881  :         // Walk the directory table matching the previous token for an entry matching the next token.
; 882  :         //
; 883  : 
; 884  :         Match = BlFatFindDirectoryTableEntry(Table,
; 885  :                                              TableSize,
; 886  :                                              (PCSTR) Token);

  001a1	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR _Token$[ebp]
  001a7	51		 push	 ecx
  001a8	8b 95 bc fe ff
	ff		 mov	 edx, DWORD PTR _TableSize$[ebp]
  001ae	8b 4d d0	 mov	 ecx, DWORD PTR _Table$[ebp]
  001b1	e8 00 00 00 00	 call	 ?BlFatFindDirectoryTableEntry@@YIPAU_FAT_DIRECTORY_ENTRY@@PAU1@KPBD@Z ; BlFatFindDirectoryTableEntry
  001b6	89 45 c4	 mov	 DWORD PTR _Match$[ebp], eax

; 887  : 
; 888  :         if (Match == NULL) {

  001b9	83 7d c4 00	 cmp	 DWORD PTR _Match$[ebp], 0
  001bd	75 17		 jne	 SHORT $LN3@BlFatFindF

; 889  : 
; 890  : #if FAT_VERBOSE
; 891  : 
; 892  :             BlRtlPrintf("FAT: FindFileEntry: Unable to find directory entry for token %s.\n", Token);
; 893  : 
; 894  : #endif
; 895  : 
; 896  :             if (Table != BlFatRootDirectory) {

  001bf	8b 55 d0	 mov	 edx, DWORD PTR _Table$[ebp]
  001c2	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?BlFatRootDirectory@@3PAU_FAT_DIRECTORY_ENTRY@@A ; BlFatRootDirectory
  001c8	74 08		 je	 SHORT $LN2@BlFatFindF

; 897  : 
; 898  :                 BlPoolFreeBlock(Table);

  001ca	8b 4d d0	 mov	 ecx, DWORD PTR _Table$[ebp]
  001cd	e8 00 00 00 00	 call	 ?BlPoolFreeBlock@@YIXPAX@Z ; BlPoolFreeBlock
$LN2@BlFatFindF:

; 899  :             }
; 900  : 
; 901  :             return FALSE;

  001d2	32 c0		 xor	 al, al
  001d4	eb 2e		 jmp	 SHORT $LN20@BlFatFindF
$LN3@BlFatFindF:

; 902  :         }
; 903  : 
; 904  :         Entry = *Match;

  001d6	8b 75 c4	 mov	 esi, DWORD PTR _Match$[ebp]
  001d9	b9 08 00 00 00	 mov	 ecx, 8
  001de	8d 7d d4	 lea	 edi, DWORD PTR _Entry$[ebp]
  001e1	f3 a5		 rep movsd

; 905  : 
; 906  :         if (Table != BlFatRootDirectory) {

  001e3	8b 45 d0	 mov	 eax, DWORD PTR _Table$[ebp]
  001e6	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatRootDirectory@@3PAU_FAT_DIRECTORY_ENTRY@@A ; BlFatRootDirectory
  001ec	74 08		 je	 SHORT $LN1@BlFatFindF

; 907  : 
; 908  :             BlPoolFreeBlock(Table);

  001ee	8b 4d d0	 mov	 ecx, DWORD PTR _Table$[ebp]
  001f1	e8 00 00 00 00	 call	 ?BlPoolFreeBlock@@YIXPAX@Z ; BlPoolFreeBlock
$LN1@BlFatFindF:

; 909  :         }
; 910  : 
; 911  :         Depth += 1;

  001f6	8b 4d cc	 mov	 ecx, DWORD PTR _Depth$[ebp]
  001f9	83 c1 01	 add	 ecx, 1
  001fc	89 4d cc	 mov	 DWORD PTR _Depth$[ebp], ecx

; 912  :     }

  001ff	e9 64 fe ff ff	 jmp	 $LN17@BlFatFindF
$LN20@BlFatFindF:

; 913  : }

  00204	5f		 pop	 edi
  00205	5e		 pop	 esi
  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c3		 ret	 0
?BlFatFindFileEntry@@YIEPBDPAU_FAT_DIRECTORY_ENTRY@@@Z ENDP ; BlFatFindFileEntry
_TEXT	ENDS
PUBLIC	?BlFatGetFileSize@@YIEPBDPAK@Z			; BlFatGetFileSize
; Function compile flags: /Odtp
;	COMDAT ?BlFatGetFileSize@@YIEPBDPAK@Z
_TEXT	SEGMENT
_FileSize$ = -40					; size = 4
_Path$ = -36						; size = 4
_Entry$ = -32						; size = 32
?BlFatGetFileSize@@YIEPBDPAK@Z PROC			; BlFatGetFileSize, COMDAT
; _Path$ = ecx
; _FileSize$ = edx

; 940  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 55 d8	 mov	 DWORD PTR _FileSize$[ebp], edx
  00009	89 4d dc	 mov	 DWORD PTR _Path$[ebp], ecx

; 941  :     FAT_DIRECTORY_ENTRY Entry;
; 942  : 
; 943  :     if (BlFatFindFileEntry(Path, &Entry) == FALSE) {

  0000c	8d 55 e0	 lea	 edx, DWORD PTR _Entry$[ebp]
  0000f	8b 4d dc	 mov	 ecx, DWORD PTR _Path$[ebp]
  00012	e8 00 00 00 00	 call	 ?BlFatFindFileEntry@@YIEPBDPAU_FAT_DIRECTORY_ENTRY@@@Z ; BlFatFindFileEntry
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	75 04		 jne	 SHORT $LN1@BlFatGetFi

; 944  : 
; 945  :         return FALSE;

  0001e	32 c0		 xor	 al, al
  00020	eb 0a		 jmp	 SHORT $LN2@BlFatGetFi
$LN1@BlFatGetFi:

; 946  :     }
; 947  : 
; 948  :     *FileSize = Entry.u1.Short.Size;

  00022	8b 4d d8	 mov	 ecx, DWORD PTR _FileSize$[ebp]
  00025	8b 55 fc	 mov	 edx, DWORD PTR _Entry$[ebp+28]
  00028	89 11		 mov	 DWORD PTR [ecx], edx

; 949  : 
; 950  :     return TRUE;

  0002a	b0 01		 mov	 al, 1
$LN2@BlFatGetFi:

; 951  : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?BlFatGetFileSize@@YIEPBDPAK@Z ENDP			; BlFatGetFileSize
_TEXT	ENDS
PUBLIC	?BlFatReadFile@@YIEPBDPAXK@Z			; BlFatReadFile
; Function compile flags: /Odtp
;	COMDAT ?BlFatReadFile@@YIEPBDPAXK@Z
_TEXT	SEGMENT
_Buffer$ = -44						; size = 4
_Path$ = -40						; size = 4
_Entry$ = -36						; size = 32
_Result$ = -1						; size = 1
_NumberOfBytes$ = 8					; size = 4
?BlFatReadFile@@YIEPBDPAXK@Z PROC			; BlFatReadFile, COMDAT
; _Path$ = ecx
; _Buffer$ = edx

; 981  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 55 d4	 mov	 DWORD PTR _Buffer$[ebp], edx
  00009	89 4d d8	 mov	 DWORD PTR _Path$[ebp], ecx

; 982  :     FAT_DIRECTORY_ENTRY Entry;
; 983  :     BOOLEAN Result;
; 984  : 
; 985  :     if (BlFatFindFileEntry(Path, &Entry) == FALSE) {

  0000c	8d 55 dc	 lea	 edx, DWORD PTR _Entry$[ebp]
  0000f	8b 4d d8	 mov	 ecx, DWORD PTR _Path$[ebp]
  00012	e8 00 00 00 00	 call	 ?BlFatFindFileEntry@@YIEPBDPAU_FAT_DIRECTORY_ENTRY@@@Z ; BlFatFindFileEntry
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	75 04		 jne	 SHORT $LN2@BlFatReadF

; 986  : 
; 987  :         return FALSE;

  0001e	32 c0		 xor	 al, al
  00020	eb 22		 jmp	 SHORT $LN3@BlFatReadF
$LN2@BlFatReadF:

; 988  :     }
; 989  : 
; 990  :     if (NumberOfBytes > Entry.u1.Short.Size) {

  00022	8b 4d 08	 mov	 ecx, DWORD PTR _NumberOfBytes$[ebp]
  00025	3b 4d f8	 cmp	 ecx, DWORD PTR _Entry$[ebp+28]
  00028	76 04		 jbe	 SHORT $LN1@BlFatReadF

; 991  : 
; 992  :         return FALSE;

  0002a	32 c0		 xor	 al, al
  0002c	eb 16		 jmp	 SHORT $LN3@BlFatReadF
$LN1@BlFatReadF:

; 993  :     }
; 994  : 
; 995  :     Result = BlFatReadClusterChain(Entry.u1.Short.FirstClusterLow,
; 996  :                                    NumberOfBytes,
; 997  :                                    Buffer);

  0002e	8b 55 d4	 mov	 edx, DWORD PTR _Buffer$[ebp]
  00031	52		 push	 edx
  00032	0f b7 4d f6	 movzx	 ecx, WORD PTR _Entry$[ebp+26]
  00036	8b 55 08	 mov	 edx, DWORD PTR _NumberOfBytes$[ebp]
  00039	e8 00 00 00 00	 call	 ?BlFatReadClusterChain@@YIEKKPAX@Z ; BlFatReadClusterChain
  0003e	88 45 ff	 mov	 BYTE PTR _Result$[ebp], al

; 998  : 
; 999  :     return Result;

  00041	8a 45 ff	 mov	 al, BYTE PTR _Result$[ebp]
$LN3@BlFatReadF:

; 1000 : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?BlFatReadFile@@YIEPBDPAXK@Z ENDP			; BlFatReadFile
_TEXT	ENDS
PUBLIC	?BlFat16GetNextCluster@@YIEKPAK@Z		; BlFat16GetNextCluster
; Function compile flags: /Odtp
;	COMDAT ?BlFat16GetNextCluster@@YIEKPAK@Z
_TEXT	SEGMENT
_TablePage$ = -1024					; size = 512
_Offset$ = -20						; size = 4
_Sector$ = -16						; size = 4
tv67 = -12						; size = 4
_Cluster$ = -8						; size = 4
_NextCluster$ = -4					; size = 4
?BlFat16GetNextCluster@@YIEKPAK@Z PROC			; BlFat16GetNextCluster, COMDAT
; _Cluster$ = ecx
; _NextCluster$ = edx

; 1027 : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	81 e4 00 fe ff
	ff		 and	 esp, -512		; fffffe00H
  0000c	83 c4 04	 add	 esp, 4
  0000f	55		 push	 ebp
  00010	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00013	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00017	8b ec		 mov	 ebp, esp
  00019	81 ec 00 04 00
	00		 sub	 esp, 1024		; 00000400H
  0001f	89 55 fc	 mov	 DWORD PTR _NextCluster$[ebp], edx
  00022	89 4d f8	 mov	 DWORD PTR _Cluster$[ebp], ecx

; 1028 :     UINT32 Offset;
; 1029 :     UINT32 Sector;
; 1030 :     FAT_SECTOR TablePage;
; 1031 : 
; 1032 :     if (FAT_IS_DATA_CLUSTER(Cluster) == FALSE) {

  00025	83 7d f8 02	 cmp	 DWORD PTR _Cluster$[ebp], 2
  00029	72 17		 jb	 SHORT $LN5@BlFat16Get
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _Cluster$[ebp]
  0002e	83 e8 02	 sub	 eax, 2
  00031	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatNumberOfDataClusters@@3KA ; BlFatNumberOfDataClusters
  00037	73 09		 jae	 SHORT $LN5@BlFat16Get
  00039	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00040	eb 07		 jmp	 SHORT $LN6@BlFat16Get
$LN5@BlFat16Get:
  00042	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN6@BlFat16Get:
  00049	83 7d f4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0004d	75 04		 jne	 SHORT $LN2@BlFat16Get

; 1033 : 
; 1034 : #if FAT_VERBOSE
; 1035 : 
; 1036 :         BlRtlPrintf("FAT: Fat16GetNextCluster: Cluster %u is out of range!\n", Cluster);
; 1037 : 
; 1038 : #endif
; 1039 : 
; 1040 :         return FALSE;

  0004f	32 c0		 xor	 al, al
  00051	eb 4f		 jmp	 SHORT $LN3@BlFat16Get
$LN2@BlFat16Get:

; 1041 :     }
; 1042 : 
; 1043 :     Sector = BlFatTableStart + (Cluster / 256);

  00053	8b 4d f8	 mov	 ecx, DWORD PTR _Cluster$[ebp]
  00056	c1 e9 08	 shr	 ecx, 8
  00059	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?BlFatTableStart@@3KA ; BlFatTableStart
  0005f	89 4d f0	 mov	 DWORD PTR _Sector$[ebp], ecx

; 1044 :     Offset = Cluster % 256;

  00062	8b 45 f8	 mov	 eax, DWORD PTR _Cluster$[ebp]
  00065	33 d2		 xor	 edx, edx
  00067	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0006c	f7 f1		 div	 ecx
  0006e	89 55 ec	 mov	 DWORD PTR _Offset$[ebp], edx

; 1045 : 
; 1046 :     if (BlFatReadSector(Sector, 1, &TablePage) == FALSE) {

  00071	8d 95 00 fc ff
	ff		 lea	 edx, DWORD PTR _TablePage$[ebp]
  00077	52		 push	 edx
  00078	ba 01 00 00 00	 mov	 edx, 1
  0007d	8b 4d f0	 mov	 ecx, DWORD PTR _Sector$[ebp]
  00080	e8 00 00 00 00	 call	 ?BlFatReadSector@@YIEKKPAU_FAT_SECTOR@@@Z ; BlFatReadSector
  00085	0f b6 c0	 movzx	 eax, al
  00088	85 c0		 test	 eax, eax
  0008a	75 04		 jne	 SHORT $LN1@BlFat16Get

; 1047 : 
; 1048 :         return FALSE;

  0008c	32 c0		 xor	 al, al
  0008e	eb 12		 jmp	 SHORT $LN3@BlFat16Get
$LN1@BlFat16Get:

; 1049 :     }
; 1050 : 
; 1051 :     *NextCluster = (UINT32) (((PUINT16) &TablePage)[Offset]);

  00090	8b 4d ec	 mov	 ecx, DWORD PTR _Offset$[ebp]
  00093	0f b7 94 4d 00
	fc ff ff	 movzx	 edx, WORD PTR _TablePage$[ebp+ecx*2]
  0009b	8b 45 fc	 mov	 eax, DWORD PTR _NextCluster$[ebp]
  0009e	89 10		 mov	 DWORD PTR [eax], edx

; 1052 : 
; 1053 :     return TRUE;

  000a0	b0 01		 mov	 al, 1
$LN3@BlFat16Get:

; 1054 : }

  000a2	8b e5		 mov	 esp, ebp
  000a4	5d		 pop	 ebp
  000a5	8b e3		 mov	 esp, ebx
  000a7	5b		 pop	 ebx
  000a8	c3		 ret	 0
?BlFat16GetNextCluster@@YIEKPAK@Z ENDP			; BlFat16GetNextCluster
_TEXT	ENDS
PUBLIC	?BlFat16Initialize@@YIXXZ			; BlFat16Initialize
; Function compile flags: /Odtp
;	COMDAT ?BlFat16Initialize@@YIXXZ
_TEXT	SEGMENT
tv179 = -8						; size = 4
_BootSector$ = -4					; size = 4
?BlFat16Initialize@@YIXXZ PROC				; BlFat16Initialize, COMDAT

; 1069 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1070 :     PFAT16_BOOT_SECTOR BootSector;
; 1071 : 
; 1072 :     BootSector = &BlFatBootSector.u1.Fat16;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _BootSector$[ebp], OFFSET ?BlFatBootSector@@3U_FAT_BOOT_SECTOR@@A ; BlFatBootSector

; 1073 : 
; 1074 :     BLASSERT(BlFatMbr.Partition[BlFatPartitionId].Type == MBR_FAT16LBA);

  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatPartitionId@@3KA ; BlFatPartitionId
  00012	c1 e0 04	 shl	 eax, 4
  00015	0f b6 88 c2 01
	00 00		 movzx	 ecx, BYTE PTR ?BlFatMbr@@3U_MBR@@A[eax+450]
  0001c	83 f9 0e	 cmp	 ecx, 14			; 0000000eH
  0001f	74 0f		 je	 SHORT $LN17@BlFat16Ini
  00021	ba 32 04 00 00	 mov	 edx, 1074		; 00000432H
  00026	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  0002b	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN17@BlFat16Ini:

; 1075 : 
; 1076 :     //
; 1077 :     // Read FAT16 boot sector.
; 1078 :     //
; 1079 : 
; 1080 :     if (BlRtlReadDrive(BlFatDriveId,
; 1081 :                        BlFatPartitionStart,
; 1082 :                        1,
; 1083 :                        BootSector) == FALSE) {

  00030	8b 55 fc	 mov	 edx, DWORD PTR _BootSector$[ebp]
  00033	52		 push	 edx
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatPartitionStart@@3KA ; BlFatPartitionStart
  00039	33 c9		 xor	 ecx, ecx
  0003b	51		 push	 ecx
  0003c	50		 push	 eax
  0003d	ba 01 00 00 00	 mov	 edx, 1
  00042	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?BlFatDriveId@@3EA ; BlFatDriveId
  00048	e8 00 00 00 00	 call	 ?BlRtlReadDrive@@YIEE_KGPAX@Z ; BlRtlReadDrive
  0004d	0f b6 d0	 movzx	 edx, al
  00050	85 d2		 test	 edx, edx
  00052	75 0a		 jne	 SHORT $LN16@BlFat16Ini

; 1084 : 
; 1085 : #if FAT_VERBOSE
; 1086 :         BlRtlPrintf("FAT: Error reading boot sector!\n");
; 1087 : #endif
; 1088 :         BlFatHalt();

  00054	b9 40 04 00 00	 mov	 ecx, 1088		; 00000440H
  00059	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN16@BlFat16Ini:

; 1089 :     }
; 1090 : 
; 1091 :     //
; 1092 :     // Extract volume geometry.
; 1093 :     //
; 1094 : 
; 1095 :     if (BootSector->BytesPerSector != FAT_SECTOR_SIZE) {

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  00061	0f b7 48 0b	 movzx	 ecx, WORD PTR [eax+11]
  00065	81 f9 00 02 00
	00		 cmp	 ecx, 512		; 00000200H
  0006b	74 0a		 je	 SHORT $LN15@BlFat16Ini

; 1096 : 
; 1097 : #if FAT_VERBOSE
; 1098 :         BlRtlPrintf("FAT: Unsupported sector size (%u)!\n", BootSector->BytesPerSector);
; 1099 : #endif
; 1100 :         BlFatHalt();

  0006d	b9 4c 04 00 00	 mov	 ecx, 1100		; 0000044cH
  00072	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN15@BlFat16Ini:

; 1101 :     }
; 1102 : 
; 1103 :     BlFatSectorsPerCluster = BootSector->SectorsPerCluster;

  00077	8b 55 fc	 mov	 edx, DWORD PTR _BootSector$[ebp]
  0007a	0f b6 42 0d	 movzx	 eax, BYTE PTR [edx+13]
  0007e	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatSectorsPerCluster@@3KA, eax ; BlFatSectorsPerCluster

; 1104 : 
; 1105 :     if (BlFatSectorsPerCluster == 0) {

  00083	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?BlFatSectorsPerCluster@@3KA, 0 ; BlFatSectorsPerCluster
  0008a	75 0a		 jne	 SHORT $LN14@BlFat16Ini

; 1106 : 
; 1107 : #if FAT_VERBOSE
; 1108 :         BlRtlPrintf("FAT: SectorsPerCluster == 0!\n");
; 1109 : #endif
; 1110 :         BlFatHalt();

  0008c	b9 56 04 00 00	 mov	 ecx, 1110		; 00000456H
  00091	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN14@BlFat16Ini:

; 1111 :     }
; 1112 : 
; 1113 :     BlFatBytesPerCluster = BlFatSectorsPerCluster * FAT_SECTOR_SIZE;

  00096	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlFatSectorsPerCluster@@3KA ; BlFatSectorsPerCluster
  0009c	c1 e1 09	 shl	 ecx, 9
  0009f	89 0d 00 00 00
	00		 mov	 DWORD PTR ?BlFatBytesPerCluster@@3KA, ecx ; BlFatBytesPerCluster

; 1114 : 
; 1115 :     if (BootSector->TotalSectorCount32 > 0) {

  000a5	8b 55 fc	 mov	 edx, DWORD PTR _BootSector$[ebp]
  000a8	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  000ac	76 0e		 jbe	 SHORT $LN13@BlFat16Ini

; 1116 : 
; 1117 :         BlFatTotalSectorCount = BootSector->TotalSectorCount32;

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  000b1	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000b4	89 0d 00 00 00
	00		 mov	 DWORD PTR ?BlFatTotalSectorCount@@3KA, ecx ; BlFatTotalSectorCount

; 1118 : 
; 1119 :     } else {

  000ba	eb 0c		 jmp	 SHORT $LN12@BlFat16Ini
$LN13@BlFat16Ini:

; 1120 : 
; 1121 :         BlFatTotalSectorCount = BootSector->TotalSectorCount16;

  000bc	8b 55 fc	 mov	 edx, DWORD PTR _BootSector$[ebp]
  000bf	0f b7 42 13	 movzx	 eax, WORD PTR [edx+19]
  000c3	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatTotalSectorCount@@3KA, eax ; BlFatTotalSectorCount
$LN12@BlFat16Ini:

; 1122 :     }
; 1123 : 
; 1124 :     if (BlFatTotalSectorCount > BlFatPartitionSize) {

  000c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  000ce	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?BlFatPartitionSize@@3KA ; BlFatPartitionSize
  000d4	76 0a		 jbe	 SHORT $LN11@BlFat16Ini

; 1125 : 
; 1126 : #if FAT_VERBOSE
; 1127 :         BlRtlPrintf("FAT: Boot sector claims more sectors than MBR!\n");
; 1128 : #endif
; 1129 :         BlFatHalt();

  000d6	b9 69 04 00 00	 mov	 ecx, 1129		; 00000469H
  000db	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN11@BlFat16Ini:

; 1130 :     }
; 1131 : 
; 1132 :     if (BootSector->NumberOfFATs == 0) {

  000e0	8b 55 fc	 mov	 edx, DWORD PTR _BootSector$[ebp]
  000e3	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  000e7	85 c0		 test	 eax, eax
  000e9	75 0a		 jne	 SHORT $LN10@BlFat16Ini

; 1133 : 
; 1134 : #if FAT_VERBOSE
; 1135 :         BlRtlPrintf("FAT: NumberOfFATs == 0!\n");
; 1136 : #endif
; 1137 :         BlFatHalt();

  000eb	b9 71 04 00 00	 mov	 ecx, 1137		; 00000471H
  000f0	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN10@BlFat16Ini:

; 1138 :     }
; 1139 : 
; 1140 :     if (BootSector->SectorsPerFAT == 0) {

  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _BootSector$[ebp]
  000f8	0f b7 51 16	 movzx	 edx, WORD PTR [ecx+22]
  000fc	85 d2		 test	 edx, edx
  000fe	75 0a		 jne	 SHORT $LN9@BlFat16Ini

; 1141 : 
; 1142 : #if FAT_VERBOSE
; 1143 :         BlRtlPrintf("FAT: SectorsPerFAT == 0!\n");
; 1144 : #endif
; 1145 :         BlFatHalt();

  00100	b9 79 04 00 00	 mov	 ecx, 1145		; 00000479H
  00105	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN9@BlFat16Ini:

; 1146 :     }
; 1147 : 
; 1148 :     BlFatNumberOfRootDirectoryEntries = BootSector->NumberOfRootDirectoryEntries;

  0010a	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  0010d	0f b7 48 11	 movzx	 ecx, WORD PTR [eax+17]
  00111	89 0d 00 00 00
	00		 mov	 DWORD PTR ?BlFatNumberOfRootDirectoryEntries@@3KA, ecx ; BlFatNumberOfRootDirectoryEntries

; 1149 : 
; 1150 :     if ((BlFatNumberOfRootDirectoryEntries == 0) ||
; 1151 :         ((BlFatNumberOfRootDirectoryEntries % 64) != 0)) {

  00117	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?BlFatNumberOfRootDirectoryEntries@@3KA, 0 ; BlFatNumberOfRootDirectoryEntries
  0011e	74 12		 je	 SHORT $LN7@BlFat16Ini
  00120	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatNumberOfRootDirectoryEntries@@3KA ; BlFatNumberOfRootDirectoryEntries
  00125	33 d2		 xor	 edx, edx
  00127	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  0012c	f7 f1		 div	 ecx
  0012e	85 d2		 test	 edx, edx
  00130	74 0a		 je	 SHORT $LN8@BlFat16Ini
$LN7@BlFat16Ini:

; 1152 : 
; 1153 : #if FAT_VERBOSE
; 1154 :         BlRtlPrintf("FAT: Invalid number of root directory entries (%u)!\n", BlFatNumberOfRootDirectoryEntries);
; 1155 : #endif
; 1156 :         BlFatHalt();

  00132	b9 84 04 00 00	 mov	 ecx, 1156		; 00000484H
  00137	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN8@BlFat16Ini:

; 1157 :     }
; 1158 : 
; 1159 :     BlFatTableStart = BootSector->NumberOfReservedSectors;

  0013c	8b 55 fc	 mov	 edx, DWORD PTR _BootSector$[ebp]
  0013f	0f b7 42 0e	 movzx	 eax, WORD PTR [edx+14]
  00143	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatTableStart@@3KA, eax ; BlFatTableStart

; 1160 : 
; 1161 :     if (BlFatTotalSectorCount < BlFatTableStart) {

  00148	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  0014e	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?BlFatTableStart@@3KA ; BlFatTableStart
  00154	73 0a		 jae	 SHORT $LN6@BlFat16Ini

; 1162 : 
; 1163 : #if FAT_VERBOSE
; 1164 :         BlRtlPrintf("FAT: TotalSectorCount < TableStart!\n");
; 1165 : #endif
; 1166 :         BlFatHalt();

  00156	b9 8e 04 00 00	 mov	 ecx, 1166		; 0000048eH
  0015b	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN6@BlFat16Ini:

; 1167 :     }
; 1168 : 
; 1169 :     BlFatRootStart = BlFatTableStart + (BootSector->NumberOfFATs * BootSector->SectorsPerFAT);

  00160	8b 55 fc	 mov	 edx, DWORD PTR _BootSector$[ebp]
  00163	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  00167	8b 4d fc	 mov	 ecx, DWORD PTR _BootSector$[ebp]
  0016a	0f b7 51 16	 movzx	 edx, WORD PTR [ecx+22]
  0016e	0f af c2	 imul	 eax, edx
  00171	03 05 00 00 00
	00		 add	 eax, DWORD PTR ?BlFatTableStart@@3KA ; BlFatTableStart
  00177	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatRootStart@@3KA, eax ; BlFatRootStart

; 1170 : 
; 1171 :     if (BlFatTotalSectorCount < BlFatRootStart) {

  0017c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  00181	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatRootStart@@3KA ; BlFatRootStart
  00187	73 0a		 jae	 SHORT $LN5@BlFat16Ini

; 1172 : 
; 1173 : #if FAT_VERBOSE
; 1174 :         BlRtlPrintf("FAT: TotalSectorCount < RootStart!\n");
; 1175 : #endif
; 1176 :         BlFatHalt();

  00189	b9 98 04 00 00	 mov	 ecx, 1176		; 00000498H
  0018e	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN5@BlFat16Ini:

; 1177 :     }
; 1178 : 
; 1179 :     BlFatDataStart = BlFatRootStart + (ROUND_UP_TO_POWER2(BlFatNumberOfRootDirectoryEntries * sizeof(FAT_DIRECTORY_ENTRY), FAT_SECTOR_SIZE) / FAT_SECTOR_SIZE);

  00193	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlFatNumberOfRootDirectoryEntries@@3KA ; BlFatNumberOfRootDirectoryEntries
  00199	c1 e1 05	 shl	 ecx, 5
  0019c	81 c1 ff 01 00
	00		 add	 ecx, 511		; 000001ffH
  001a2	81 e1 00 fe ff
	ff		 and	 ecx, -512		; fffffe00H
  001a8	c1 e9 09	 shr	 ecx, 9
  001ab	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?BlFatRootStart@@3KA ; BlFatRootStart
  001b1	89 0d 00 00 00
	00		 mov	 DWORD PTR ?BlFatDataStart@@3KA, ecx ; BlFatDataStart

; 1180 : 
; 1181 :     if (BlFatTotalSectorCount < BlFatDataStart) {

  001b7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  001bd	3b 15 00 00 00
	00		 cmp	 edx, DWORD PTR ?BlFatDataStart@@3KA ; BlFatDataStart
  001c3	73 0a		 jae	 SHORT $LN4@BlFat16Ini

; 1182 : 
; 1183 : #if FAT_VERBOSE
; 1184 :         BlRtlPrintf("FAT: TotalSectorCount < DataStart!\n");
; 1185 : #endif
; 1186 :         BlFatHalt();

  001c5	b9 a2 04 00 00	 mov	 ecx, 1186		; 000004a2H
  001ca	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN4@BlFat16Ini:

; 1187 :     }
; 1188 : 
; 1189 :     BlFatNumberOfDataClusters = (BlFatTotalSectorCount - BlFatDataStart) / BlFatSectorsPerCluster;

  001cf	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  001d4	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?BlFatDataStart@@3KA ; BlFatDataStart
  001da	33 d2		 xor	 edx, edx
  001dc	f7 35 00 00 00
	00		 div	 DWORD PTR ?BlFatSectorsPerCluster@@3KA ; BlFatSectorsPerCluster
  001e2	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatNumberOfDataClusters@@3KA, eax ; BlFatNumberOfDataClusters

; 1190 : 
; 1191 :     if (BlFatNumberOfDataClusters == 0) {

  001e7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?BlFatNumberOfDataClusters@@3KA, 0 ; BlFatNumberOfDataClusters
  001ee	75 0a		 jne	 SHORT $LN3@BlFat16Ini

; 1192 : 
; 1193 : #if FAT_VERBOSE
; 1194 :         BlRtlPrintf("FAT: NumberOfDataClusters == 0!\n");
; 1195 : #endif
; 1196 :         BlFatHalt();

  001f0	b9 ac 04 00 00	 mov	 ecx, 1196		; 000004acH
  001f5	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN3@BlFat16Ini:

; 1197 :     }
; 1198 : 
; 1199 :     BlFatLinkTerminator = FAT16_LINK_TERMINATOR;

  001fa	c7 05 00 00 00
	00 ff ff 00 00	 mov	 DWORD PTR ?BlFatLinkTerminator@@3KA, 65535 ; BlFatLinkTerminator, 0000ffffH

; 1200 :     BlFatGetNextCluster = BlFat16GetNextCluster;

  00204	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BlFatGetNextCluster@@3P6IEKPAK@ZA, OFFSET ?BlFat16GetNextCluster@@YIEKPAK@Z ; BlFatGetNextCluster, BlFat16GetNextCluster

; 1201 : 
; 1202 :     //
; 1203 :     // Read root directory.
; 1204 :     //
; 1205 : 
; 1206 :     BlFatRootDirectory = (PFAT_DIRECTORY_ENTRY) BlPoolAllocateBlock((BlFatDataStart - BlFatRootStart) * FAT_SECTOR_SIZE);

  0020e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlFatDataStart@@3KA ; BlFatDataStart
  00214	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR ?BlFatRootStart@@3KA ; BlFatRootStart
  0021a	c1 e1 09	 shl	 ecx, 9
  0021d	e8 00 00 00 00	 call	 ?BlPoolAllocateBlock@@YIPAXK@Z ; BlPoolAllocateBlock
  00222	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatRootDirectory@@3PAU_FAT_DIRECTORY_ENTRY@@A, eax ; BlFatRootDirectory

; 1207 : 
; 1208 :     if (BlFatReadSector(BlFatRootStart,
; 1209 :                         BlFatDataStart - BlFatRootStart,
; 1210 :                         (PFAT_SECTOR) BlFatRootDirectory) == FALSE) {

  00227	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatRootDirectory@@3PAU_FAT_DIRECTORY_ENTRY@@A ; BlFatRootDirectory
  0022c	50		 push	 eax
  0022d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?BlFatDataStart@@3KA ; BlFatDataStart
  00233	2b 15 00 00 00
	00		 sub	 edx, DWORD PTR ?BlFatRootStart@@3KA ; BlFatRootStart
  00239	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlFatRootStart@@3KA ; BlFatRootStart
  0023f	e8 00 00 00 00	 call	 ?BlFatReadSector@@YIEKKPAU_FAT_SECTOR@@@Z ; BlFatReadSector
  00244	0f b6 c8	 movzx	 ecx, al
  00247	85 c9		 test	 ecx, ecx
  00249	75 0a		 jne	 SHORT $LN2@BlFat16Ini

; 1211 : 
; 1212 : #if FAT_VERBOSE
; 1213 :         BlRtlPrintf("FAT: Error reading root directory!\n");
; 1214 : #endif
; 1215 :         BlFatHalt();

  0024b	b9 bf 04 00 00	 mov	 ecx, 1215		; 000004bfH
  00250	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN2@BlFat16Ini:

; 1216 :     }
; 1217 : 
; 1218 :     BLASSERT(FAT_IS_DATA_CLUSTER(FAT16_LINK_TERMINATOR) == FALSE);

  00255	ba 01 00 00 00	 mov	 edx, 1
  0025a	85 d2		 test	 edx, edx
  0025c	74 15		 je	 SHORT $LN20@BlFat16Ini
  0025e	81 3d 00 00 00
	00 fd ff 00 00	 cmp	 DWORD PTR ?BlFatNumberOfDataClusters@@3KA, 65533 ; BlFatNumberOfDataClusters, 0000fffdH
  00268	76 09		 jbe	 SHORT $LN20@BlFat16Ini
  0026a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv179[ebp], 1
  00271	eb 07		 jmp	 SHORT $LN21@BlFat16Ini
$LN20@BlFat16Ini:
  00273	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv179[ebp], 0
$LN21@BlFat16Ini:
  0027a	83 7d f8 00	 cmp	 DWORD PTR tv179[ebp], 0
  0027e	74 0f		 je	 SHORT $LN18@BlFat16Ini
  00280	ba c2 04 00 00	 mov	 edx, 1218		; 000004c2H
  00285	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  0028a	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN18@BlFat16Ini:

; 1219 : 
; 1220 :     return;
; 1221 : }

  0028f	8b e5		 mov	 esp, ebp
  00291	5d		 pop	 ebp
  00292	c3		 ret	 0
?BlFat16Initialize@@YIXXZ ENDP				; BlFat16Initialize
_TEXT	ENDS
PUBLIC	?BlFat32GetNextCluster@@YIEKPAK@Z		; BlFat32GetNextCluster
; Function compile flags: /Odtp
;	COMDAT ?BlFat32GetNextCluster@@YIEKPAK@Z
_TEXT	SEGMENT
_TablePage$ = -1024					; size = 512
_Offset$ = -20						; size = 4
_Sector$ = -16						; size = 4
tv67 = -12						; size = 4
_Cluster$ = -8						; size = 4
_NextCluster$ = -4					; size = 4
?BlFat32GetNextCluster@@YIEKPAK@Z PROC			; BlFat32GetNextCluster, COMDAT
; _Cluster$ = ecx
; _NextCluster$ = edx

; 1248 : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	81 e4 00 fe ff
	ff		 and	 esp, -512		; fffffe00H
  0000c	83 c4 04	 add	 esp, 4
  0000f	55		 push	 ebp
  00010	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00013	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00017	8b ec		 mov	 ebp, esp
  00019	81 ec 00 04 00
	00		 sub	 esp, 1024		; 00000400H
  0001f	89 55 fc	 mov	 DWORD PTR _NextCluster$[ebp], edx
  00022	89 4d f8	 mov	 DWORD PTR _Cluster$[ebp], ecx

; 1249 :     UINT32 Offset;
; 1250 :     UINT32 Sector;
; 1251 :     FAT_SECTOR TablePage;
; 1252 : 
; 1253 :     if (FAT_IS_DATA_CLUSTER(Cluster) == FALSE) {

  00025	83 7d f8 02	 cmp	 DWORD PTR _Cluster$[ebp], 2
  00029	72 17		 jb	 SHORT $LN5@BlFat32Get
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _Cluster$[ebp]
  0002e	83 e8 02	 sub	 eax, 2
  00031	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatNumberOfDataClusters@@3KA ; BlFatNumberOfDataClusters
  00037	73 09		 jae	 SHORT $LN5@BlFat32Get
  00039	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00040	eb 07		 jmp	 SHORT $LN6@BlFat32Get
$LN5@BlFat32Get:
  00042	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN6@BlFat32Get:
  00049	83 7d f4 00	 cmp	 DWORD PTR tv67[ebp], 0
  0004d	75 04		 jne	 SHORT $LN2@BlFat32Get

; 1254 : 
; 1255 : #if FAT_VERBOSE
; 1256 : 
; 1257 :         BlRtlPrintf("FAT: Fat32GetNextCluster: Cluster %u is out of range!\n", Cluster);
; 1258 : 
; 1259 : #endif
; 1260 : 
; 1261 :         return FALSE;

  0004f	32 c0		 xor	 al, al
  00051	eb 4e		 jmp	 SHORT $LN3@BlFat32Get
$LN2@BlFat32Get:

; 1262 :     }
; 1263 : 
; 1264 :     Sector = BlFatTableStart + (Cluster / 128);

  00053	8b 4d f8	 mov	 ecx, DWORD PTR _Cluster$[ebp]
  00056	c1 e9 07	 shr	 ecx, 7
  00059	03 0d 00 00 00
	00		 add	 ecx, DWORD PTR ?BlFatTableStart@@3KA ; BlFatTableStart
  0005f	89 4d f0	 mov	 DWORD PTR _Sector$[ebp], ecx

; 1265 :     Offset = Cluster % 128;

  00062	8b 45 f8	 mov	 eax, DWORD PTR _Cluster$[ebp]
  00065	33 d2		 xor	 edx, edx
  00067	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0006c	f7 f1		 div	 ecx
  0006e	89 55 ec	 mov	 DWORD PTR _Offset$[ebp], edx

; 1266 : 
; 1267 :     if (BlFatReadSector(Sector, 1, &TablePage) == FALSE) {

  00071	8d 95 00 fc ff
	ff		 lea	 edx, DWORD PTR _TablePage$[ebp]
  00077	52		 push	 edx
  00078	ba 01 00 00 00	 mov	 edx, 1
  0007d	8b 4d f0	 mov	 ecx, DWORD PTR _Sector$[ebp]
  00080	e8 00 00 00 00	 call	 ?BlFatReadSector@@YIEKKPAU_FAT_SECTOR@@@Z ; BlFatReadSector
  00085	0f b6 c0	 movzx	 eax, al
  00088	85 c0		 test	 eax, eax
  0008a	75 04		 jne	 SHORT $LN1@BlFat32Get

; 1268 : 
; 1269 :         return FALSE;

  0008c	32 c0		 xor	 al, al
  0008e	eb 11		 jmp	 SHORT $LN3@BlFat32Get
$LN1@BlFat32Get:

; 1270 :     }
; 1271 : 
; 1272 :     *NextCluster = ((PUINT32) &TablePage)[Offset];

  00090	8b 4d fc	 mov	 ecx, DWORD PTR _NextCluster$[ebp]
  00093	8b 55 ec	 mov	 edx, DWORD PTR _Offset$[ebp]
  00096	8b 84 95 00 fc
	ff ff		 mov	 eax, DWORD PTR _TablePage$[ebp+edx*4]
  0009d	89 01		 mov	 DWORD PTR [ecx], eax

; 1273 : 
; 1274 :     return TRUE;

  0009f	b0 01		 mov	 al, 1
$LN3@BlFat32Get:

; 1275 : }

  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	8b e3		 mov	 esp, ebx
  000a6	5b		 pop	 ebx
  000a7	c3		 ret	 0
?BlFat32GetNextCluster@@YIEKPAK@Z ENDP			; BlFat32GetNextCluster
_TEXT	ENDS
PUBLIC	?BlFat32Initialize@@YIXXZ			; BlFat32Initialize
; Function compile flags: /Odtp
;	COMDAT ?BlFat32Initialize@@YIXXZ
_TEXT	SEGMENT
tv177 = -12						; size = 4
_RootDirectoryChainLength$ = -8				; size = 4
_BootSector$ = -4					; size = 4
?BlFat32Initialize@@YIXXZ PROC				; BlFat32Initialize, COMDAT

; 1290 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1291 :     PFAT32_BOOT_SECTOR BootSector;
; 1292 :     UINT32 RootDirectoryChainLength;
; 1293 : 
; 1294 :     BootSector = &BlFatBootSector.u1.Fat32;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _BootSector$[ebp], OFFSET ?BlFatBootSector@@3U_FAT_BOOT_SECTOR@@A ; BlFatBootSector

; 1295 : 
; 1296 :     BLASSERT(BlFatMbr.Partition[BlFatPartitionId].Type == MBR_FAT32LBA);

  0000d	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatPartitionId@@3KA ; BlFatPartitionId
  00012	c1 e0 04	 shl	 eax, 4
  00015	0f b6 88 c2 01
	00 00		 movzx	 ecx, BYTE PTR ?BlFatMbr@@3U_MBR@@A[eax+450]
  0001c	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  0001f	74 0f		 je	 SHORT $LN16@BlFat32Ini
  00021	ba 10 05 00 00	 mov	 edx, 1296		; 00000510H
  00026	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  0002b	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN16@BlFat32Ini:

; 1297 : 
; 1298 :     //
; 1299 :     // Read FAT32 boot sector.
; 1300 :     //
; 1301 : 
; 1302 :     if (BlRtlReadDrive(BlFatDriveId,
; 1303 :                        BlFatPartitionStart,
; 1304 :                        1,
; 1305 :                        BootSector) == FALSE) {

  00030	8b 55 fc	 mov	 edx, DWORD PTR _BootSector$[ebp]
  00033	52		 push	 edx
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatPartitionStart@@3KA ; BlFatPartitionStart
  00039	33 c9		 xor	 ecx, ecx
  0003b	51		 push	 ecx
  0003c	50		 push	 eax
  0003d	ba 01 00 00 00	 mov	 edx, 1
  00042	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?BlFatDriveId@@3EA ; BlFatDriveId
  00048	e8 00 00 00 00	 call	 ?BlRtlReadDrive@@YIEE_KGPAX@Z ; BlRtlReadDrive
  0004d	0f b6 d0	 movzx	 edx, al
  00050	85 d2		 test	 edx, edx
  00052	75 0a		 jne	 SHORT $LN15@BlFat32Ini

; 1306 : 
; 1307 : #if FAT_VERBOSE
; 1308 :         BlRtlPrintf("FAT: Error reading boot sector!\n");
; 1309 : #endif
; 1310 :         BlFatHalt();

  00054	b9 1e 05 00 00	 mov	 ecx, 1310		; 0000051eH
  00059	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN15@BlFat32Ini:

; 1311 :     }
; 1312 : 
; 1313 :     //
; 1314 :     // Extract volume geometry.
; 1315 :     //
; 1316 : 
; 1317 :     if (BootSector->BytesPerSector != FAT_SECTOR_SIZE) {

  0005e	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  00061	0f b7 48 0b	 movzx	 ecx, WORD PTR [eax+11]
  00065	81 f9 00 02 00
	00		 cmp	 ecx, 512		; 00000200H
  0006b	74 0a		 je	 SHORT $LN14@BlFat32Ini

; 1318 : 
; 1319 : #if FAT_VERBOSE
; 1320 :         BlRtlPrintf("FAT: Unsupported sector size (%u)!\n", BootSector->BytesPerSector);
; 1321 : #endif
; 1322 :         BlFatHalt();

  0006d	b9 2a 05 00 00	 mov	 ecx, 1322		; 0000052aH
  00072	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN14@BlFat32Ini:

; 1323 :     }
; 1324 : 
; 1325 :     BlFatSectorsPerCluster = BootSector->SectorsPerCluster;

  00077	8b 55 fc	 mov	 edx, DWORD PTR _BootSector$[ebp]
  0007a	0f b6 42 0d	 movzx	 eax, BYTE PTR [edx+13]
  0007e	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatSectorsPerCluster@@3KA, eax ; BlFatSectorsPerCluster

; 1326 : 
; 1327 :     if (BlFatSectorsPerCluster == 0) {

  00083	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?BlFatSectorsPerCluster@@3KA, 0 ; BlFatSectorsPerCluster
  0008a	75 0a		 jne	 SHORT $LN13@BlFat32Ini

; 1328 : 
; 1329 : #if FAT_VERBOSE
; 1330 :         BlRtlPrintf("FAT: SectorsPerCluster == 0!\n");
; 1331 : #endif
; 1332 :         BlFatHalt();

  0008c	b9 34 05 00 00	 mov	 ecx, 1332		; 00000534H
  00091	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN13@BlFat32Ini:

; 1333 :     }
; 1334 : 
; 1335 :     BlFatBytesPerCluster = BlFatSectorsPerCluster * FAT_SECTOR_SIZE;

  00096	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlFatSectorsPerCluster@@3KA ; BlFatSectorsPerCluster
  0009c	c1 e1 09	 shl	 ecx, 9
  0009f	89 0d 00 00 00
	00		 mov	 DWORD PTR ?BlFatBytesPerCluster@@3KA, ecx ; BlFatBytesPerCluster

; 1336 : 
; 1337 :     if (BootSector->TotalSectorCount32 > 0) {

  000a5	8b 55 fc	 mov	 edx, DWORD PTR _BootSector$[ebp]
  000a8	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  000ac	76 0e		 jbe	 SHORT $LN12@BlFat32Ini

; 1338 : 
; 1339 :         BlFatTotalSectorCount = BootSector->TotalSectorCount32;

  000ae	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  000b1	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  000b4	89 0d 00 00 00
	00		 mov	 DWORD PTR ?BlFatTotalSectorCount@@3KA, ecx ; BlFatTotalSectorCount

; 1340 : 
; 1341 :     } else {

  000ba	eb 0c		 jmp	 SHORT $LN11@BlFat32Ini
$LN12@BlFat32Ini:

; 1342 : 
; 1343 :         BlFatTotalSectorCount = BootSector->TotalSectorCount16;

  000bc	8b 55 fc	 mov	 edx, DWORD PTR _BootSector$[ebp]
  000bf	0f b7 42 13	 movzx	 eax, WORD PTR [edx+19]
  000c3	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatTotalSectorCount@@3KA, eax ; BlFatTotalSectorCount
$LN11@BlFat32Ini:

; 1344 :     }
; 1345 : 
; 1346 :     if (BlFatTotalSectorCount > BlFatPartitionSize) {

  000c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  000ce	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?BlFatPartitionSize@@3KA ; BlFatPartitionSize
  000d4	76 0a		 jbe	 SHORT $LN10@BlFat32Ini

; 1347 : 
; 1348 : #if FAT_VERBOSE
; 1349 :         BlRtlPrintf("FAT: Boot sector claims more sectors than MBR!\n");
; 1350 : #endif
; 1351 :         BlFatHalt();

  000d6	b9 47 05 00 00	 mov	 ecx, 1351		; 00000547H
  000db	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN10@BlFat32Ini:

; 1352 :     }
; 1353 : 
; 1354 :     if (BootSector->NumberOfFATs == 0) {

  000e0	8b 55 fc	 mov	 edx, DWORD PTR _BootSector$[ebp]
  000e3	0f b6 42 10	 movzx	 eax, BYTE PTR [edx+16]
  000e7	85 c0		 test	 eax, eax
  000e9	75 0a		 jne	 SHORT $LN9@BlFat32Ini

; 1355 : 
; 1356 : #if FAT_VERBOSE
; 1357 :         BlRtlPrintf("FAT: NumberOfFATs == 0!\n");
; 1358 : #endif
; 1359 :         BlFatHalt();

  000eb	b9 4f 05 00 00	 mov	 ecx, 1359		; 0000054fH
  000f0	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN9@BlFat32Ini:

; 1360 :     }
; 1361 : 
; 1362 :     if (BootSector->SectorsPerFAT32 == 0) {

  000f5	8b 4d fc	 mov	 ecx, DWORD PTR _BootSector$[ebp]
  000f8	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  000fc	75 0a		 jne	 SHORT $LN8@BlFat32Ini

; 1363 : 
; 1364 : #if FAT_VERBOSE
; 1365 :         BlRtlPrintf("FAT: SectorsPerFAT == 0!\n");
; 1366 : #endif
; 1367 :         BlFatHalt();

  000fe	b9 57 05 00 00	 mov	 ecx, 1367		; 00000557H
  00103	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN8@BlFat32Ini:

; 1368 :     }
; 1369 : 
; 1370 :     if (BootSector->NumberOfRootDirectoryEntries != 0) {

  00108	8b 55 fc	 mov	 edx, DWORD PTR _BootSector$[ebp]
  0010b	0f b7 42 11	 movzx	 eax, WORD PTR [edx+17]
  0010f	85 c0		 test	 eax, eax
  00111	74 0a		 je	 SHORT $LN7@BlFat32Ini

; 1371 : 
; 1372 : #if FAT_VERBOSE
; 1373 :         BlRtlPrintf("FAT: BootSector->NumberOfRootDirectoryEntries != 0!\n");
; 1374 : #endif
; 1375 :         BlFatHalt();

  00113	b9 5f 05 00 00	 mov	 ecx, 1375		; 0000055fH
  00118	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN7@BlFat32Ini:

; 1376 :     }
; 1377 : 
; 1378 :     BlFatTableStart = BootSector->NumberOfReservedSectors;

  0011d	8b 4d fc	 mov	 ecx, DWORD PTR _BootSector$[ebp]
  00120	0f b7 51 0e	 movzx	 edx, WORD PTR [ecx+14]
  00124	89 15 00 00 00
	00		 mov	 DWORD PTR ?BlFatTableStart@@3KA, edx ; BlFatTableStart

; 1379 : 
; 1380 :     if (BlFatTotalSectorCount < BlFatTableStart) {

  0012a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  0012f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?BlFatTableStart@@3KA ; BlFatTableStart
  00135	73 0a		 jae	 SHORT $LN6@BlFat32Ini

; 1381 : 
; 1382 : #if FAT_VERBOSE
; 1383 :         BlRtlPrintf("FAT: TotalSectorCount < TableStart!\n");
; 1384 : #endif
; 1385 :         BlFatHalt();

  00137	b9 69 05 00 00	 mov	 ecx, 1385		; 00000569H
  0013c	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN6@BlFat32Ini:

; 1386 :     }
; 1387 : 
; 1388 :     BlFatDataStart = BlFatTableStart + (BootSector->NumberOfFATs * BootSector->SectorsPerFAT32);

  00141	8b 4d fc	 mov	 ecx, DWORD PTR _BootSector$[ebp]
  00144	0f b6 51 10	 movzx	 edx, BYTE PTR [ecx+16]
  00148	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  0014b	0f af 50 24	 imul	 edx, DWORD PTR [eax+36]
  0014f	03 15 00 00 00
	00		 add	 edx, DWORD PTR ?BlFatTableStart@@3KA ; BlFatTableStart
  00155	89 15 00 00 00
	00		 mov	 DWORD PTR ?BlFatDataStart@@3KA, edx ; BlFatDataStart

; 1389 : 
; 1390 :     if (BlFatTotalSectorCount < BlFatDataStart) {

  0015b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  00161	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR ?BlFatDataStart@@3KA ; BlFatDataStart
  00167	73 0a		 jae	 SHORT $LN5@BlFat32Ini

; 1391 : 
; 1392 : #if FAT_VERBOSE
; 1393 :         BlRtlPrintf("FAT: TotalSectorCount < DataStart!\n");
; 1394 : #endif
; 1395 :         BlFatHalt();

  00169	b9 73 05 00 00	 mov	 ecx, 1395		; 00000573H
  0016e	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN5@BlFat32Ini:

; 1396 :     }
; 1397 : 
; 1398 :     BlFatNumberOfDataClusters = (BlFatTotalSectorCount - BlFatDataStart) / BlFatSectorsPerCluster;

  00173	a1 00 00 00 00	 mov	 eax, DWORD PTR ?BlFatTotalSectorCount@@3KA ; BlFatTotalSectorCount
  00178	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR ?BlFatDataStart@@3KA ; BlFatDataStart
  0017e	33 d2		 xor	 edx, edx
  00180	f7 35 00 00 00
	00		 div	 DWORD PTR ?BlFatSectorsPerCluster@@3KA ; BlFatSectorsPerCluster
  00186	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatNumberOfDataClusters@@3KA, eax ; BlFatNumberOfDataClusters

; 1399 : 
; 1400 :     if (BlFatNumberOfDataClusters == 0) {

  0018b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?BlFatNumberOfDataClusters@@3KA, 0 ; BlFatNumberOfDataClusters
  00192	75 0a		 jne	 SHORT $LN4@BlFat32Ini

; 1401 : 
; 1402 : #if FAT_VERBOSE
; 1403 :         BlRtlPrintf("FAT: NumberOfDataClusters == 0!\n");
; 1404 : #endif
; 1405 :         BlFatHalt();

  00194	b9 7d 05 00 00	 mov	 ecx, 1405		; 0000057dH
  00199	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN4@BlFat32Ini:

; 1406 :     }
; 1407 : 
; 1408 :     BlFatLinkTerminator = FAT32_LINK_TERMINATOR;

  0019e	c7 05 00 00 00
	00 ff ff ff 0f	 mov	 DWORD PTR ?BlFatLinkTerminator@@3KA, 268435455 ; BlFatLinkTerminator, 0fffffffH

; 1409 :     BlFatGetNextCluster = BlFat32GetNextCluster;

  001a8	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BlFatGetNextCluster@@3P6IEKPAK@ZA, OFFSET ?BlFat32GetNextCluster@@YIEKPAK@Z ; BlFatGetNextCluster, BlFat32GetNextCluster

; 1410 : 
; 1411 :     //
; 1412 :     // Read root directory.
; 1413 :     //
; 1414 : 
; 1415 :     if (BlFatGetLengthClusterChain(BootSector->RootDirectoryFirstCluster, &RootDirectoryChainLength) == FALSE) {

  001b2	8d 55 f8	 lea	 edx, DWORD PTR _RootDirectoryChainLength$[ebp]
  001b5	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  001b8	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  001bb	e8 00 00 00 00	 call	 ?BlFatGetLengthClusterChain@@YIEKPAK@Z ; BlFatGetLengthClusterChain
  001c0	0f b6 c8	 movzx	 ecx, al
  001c3	85 c9		 test	 ecx, ecx
  001c5	75 0a		 jne	 SHORT $LN3@BlFat32Ini

; 1416 : 
; 1417 : #if FAT_VERBOSE
; 1418 :         BlRtlPrintf("FAT: Error querying chain length of root directory!\n");
; 1419 : #endif
; 1420 :         BlFatHalt();

  001c7	b9 8c 05 00 00	 mov	 ecx, 1420		; 0000058cH
  001cc	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN3@BlFat32Ini:

; 1421 :     }
; 1422 : 
; 1423 :     BlFatRootDirectory = (PFAT_DIRECTORY_ENTRY) BlPoolAllocateBlock(RootDirectoryChainLength * BlFatBytesPerCluster);

  001d1	8b 4d f8	 mov	 ecx, DWORD PTR _RootDirectoryChainLength$[ebp]
  001d4	0f af 0d 00 00
	00 00		 imul	 ecx, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  001db	e8 00 00 00 00	 call	 ?BlPoolAllocateBlock@@YIPAXK@Z ; BlPoolAllocateBlock
  001e0	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatRootDirectory@@3PAU_FAT_DIRECTORY_ENTRY@@A, eax ; BlFatRootDirectory

; 1424 : 
; 1425 :     if (BlFatReadClusterChain(BootSector->RootDirectoryFirstCluster,
; 1426 :                               RootDirectoryChainLength * BlFatBytesPerCluster,
; 1427 :                               BlFatRootDirectory) == FALSE) {

  001e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?BlFatRootDirectory@@3PAU_FAT_DIRECTORY_ENTRY@@A ; BlFatRootDirectory
  001eb	52		 push	 edx
  001ec	8b 55 f8	 mov	 edx, DWORD PTR _RootDirectoryChainLength$[ebp]
  001ef	0f af 15 00 00
	00 00		 imul	 edx, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  001f6	8b 45 fc	 mov	 eax, DWORD PTR _BootSector$[ebp]
  001f9	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  001fc	e8 00 00 00 00	 call	 ?BlFatReadClusterChain@@YIEKKPAX@Z ; BlFatReadClusterChain
  00201	0f b6 c8	 movzx	 ecx, al
  00204	85 c9		 test	 ecx, ecx
  00206	75 0a		 jne	 SHORT $LN2@BlFat32Ini

; 1428 : 
; 1429 : #if FAT_VERBOSE
; 1430 :         BlRtlPrintf("FAT: Error reading root directory!\n");
; 1431 : #endif
; 1432 :         BlFatHalt();

  00208	b9 98 05 00 00	 mov	 ecx, 1432		; 00000598H
  0020d	e8 00 00 00 00	 call	 ?BlFatHaltInternal@@YIXK@Z ; BlFatHaltInternal
$LN2@BlFat32Ini:

; 1433 :     }
; 1434 : 
; 1435 :     BlFatNumberOfRootDirectoryEntries = (RootDirectoryChainLength * BlFatBytesPerCluster) / sizeof(FAT_DIRECTORY_ENTRY);

  00212	8b 55 f8	 mov	 edx, DWORD PTR _RootDirectoryChainLength$[ebp]
  00215	0f af 15 00 00
	00 00		 imul	 edx, DWORD PTR ?BlFatBytesPerCluster@@3KA ; BlFatBytesPerCluster
  0021c	c1 ea 05	 shr	 edx, 5
  0021f	89 15 00 00 00
	00		 mov	 DWORD PTR ?BlFatNumberOfRootDirectoryEntries@@3KA, edx ; BlFatNumberOfRootDirectoryEntries

; 1436 : 
; 1437 : 
; 1438 :     BLASSERT(FAT_IS_DATA_CLUSTER(FAT32_LINK_TERMINATOR) == FALSE);

  00225	b8 01 00 00 00	 mov	 eax, 1
  0022a	85 c0		 test	 eax, eax
  0022c	74 15		 je	 SHORT $LN19@BlFat32Ini
  0022e	81 3d 00 00 00
	00 fd ff ff 0f	 cmp	 DWORD PTR ?BlFatNumberOfDataClusters@@3KA, 268435453 ; BlFatNumberOfDataClusters, 0ffffffdH
  00238	76 09		 jbe	 SHORT $LN19@BlFat32Ini
  0023a	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv177[ebp], 1
  00241	eb 07		 jmp	 SHORT $LN20@BlFat32Ini
$LN19@BlFat32Ini:
  00243	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv177[ebp], 0
$LN20@BlFat32Ini:
  0024a	83 7d f4 00	 cmp	 DWORD PTR tv177[ebp], 0
  0024e	74 0f		 je	 SHORT $LN17@BlFat32Ini
  00250	ba 9e 05 00 00	 mov	 edx, 1438		; 0000059eH
  00255	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  0025a	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN17@BlFat32Ini:

; 1439 : 
; 1440 :     return;
; 1441 : }

  0025f	8b e5		 mov	 esp, ebp
  00261	5d		 pop	 ebp
  00262	c3		 ret	 0
?BlFat32Initialize@@YIXXZ ENDP				; BlFat32Initialize
_TEXT	ENDS
PUBLIC	??_C@_0BI@MOIILNGK@FAT?3?5No?5?$CFs?5partitions?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_05HNJNFBJJ@FAT32?$AA@			; `string'
PUBLIC	??_C@_05BKHFEAPD@FAT16?$AA@			; `string'
PUBLIC	??_C@_0BI@HGHMGDLA@FAT?3?5No?5MBR?5signature?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@CLMOHOJH@FAT?3?5Error?5reading?5MBR?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@OBAMHFHH@FAT?3?5Unexpected?5bytes?5per?5sector@ ; `string'
PUBLIC	??_C@_0CD@FBPPOBEA@FAT?3?5Can?8t?5get?5drive?5info?50x?$CF02x@ ; `string'
PUBLIC	?BlFatInitialize@@YIXEE@Z			; BlFatInitialize
EXTRN	?BlFsReadFile@@3P6IEPBDPAXK@ZA:DWORD		; BlFsReadFile
EXTRN	?BlFsGetFileSize@@3P6IEPBDPAK@ZA:DWORD		; BlFsGetFileSize
EXTRN	?BlRtlGetDriveParameters@@YIEEPAU_INT13_DRIVE_PARAMETERS@@@Z:PROC ; BlRtlGetDriveParameters
;	COMDAT ??_C@_0BI@MOIILNGK@FAT?3?5No?5?$CFs?5partitions?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BI@MOIILNGK@FAT?3?5No?5?$CFs?5partitions?$CB?6?$AA@ DB 'FAT: No %s'
	DB	' partitions!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05HNJNFBJJ@FAT32?$AA@
CONST	SEGMENT
??_C@_05HNJNFBJJ@FAT32?$AA@ DB 'FAT32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05BKHFEAPD@FAT16?$AA@
CONST	SEGMENT
??_C@_05BKHFEAPD@FAT16?$AA@ DB 'FAT16', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@HGHMGDLA@FAT?3?5No?5MBR?5signature?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BI@HGHMGDLA@FAT?3?5No?5MBR?5signature?$CB?6?$AA@ DB 'FAT: No MBR s'
	DB	'ignature!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CLMOHOJH@FAT?3?5Error?5reading?5MBR?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BJ@CLMOHOJH@FAT?3?5Error?5reading?5MBR?$CB?6?$AA@ DB 'FAT: Error r'
	DB	'eading MBR!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@OBAMHFHH@FAT?3?5Unexpected?5bytes?5per?5sector@
CONST	SEGMENT
??_C@_0CI@OBAMHFHH@FAT?3?5Unexpected?5bytes?5per?5sector@ DB 'FAT: Unexpe'
	DB	'cted bytes per sector (%u)!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FBPPOBEA@FAT?3?5Can?8t?5get?5drive?5info?50x?$CF02x@
CONST	SEGMENT
??_C@_0CD@FBPPOBEA@FAT?3?5Can?8t?5get?5drive?5info?50x?$CF02x@ DB 'FAT: C'
	DB	'an''t get drive info 0x%02x!', 0aH, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlFatInitialize@@YIXEE@Z
_TEXT	SEGMENT
tv165 = -20						; size = 4
tv144 = -16						; size = 4
_FatType$ = -12						; size = 1
_DriveId$ = -8						; size = 1
_Index$ = -4						; size = 4
?BlFatInitialize@@YIXEE@Z PROC				; BlFatInitialize, COMDAT
; _DriveId$ = cl
; _FatType$ = dl

; 1463 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	88 55 f4	 mov	 BYTE PTR _FatType$[ebp], dl
  00009	88 4d f8	 mov	 BYTE PTR _DriveId$[ebp], cl

; 1464 :     UINT32 Index;
; 1465 : 
; 1466 :     BLASSERT((FatType == MBR_FAT16LBA) || (FatType == MBR_FAT32LBA));

  0000c	0f b6 45 f4	 movzx	 eax, BYTE PTR _FatType$[ebp]
  00010	83 f8 0e	 cmp	 eax, 14			; 0000000eH
  00013	74 18		 je	 SHORT $LN14@BlFatIniti
  00015	0f b6 4d f4	 movzx	 ecx, BYTE PTR _FatType$[ebp]
  00019	83 f9 0c	 cmp	 ecx, 12			; 0000000cH
  0001c	74 0f		 je	 SHORT $LN14@BlFatIniti
  0001e	ba ba 05 00 00	 mov	 edx, 1466		; 000005baH
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  00028	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN14@BlFatIniti:

; 1467 : 
; 1468 :     if (BlRtlGetDriveParameters(DriveId, &BlFatDriveParameters) == FALSE) {

  0002d	ba 00 00 00 00	 mov	 edx, OFFSET ?BlFatDriveParameters@@3U_INT13_DRIVE_PARAMETERS@@A ; BlFatDriveParameters
  00032	8a 4d f8	 mov	 cl, BYTE PTR _DriveId$[ebp]
  00035	e8 00 00 00 00	 call	 ?BlRtlGetDriveParameters@@YIEEPAU_INT13_DRIVE_PARAMETERS@@@Z ; BlRtlGetDriveParameters
  0003a	0f b6 d0	 movzx	 edx, al
  0003d	85 d2		 test	 edx, edx
  0003f	75 21		 jne	 SHORT $LN13@BlFatIniti

; 1469 : 
; 1470 :         BlRtlPrintf("FAT: Can't get drive info 0x%02x!\n", DriveId);

  00041	0f b6 45 f8	 movzx	 eax, BYTE PTR _DriveId$[ebp]
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@FBPPOBEA@FAT?3?5Can?8t?5get?5drive?5info?50x?$CF02x@
  0004b	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00050	83 c4 08	 add	 esp, 8

; 1471 :         BlRtlHalt();

  00053	ba bf 05 00 00	 mov	 edx, 1471		; 000005bfH
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  0005d	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN13@BlFatIniti:

; 1472 :     }
; 1473 : 
; 1474 :     if (BlFatDriveParameters.BytesPerSector != FAT_SECTOR_SIZE) {

  00062	0f b7 0d 18 00
	00 00		 movzx	 ecx, WORD PTR ?BlFatDriveParameters@@3U_INT13_DRIVE_PARAMETERS@@A+24
  00069	81 f9 00 02 00
	00		 cmp	 ecx, 512		; 00000200H
  0006f	74 24		 je	 SHORT $LN12@BlFatIniti

; 1475 : 
; 1476 :         BlRtlPrintf("FAT: Unexpected bytes per sector (%u)!\n", BlFatDriveParameters.BytesPerSector);

  00071	0f b7 15 18 00
	00 00		 movzx	 edx, WORD PTR ?BlFatDriveParameters@@3U_INT13_DRIVE_PARAMETERS@@A+24
  00078	52		 push	 edx
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@OBAMHFHH@FAT?3?5Unexpected?5bytes?5per?5sector@
  0007e	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00083	83 c4 08	 add	 esp, 8

; 1477 :         BlRtlHalt();

  00086	ba c5 05 00 00	 mov	 edx, 1477		; 000005c5H
  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  00090	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN12@BlFatIniti:

; 1478 :     }
; 1479 : 
; 1480 :     if (BlRtlReadDrive(DriveId, 0, 1, &BlFatMbr) == FALSE) {

  00095	68 00 00 00 00	 push	 OFFSET ?BlFatMbr@@3U_MBR@@A ; BlFatMbr
  0009a	6a 00		 push	 0
  0009c	6a 00		 push	 0
  0009e	ba 01 00 00 00	 mov	 edx, 1
  000a3	8a 4d f8	 mov	 cl, BYTE PTR _DriveId$[ebp]
  000a6	e8 00 00 00 00	 call	 ?BlRtlReadDrive@@YIEE_KGPAX@Z ; BlRtlReadDrive
  000ab	0f b6 c0	 movzx	 eax, al
  000ae	85 c0		 test	 eax, eax
  000b0	75 1c		 jne	 SHORT $LN11@BlFatIniti

; 1481 : 
; 1482 :         BlRtlPrintf("FAT: Error reading MBR!\n");

  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CLMOHOJH@FAT?3?5Error?5reading?5MBR?$CB?6?$AA@
  000b7	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  000bc	83 c4 04	 add	 esp, 4

; 1483 :         BlRtlHalt();

  000bf	ba cb 05 00 00	 mov	 edx, 1483		; 000005cbH
  000c4	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  000c9	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN11@BlFatIniti:

; 1484 :     }
; 1485 : 
; 1486 :     if (BlFatMbr.Signature != MBR_SIGNATURE) {

  000ce	0f b7 0d fe 01
	00 00		 movzx	 ecx, WORD PTR ?BlFatMbr@@3U_MBR@@A+510
  000d5	81 f9 55 aa 00
	00		 cmp	 ecx, 43605		; 0000aa55H
  000db	74 0d		 je	 SHORT $LN10@BlFatIniti

; 1487 : 
; 1488 :         BlRtlPrintf("FAT: No MBR signature!\n");

  000dd	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@HGHMGDLA@FAT?3?5No?5MBR?5signature?$CB?6?$AA@
  000e2	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  000e7	83 c4 04	 add	 esp, 4
$LN10@BlFatIniti:

; 1489 :     }
; 1490 : 
; 1491 :     BlFatPartitionId = (UINT32) -1;

  000ea	c7 05 00 00 00
	00 ff ff ff ff	 mov	 DWORD PTR ?BlFatPartitionId@@3KA, -1 ; BlFatPartitionId

; 1492 : 
; 1493 :     for (Index = 0; Index <= 4; Index += 1) {

  000f4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0
  000fb	eb 09		 jmp	 SHORT $LN9@BlFatIniti
$LN8@BlFatIniti:
  000fd	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  00100	83 c2 01	 add	 edx, 1
  00103	89 55 fc	 mov	 DWORD PTR _Index$[ebp], edx
$LN9@BlFatIniti:
  00106	83 7d fc 04	 cmp	 DWORD PTR _Index$[ebp], 4
  0010a	0f 87 b1 00 00
	00		 ja	 $LN7@BlFatIniti

; 1494 : 
; 1495 :         if (FatType == BlFatMbr.Partition[Index].Type) {

  00110	0f b6 45 f4	 movzx	 eax, BYTE PTR _FatType$[ebp]
  00114	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  00117	c1 e1 04	 shl	 ecx, 4
  0011a	0f b6 91 c2 01
	00 00		 movzx	 edx, BYTE PTR ?BlFatMbr@@3U_MBR@@A[ecx+450]
  00121	3b c2		 cmp	 eax, edx
  00123	0f 85 93 00 00
	00		 jne	 $LN6@BlFatIniti

; 1496 : 
; 1497 :             switch (BlFatMbr.Partition[Index].Type) {

  00129	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0012c	c1 e0 04	 shl	 eax, 4
  0012f	8a 88 c2 01 00
	00		 mov	 cl, BYTE PTR ?BlFatMbr@@3U_MBR@@A[eax+450]
  00135	88 4d f0	 mov	 BYTE PTR tv144[ebp], cl
  00138	80 7d f0 0c	 cmp	 BYTE PTR tv144[ebp], 12	; 0000000cH
  0013c	74 44		 je	 SHORT $LN2@BlFatIniti
  0013e	80 7d f0 0e	 cmp	 BYTE PTR tv144[ebp], 14	; 0000000eH
  00142	74 02		 je	 SHORT $LN3@BlFatIniti
  00144	eb 76		 jmp	 SHORT $LN6@BlFatIniti
$LN3@BlFatIniti:

; 1498 : 
; 1499 :                 case MBR_FAT16LBA: {
; 1500 : 
; 1501 :                     BlFatDriveId = DriveId;

  00146	8a 55 f8	 mov	 dl, BYTE PTR _DriveId$[ebp]
  00149	88 15 00 00 00
	00		 mov	 BYTE PTR ?BlFatDriveId@@3EA, dl ; BlFatDriveId

; 1502 :                     BlFatPartitionId = Index;

  0014f	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00152	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatPartitionId@@3KA, eax ; BlFatPartitionId

; 1503 :                     BlFatPartitionStart = BlFatMbr.Partition[Index].FirstSector;

  00157	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  0015a	c1 e1 04	 shl	 ecx, 4
  0015d	8b 91 c6 01 00
	00		 mov	 edx, DWORD PTR ?BlFatMbr@@3U_MBR@@A[ecx+454]
  00163	89 15 00 00 00
	00		 mov	 DWORD PTR ?BlFatPartitionStart@@3KA, edx ; BlFatPartitionStart

; 1504 :                     BlFatPartitionSize = BlFatMbr.Partition[Index].NumberOfSectors;

  00169	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0016c	c1 e0 04	 shl	 eax, 4
  0016f	8b 88 ca 01 00
	00		 mov	 ecx, DWORD PTR ?BlFatMbr@@3U_MBR@@A[eax+458]
  00175	89 0d 00 00 00
	00		 mov	 DWORD PTR ?BlFatPartitionSize@@3KA, ecx ; BlFatPartitionSize

; 1505 : 
; 1506 :                     BlFat16Initialize();

  0017b	e8 00 00 00 00	 call	 ?BlFat16Initialize@@YIXXZ ; BlFat16Initialize

; 1507 : 
; 1508 :                     break;

  00180	eb 3a		 jmp	 SHORT $LN6@BlFatIniti
$LN2@BlFatIniti:

; 1509 :                 }
; 1510 : 
; 1511 :                 case MBR_FAT32LBA: {
; 1512 : 
; 1513 :                     BlFatDriveId = DriveId;

  00182	8a 55 f8	 mov	 dl, BYTE PTR _DriveId$[ebp]
  00185	88 15 00 00 00
	00		 mov	 BYTE PTR ?BlFatDriveId@@3EA, dl ; BlFatDriveId

; 1514 :                     BlFatPartitionId = Index;

  0018b	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0018e	a3 00 00 00 00	 mov	 DWORD PTR ?BlFatPartitionId@@3KA, eax ; BlFatPartitionId

; 1515 :                     BlFatPartitionStart = BlFatMbr.Partition[Index].FirstSector;

  00193	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  00196	c1 e1 04	 shl	 ecx, 4
  00199	8b 91 c6 01 00
	00		 mov	 edx, DWORD PTR ?BlFatMbr@@3U_MBR@@A[ecx+454]
  0019f	89 15 00 00 00
	00		 mov	 DWORD PTR ?BlFatPartitionStart@@3KA, edx ; BlFatPartitionStart

; 1516 :                     BlFatPartitionSize = BlFatMbr.Partition[Index].NumberOfSectors;

  001a5	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  001a8	c1 e0 04	 shl	 eax, 4
  001ab	8b 88 ca 01 00
	00		 mov	 ecx, DWORD PTR ?BlFatMbr@@3U_MBR@@A[eax+458]
  001b1	89 0d 00 00 00
	00		 mov	 DWORD PTR ?BlFatPartitionSize@@3KA, ecx ; BlFatPartitionSize

; 1517 : 
; 1518 :                     BlFat32Initialize();

  001b7	e8 00 00 00 00	 call	 ?BlFat32Initialize@@YIXXZ ; BlFat32Initialize
$LN6@BlFatIniti:

; 1519 : 
; 1520 :                     break;
; 1521 :                 }
; 1522 :             }
; 1523 :         }
; 1524 :     }

  001bc	e9 3c ff ff ff	 jmp	 $LN8@BlFatIniti
$LN7@BlFatIniti:

; 1525 : 
; 1526 :     if (BlFatPartitionId == (UINT32) -1) {

  001c1	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?BlFatPartitionId@@3KA, -1 ; BlFatPartitionId
  001c8	75 39		 jne	 SHORT $LN1@BlFatIniti

; 1527 : 
; 1528 :         BlRtlPrintf("FAT: No %s partitions!\n", FatType == MBR_FAT16LBA ? "FAT16" : "FAT32");

  001ca	0f b6 55 f4	 movzx	 edx, BYTE PTR _FatType$[ebp]
  001ce	83 fa 0e	 cmp	 edx, 14			; 0000000eH
  001d1	75 09		 jne	 SHORT $LN17@BlFatIniti
  001d3	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv165[ebp], OFFSET ??_C@_05BKHFEAPD@FAT16?$AA@
  001da	eb 07		 jmp	 SHORT $LN18@BlFatIniti
$LN17@BlFatIniti:
  001dc	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv165[ebp], OFFSET ??_C@_05HNJNFBJJ@FAT32?$AA@
$LN18@BlFatIniti:
  001e3	8b 45 ec	 mov	 eax, DWORD PTR tv165[ebp]
  001e6	50		 push	 eax
  001e7	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@MOIILNGK@FAT?3?5No?5?$CFs?5partitions?$CB?6?$AA@
  001ec	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  001f1	83 c4 08	 add	 esp, 8

; 1529 : 
; 1530 :         BlRtlHalt();

  001f4	ba fa 05 00 00	 mov	 edx, 1530		; 000005faH
  001f9	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09PEGKEIOA@blfat?4cpp?$AA@
  001fe	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN1@BlFatIniti:

; 1531 :     }
; 1532 : 
; 1533 :     BlFsGetFileSize = BlFatGetFileSize;

  00203	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BlFsGetFileSize@@3P6IEPBDPAK@ZA, OFFSET ?BlFatGetFileSize@@YIEPBDPAK@Z ; BlFsGetFileSize, BlFatGetFileSize

; 1534 :     BlFsReadFile = BlFatReadFile;

  0020d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BlFsReadFile@@3P6IEPBDPAXK@ZA, OFFSET ?BlFatReadFile@@YIEPBDPAXK@Z ; BlFsReadFile, BlFatReadFile

; 1535 : 
; 1536 :     return;
; 1537 : }

  00217	8b e5		 mov	 esp, ebp
  00219	5d		 pop	 ebp
  0021a	c3		 ret	 0
?BlFatInitialize@@YIXEE@Z ENDP				; BlFatInitialize
_TEXT	ENDS
END
