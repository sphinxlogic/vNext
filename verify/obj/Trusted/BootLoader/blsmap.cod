; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\OSes\VERVE\verify\src\Trusted\BootLoader\SingLdrPc\blsmap.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BlSystemMemoryMap@@3U_BL_SMAP@@A		; BlSystemMemoryMap
_BSS	SEGMENT
?BlSystemMemoryMap@@3U_BL_SMAP@@A DB 0c08H DUP (?)	; BlSystemMemoryMap
_BSS	ENDS
PUBLIC	??_C@_0BL@MFOMDCLF@SMAP?3?5INT?515?1E820?5failed?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0L@NPJEFNNA@blsmap?4cpp?$AA@		; `string'
PUBLIC	?BlGetBeb@@YIPAU_BEB@@XZ			; BlGetBeb
PUBLIC	?BlSmapInitialize@@YIXXZ			; BlSmapInitialize
EXTRN	?BlRtlHaltInternal@@YIXPBDK@Z:PROC		; BlRtlHaltInternal
EXTRN	?BlRtlPrintf@@YAEPBDZZ:PROC			; BlRtlPrintf
EXTRN	?BlRtlCallLegacyInterruptService@@YIXEPAU_BL_LEGACY_CALL_CONTEXT@@0@Z:PROC ; BlRtlCallLegacyInterruptService
EXTRN	?BlRtlZeroMemory@@YIXPAXK@Z:PROC		; BlRtlZeroMemory
EXTRN	?BlRtlAssertFailed@@YIXPBDK@Z:PROC		; BlRtlAssertFailed
EXTRN	?BlRtlCopyMemory@@YIXPAXPBXK@Z:PROC		; BlRtlCopyMemory
;	COMDAT ??_C@_0BL@MFOMDCLF@SMAP?3?5INT?515?1E820?5failed?$CB?6?$AA@
; File d:\oses\verve\verify\src\trusted\bootloader\singldrpc\blsmap.cpp
CONST	SEGMENT
??_C@_0BL@MFOMDCLF@SMAP?3?5INT?515?1E820?5failed?$CB?6?$AA@ DB 'SMAP: INT'
	DB	' 15/E820 failed!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NPJEFNNA@blsmap?4cpp?$AA@
CONST	SEGMENT
??_C@_0L@NPJEFNNA@blsmap?4cpp?$AA@ DB 'blsmap.cpp', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlSmapInitialize@@YIXXZ
_TEXT	SEGMENT
_Context$3289 = -64					; size = 36
_Address$3288 = -28					; size = 4
_ContinuationValue$3290 = -24				; size = 4
_pn$3284 = -20						; size = 4
_cb$3280 = -16						; size = 4
_pb$3278 = -12						; size = 4
_Beb$ = -8						; size = 4
_Index$ = -4						; size = 4
?BlSmapInitialize@@YIXXZ PROC				; BlSmapInitialize, COMDAT

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 89   :     UINT32 Index;
; 90   :     PBEB Beb;
; 91   : 
; 92   :     Beb = BlGetBeb();

  00006	e8 00 00 00 00	 call	 ?BlGetBeb@@YIPAU_BEB@@XZ ; BlGetBeb
  0000b	89 45 f8	 mov	 DWORD PTR _Beb$[ebp], eax

; 93   : 
; 94   :     if (Beb->SmapAddr != 0) {

  0000e	8b 45 f8	 mov	 eax, DWORD PTR _Beb$[ebp]
  00011	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00015	74 6c		 je	 SHORT $LN11@BlSmapInit

; 95   :         PUINT8 pb = (PUINT8)Beb->SmapAddr;

  00017	8b 4d f8	 mov	 ecx, DWORD PTR _Beb$[ebp]
  0001a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0001d	89 55 f4	 mov	 DWORD PTR _pb$3278[ebp], edx

; 96   :         UINT32 cb = Beb->SmapSize;

  00020	8b 45 f8	 mov	 eax, DWORD PTR _Beb$[ebp]
  00023	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00026	89 4d f0	 mov	 DWORD PTR _cb$3280[ebp], ecx

; 97   : 
; 98   :         for (Index = 0; Index < cb / 20; Index++) {

  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0
  00030	eb 09		 jmp	 SHORT $LN10@BlSmapInit
$LN9@BlSmapInit:
  00032	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  00035	83 c2 01	 add	 edx, 1
  00038	89 55 fc	 mov	 DWORD PTR _Index$[ebp], edx
$LN10@BlSmapInit:
  0003b	8b 45 f0	 mov	 eax, DWORD PTR _cb$3280[ebp]
  0003e	33 d2		 xor	 edx, edx
  00040	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  00045	f7 f1		 div	 ecx
  00047	39 45 fc	 cmp	 DWORD PTR _Index$[ebp], eax
  0004a	73 2a		 jae	 SHORT $LN8@BlSmapInit

; 99   :             PUINT8 pn = pb + Index * 20;

  0004c	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  0004f	6b d2 14	 imul	 edx, 20			; 00000014H
  00052	03 55 f4	 add	 edx, DWORD PTR _pb$3278[ebp]
  00055	89 55 ec	 mov	 DWORD PTR _pn$3284[ebp], edx

; 100  :             BlRtlCopyMemory((PVOID)&BlSystemMemoryMap.Entry[Index],
; 101  :                             (PVOID)(pb + Index * 20), 20);

  00058	6a 14		 push	 20			; 00000014H
  0005a	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  0005d	6b d2 14	 imul	 edx, 20			; 00000014H
  00060	03 55 f4	 add	 edx, DWORD PTR _pb$3278[ebp]
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  00066	6b c9 18	 imul	 ecx, 24			; 00000018H
  00069	81 c1 00 00 00
	00		 add	 ecx, OFFSET ?BlSystemMemoryMap@@3U_BL_SMAP@@A ; BlSystemMemoryMap
  0006f	e8 00 00 00 00	 call	 ?BlRtlCopyMemory@@YIXPAXPBXK@Z ; BlRtlCopyMemory

; 102  : #if 0
; 103  :             BlVideoPrintf("%4d: %p %p %8x\n",
; 104  :                           Index,
; 105  :                           ((UINT64 *)(pn + 0))[0],
; 106  :                           ((UINT64 *)(pn + 8))[0],
; 107  :                           ((UINT32 *)(pn + 16))[0]);
; 108  : #endif
; 109  :         }

  00074	eb bc		 jmp	 SHORT $LN9@BlSmapInit
$LN8@BlSmapInit:

; 110  :         BlSystemMemoryMap.EntryCount = Index;

  00076	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00079	a3 00 0c 00 00	 mov	 DWORD PTR ?BlSystemMemoryMap@@3U_BL_SMAP@@A+3072, eax

; 111  :     }
; 112  :     else {

  0007e	e9 ce 00 00 00	 jmp	 $LN12@BlSmapInit
$LN11@BlSmapInit:

; 113  :         ULONG_PTR Address;
; 114  :         BL_LEGACY_CALL_CONTEXT Context;
; 115  :         UINT32 ContinuationValue;
; 116  : 
; 117  :         Index = 0;

  00083	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0

; 118  :         ContinuationValue = 0;

  0008a	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _ContinuationValue$3290[ebp], 0
$LN6@BlSmapInit:

; 119  : 
; 120  :         for (;;) {
; 121  : 
; 122  :             BLASSERT(Index < (sizeof(BlSystemMemoryMap.Entry) / sizeof(BlSystemMemoryMap.Entry[0])));

  00091	81 7d fc 80 00
	00 00		 cmp	 DWORD PTR _Index$[ebp], 128 ; 00000080H
  00098	72 0f		 jb	 SHORT $LN4@BlSmapInit
  0009a	ba 7a 00 00 00	 mov	 edx, 122		; 0000007aH
  0009f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@NPJEFNNA@blsmap?4cpp?$AA@
  000a4	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN4@BlSmapInit:

; 123  : 
; 124  :             BlRtlZeroMemory(&Context, sizeof(Context));

  000a9	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
  000ae	8d 4d c0	 lea	 ecx, DWORD PTR _Context$3289[ebp]
  000b1	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 125  : 
; 126  :             Context.eax = 0xE820;

  000b6	c7 45 c0 20 e8
	00 00		 mov	 DWORD PTR _Context$3289[ebp], 59424 ; 0000e820H

; 127  :             Context.edx = 0x534D4150;    // 'SMAP'

  000bd	c7 45 cc 50 41
	4d 53		 mov	 DWORD PTR _Context$3289[ebp+12], 1397571920 ; 534d4150H

; 128  :             Context.ebx = ContinuationValue;

  000c4	8b 4d e8	 mov	 ecx, DWORD PTR _ContinuationValue$3290[ebp]
  000c7	89 4d c4	 mov	 DWORD PTR _Context$3289[ebp+4], ecx

; 129  :             Context.ecx = 20;

  000ca	c7 45 c8 14 00
	00 00		 mov	 DWORD PTR _Context$3289[ebp+8], 20 ; 00000014H

; 130  : 
; 131  :             Address = (ULONG_PTR) &BlSystemMemoryMap.Entry[Index];

  000d1	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  000d4	6b d2 18	 imul	 edx, 24			; 00000018H
  000d7	81 c2 00 00 00
	00		 add	 edx, OFFSET ?BlSystemMemoryMap@@3U_BL_SMAP@@A ; BlSystemMemoryMap
  000dd	89 55 e4	 mov	 DWORD PTR _Address$3288[ebp], edx

; 132  :             Context.es = (UINT32) (Address >> 4);

  000e0	8b 45 e4	 mov	 eax, DWORD PTR _Address$3288[ebp]
  000e3	c1 e8 04	 shr	 eax, 4
  000e6	89 45 dc	 mov	 DWORD PTR _Context$3289[ebp+28], eax

; 133  :             Context.edi = (UINT32) (Address & 0xF);

  000e9	8b 4d e4	 mov	 ecx, DWORD PTR _Address$3288[ebp]
  000ec	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000ef	89 4d d4	 mov	 DWORD PTR _Context$3289[ebp+20], ecx

; 134  : 
; 135  :             BlRtlCallLegacyInterruptService(0x15,
; 136  :                                             &Context,
; 137  :                                             &Context);

  000f2	8d 55 c0	 lea	 edx, DWORD PTR _Context$3289[ebp]
  000f5	52		 push	 edx
  000f6	8d 55 c0	 lea	 edx, DWORD PTR _Context$3289[ebp]
  000f9	b1 15		 mov	 cl, 21			; 00000015H
  000fb	e8 00 00 00 00	 call	 ?BlRtlCallLegacyInterruptService@@YIXEPAU_BL_LEGACY_CALL_CONTEXT@@0@Z ; BlRtlCallLegacyInterruptService

; 138  : 
; 139  :             if (((Context.eflags & RFLAGS_CF) != 0) || (Context.eax != 0x534D4150)) {

  00100	8b 45 e0	 mov	 eax, DWORD PTR _Context$3289[ebp+32]
  00103	83 e0 01	 and	 eax, 1
  00106	75 09		 jne	 SHORT $LN2@BlSmapInit
  00108	81 7d c0 50 41
	4d 53		 cmp	 DWORD PTR _Context$3289[ebp], 1397571920 ; 534d4150H
  0010f	74 1c		 je	 SHORT $LN3@BlSmapInit
$LN2@BlSmapInit:

; 140  : 
; 141  :                 BlRtlPrintf("SMAP: INT 15/E820 failed!\n");

  00111	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MFOMDCLF@SMAP?3?5INT?515?1E820?5failed?$CB?6?$AA@
  00116	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  0011b	83 c4 04	 add	 esp, 4

; 142  :                 BlRtlHalt();

  0011e	ba 8e 00 00 00	 mov	 edx, 142		; 0000008eH
  00123	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@NPJEFNNA@blsmap?4cpp?$AA@
  00128	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN3@BlSmapInit:

; 143  :             }
; 144  : 
; 145  :             Index += 1;

  0012d	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  00130	83 c1 01	 add	 ecx, 1
  00133	89 4d fc	 mov	 DWORD PTR _Index$[ebp], ecx

; 146  : 
; 147  :             ContinuationValue = Context.ebx;

  00136	8b 55 c4	 mov	 edx, DWORD PTR _Context$3289[ebp+4]
  00139	89 55 e8	 mov	 DWORD PTR _ContinuationValue$3290[ebp], edx

; 148  : 
; 149  :             if (ContinuationValue == 0) {

  0013c	83 7d e8 00	 cmp	 DWORD PTR _ContinuationValue$3290[ebp], 0
  00140	75 02		 jne	 SHORT $LN1@BlSmapInit

; 150  : 
; 151  :                 break;

  00142	eb 05		 jmp	 SHORT $LN5@BlSmapInit
$LN1@BlSmapInit:

; 152  :             }
; 153  :         }

  00144	e9 48 ff ff ff	 jmp	 $LN6@BlSmapInit
$LN5@BlSmapInit:

; 154  : 
; 155  :         BlSystemMemoryMap.EntryCount = Index;

  00149	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0014c	a3 00 0c 00 00	 mov	 DWORD PTR ?BlSystemMemoryMap@@3U_BL_SMAP@@A+3072, eax
$LN12@BlSmapInit:

; 156  :     }
; 157  : 
; 158  : #if SMAP_VERBOSE
; 159  : 
; 160  :     BlRtlPrintf("SMAP: %u entries\n", BlSystemMemoryMap.EntryCount);
; 161  : 
; 162  :     for (Index = 0; Index < BlSystemMemoryMap.EntryCount; Index += 1) {
; 163  : 
; 164  :         BlRtlPrintf("SMAP:  %016I64x ... %016I64x %s\n",
; 165  :                     BlSystemMemoryMap.Entry[Index].Base,
; 166  :                     BlSystemMemoryMap.Entry[Index].Base + BlSystemMemoryMap.Entry[Index].Size - 1,
; 167  :                     BlSmapTypeString(BlSystemMemoryMap.Entry[Index].Type));
; 168  :     }
; 169  : 
; 170  : #endif
; 171  : 
; 172  :     return;
; 173  : }

  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c3		 ret	 0
?BlSmapInitialize@@YIXXZ ENDP				; BlSmapInitialize
; Function compile flags: /Odtp
; File d:\oses\verve\verify\src\trusted\bootloader\singldrpc\bl.h
_TEXT	ENDS
;	COMDAT ?BlGetBeb@@YIPAU_BEB@@XZ
_TEXT	SEGMENT
?BlGetBeb@@YIPAU_BEB@@XZ PROC				; BlGetBeb, COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 356  :     return ((PBEB) BEB_BASE);

  00003	b8 00 f0 02 00	 mov	 eax, 192512		; 0002f000H

; 357  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?BlGetBeb@@YIPAU_BEB@@XZ ENDP				; BlGetBeb
_TEXT	ENDS
END
