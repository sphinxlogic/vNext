; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\OSes\VERVE\verify\src\Trusted\BootLoader\SingLdrPc\blkdcom.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BlKdStaticPacket@@3U<unnamed-tag>@@A		; BlKdStaticPacket
PUBLIC	?BlKdComPort@@3EA				; BlKdComPort
_BSS	SEGMENT
?BlKdStaticPacket@@3U<unnamed-tag>@@A DB 01000H DUP (?)	; BlKdStaticPacket
?BlKdComPort@@3EA DB 01H DUP (?)			; BlKdComPort
_BSS	ENDS
PUBLIC	?BlKdComReceiveByte@@YIEPAE@Z			; BlKdComReceiveByte
EXTRN	?BlComReceiveByte@@YIEE@Z:PROC			; BlComReceiveByte
EXTRN	?BlComDataAvailable@@YIEE@Z:PROC		; BlComDataAvailable
; Function compile flags: /Odtp
; File d:\oses\verve\verify\src\trusted\bootloader\singldrpc\blkdcom.cpp
;	COMDAT ?BlKdComReceiveByte@@YIEPAE@Z
_TEXT	SEGMENT
_Byte$ = -8						; size = 4
_Count$ = -4						; size = 4
?BlKdComReceiveByte@@YIEPAE@Z PROC			; BlKdComReceiveByte, COMDAT
; _Byte$ = ecx

; 53   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _Byte$[ebp], ecx

; 54   :     volatile UINT32 Count;
; 55   : 
; 56   :     if (BlKdComPort != 0) {

  00009	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?BlKdComPort@@3EA ; BlKdComPort
  00010	85 c0		 test	 eax, eax
  00012	74 42		 je	 SHORT $LN4@BlKdComRec

; 57   : 
; 58   :         Count = KD_DELAY_LOOP;

  00014	c7 45 fc 00 00
	01 00		 mov	 DWORD PTR _Count$[ebp], 65536 ; 00010000H
$LN3@BlKdComRec:

; 59   : 
; 60   :         while (Count > 0) {

  0001b	83 7d fc 00	 cmp	 DWORD PTR _Count$[ebp], 0
  0001f	76 31		 jbe	 SHORT $LN2@BlKdComRec

; 61   : 
; 62   :             if (BlComDataAvailable(BlKdComPort) != FALSE) {

  00021	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?BlKdComPort@@3EA ; BlKdComPort
  00027	e8 00 00 00 00	 call	 ?BlComDataAvailable@@YIEE@Z ; BlComDataAvailable
  0002c	0f b6 c8	 movzx	 ecx, al
  0002f	85 c9		 test	 ecx, ecx
  00031	74 14		 je	 SHORT $LN1@BlKdComRec

; 63   : 
; 64   :                 *Byte = BlComReceiveByte(BlKdComPort);

  00033	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?BlKdComPort@@3EA ; BlKdComPort
  00039	e8 00 00 00 00	 call	 ?BlComReceiveByte@@YIEE@Z ; BlComReceiveByte
  0003e	8b 55 f8	 mov	 edx, DWORD PTR _Byte$[ebp]
  00041	88 02		 mov	 BYTE PTR [edx], al

; 65   : 
; 66   :                 return TRUE;

  00043	b0 01		 mov	 al, 1
  00045	eb 11		 jmp	 SHORT $LN5@BlKdComRec
$LN1@BlKdComRec:

; 67   :             }
; 68   : 
; 69   :             Count -= 1;

  00047	8b 45 fc	 mov	 eax, DWORD PTR _Count$[ebp]
  0004a	83 e8 01	 sub	 eax, 1
  0004d	89 45 fc	 mov	 DWORD PTR _Count$[ebp], eax

; 70   :         }

  00050	eb c9		 jmp	 SHORT $LN3@BlKdComRec
$LN2@BlKdComRec:

; 71   : 
; 72   : #if KD_VERBOSE
; 73   : 
; 74   :         BlVideoPrintf("KD: Receive timeout!\n");
; 75   : 
; 76   : #endif
; 77   : 
; 78   :         return FALSE;

  00052	32 c0		 xor	 al, al
  00054	eb 02		 jmp	 SHORT $LN5@BlKdComRec
$LN4@BlKdComRec:

; 79   :     }
; 80   : 
; 81   :     return FALSE;

  00056	32 c0		 xor	 al, al
$LN5@BlKdComRec:

; 82   : }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?BlKdComReceiveByte@@YIEPAE@Z ENDP			; BlKdComReceiveByte
_TEXT	ENDS
PUBLIC	?BlKdComSendData@@YIEPBXK@Z			; BlKdComSendData
EXTRN	?BlComSendByte@@YIEEE@Z:PROC			; BlComSendByte
; Function compile flags: /Odtp
;	COMDAT ?BlKdComSendData@@YIEPBXK@Z
_TEXT	SEGMENT
_Length$ = -12						; size = 4
_Buffer$ = -8						; size = 4
_Index$ = -4						; size = 4
?BlKdComSendData@@YIEPBXK@Z PROC			; BlKdComSendData, COMDAT
; _Buffer$ = ecx
; _Length$ = edx

; 109  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 55 f4	 mov	 DWORD PTR _Length$[ebp], edx
  00009	89 4d f8	 mov	 DWORD PTR _Buffer$[ebp], ecx

; 110  :     UINT32 Index;
; 111  : 
; 112  :     for (Index = 0; Index < Length; Index += 1) {

  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0
  00013	eb 09		 jmp	 SHORT $LN4@BlKdComSen
$LN3@BlKdComSen:
  00015	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax
$LN4@BlKdComSen:
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  00021	3b 4d f4	 cmp	 ecx, DWORD PTR _Length$[ebp]
  00024	73 20		 jae	 SHORT $LN2@BlKdComSen

; 113  : 
; 114  :         if (BlComSendByte(BlKdComPort, ((PUINT8) Buffer)[Index]) == FALSE) {

  00026	8b 55 f8	 mov	 edx, DWORD PTR _Buffer$[ebp]
  00029	03 55 fc	 add	 edx, DWORD PTR _Index$[ebp]
  0002c	8a 12		 mov	 dl, BYTE PTR [edx]
  0002e	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?BlKdComPort@@3EA ; BlKdComPort
  00034	e8 00 00 00 00	 call	 ?BlComSendByte@@YIEEE@Z	; BlComSendByte
  00039	0f b6 c0	 movzx	 eax, al
  0003c	85 c0		 test	 eax, eax
  0003e	75 04		 jne	 SHORT $LN1@BlKdComSen

; 115  : 
; 116  :             return FALSE;

  00040	32 c0		 xor	 al, al
  00042	eb 04		 jmp	 SHORT $LN5@BlKdComSen
$LN1@BlKdComSen:

; 117  :         }
; 118  :     }

  00044	eb cf		 jmp	 SHORT $LN3@BlKdComSen
$LN2@BlKdComSen:

; 119  : 
; 120  :     return TRUE;

  00046	b0 01		 mov	 al, 1
$LN5@BlKdComSen:

; 121  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
?BlKdComSendData@@YIEPBXK@Z ENDP			; BlKdComSendData
_TEXT	ENDS
PUBLIC	?BlKdComReceiveData@@YIEPAXK@Z			; BlKdComReceiveData
; Function compile flags: /Odtp
;	COMDAT ?BlKdComReceiveData@@YIEPAXK@Z
_TEXT	SEGMENT
_Length$ = -12						; size = 4
_Buffer$ = -8						; size = 4
_Index$ = -4						; size = 4
?BlKdComReceiveData@@YIEPAXK@Z PROC			; BlKdComReceiveData, COMDAT
; _Buffer$ = ecx
; _Length$ = edx

; 148  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 55 f4	 mov	 DWORD PTR _Length$[ebp], edx
  00009	89 4d f8	 mov	 DWORD PTR _Buffer$[ebp], ecx

; 149  :     UINT32 Index;
; 150  : 
; 151  :     for (Index = 0; Index < Length; Index += 1) {

  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0
  00013	eb 09		 jmp	 SHORT $LN4@BlKdComRec@2
$LN3@BlKdComRec@2:
  00015	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax
$LN4@BlKdComRec@2:
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  00021	3b 4d f4	 cmp	 ecx, DWORD PTR _Length$[ebp]
  00024	73 18		 jae	 SHORT $LN2@BlKdComRec@2

; 152  : 
; 153  :         if (BlKdComReceiveByte(&(((PUINT8) Buffer)[Index])) == FALSE) {

  00026	8b 4d f8	 mov	 ecx, DWORD PTR _Buffer$[ebp]
  00029	03 4d fc	 add	 ecx, DWORD PTR _Index$[ebp]
  0002c	e8 00 00 00 00	 call	 ?BlKdComReceiveByte@@YIEPAE@Z ; BlKdComReceiveByte
  00031	0f b6 d0	 movzx	 edx, al
  00034	85 d2		 test	 edx, edx
  00036	75 04		 jne	 SHORT $LN1@BlKdComRec@2

; 154  : 
; 155  :             return FALSE;

  00038	32 c0		 xor	 al, al
  0003a	eb 04		 jmp	 SHORT $LN5@BlKdComRec@2
$LN1@BlKdComRec@2:

; 156  :         }
; 157  :     }

  0003c	eb d7		 jmp	 SHORT $LN3@BlKdComRec@2
$LN2@BlKdComRec@2:

; 158  : 
; 159  :     return TRUE;

  0003e	b0 01		 mov	 al, 1
$LN5@BlKdComRec@2:

; 160  : }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?BlKdComReceiveData@@YIEPAXK@Z ENDP			; BlKdComReceiveData
_TEXT	ENDS
PUBLIC	?BlKdComSendControlPacket@@YIEGK@Z		; BlKdComSendControlPacket
EXTRN	?BlRtlZeroMemory@@YIXPAXK@Z:PROC		; BlRtlZeroMemory
; Function compile flags: /Odtp
;	COMDAT ?BlKdComSendControlPacket@@YIEGK@Z
_TEXT	SEGMENT
_PacketId$ = -24					; size = 4
_PacketType$ = -20					; size = 2
_Header$ = -16						; size = 16
?BlKdComSendControlPacket@@YIEGK@Z PROC			; BlKdComSendControlPacket, COMDAT
; _PacketType$ = cx
; _PacketId$ = edx

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 55 e8	 mov	 DWORD PTR _PacketId$[ebp], edx
  00009	66 89 4d ec	 mov	 WORD PTR _PacketType$[ebp], cx

; 188  :     KD_PACKET Header;
; 189  : 
; 190  :     BlRtlZeroMemory(&Header, sizeof(Header));

  0000d	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00012	8d 4d f0	 lea	 ecx, DWORD PTR _Header$[ebp]
  00015	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 191  : 
; 192  :     Header.PacketLeader = KD_CONTROL_PACKET_LEADER;

  0001a	c7 45 f0 69 69
	69 69		 mov	 DWORD PTR _Header$[ebp], 1768515945 ; 69696969H

; 193  :     Header.PacketType = PacketType;

  00021	66 8b 45 ec	 mov	 ax, WORD PTR _PacketType$[ebp]
  00025	66 89 45 f4	 mov	 WORD PTR _Header$[ebp+4], ax

; 194  :     Header.PacketId = PacketId;

  00029	8b 4d e8	 mov	 ecx, DWORD PTR _PacketId$[ebp]
  0002c	89 4d f8	 mov	 DWORD PTR _Header$[ebp+8], ecx

; 195  : 
; 196  :     if (BlKdComSendData(&Header, sizeof(Header)) == FALSE) {

  0002f	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00034	8d 4d f0	 lea	 ecx, DWORD PTR _Header$[ebp]
  00037	e8 00 00 00 00	 call	 ?BlKdComSendData@@YIEPBXK@Z ; BlKdComSendData
  0003c	0f b6 d0	 movzx	 edx, al
  0003f	85 d2		 test	 edx, edx
  00041	75 04		 jne	 SHORT $LN1@BlKdComSen@2

; 197  : 
; 198  :         return FALSE;

  00043	32 c0		 xor	 al, al
  00045	eb 02		 jmp	 SHORT $LN2@BlKdComSen@2
$LN1@BlKdComSen@2:

; 199  :     }
; 200  : 
; 201  : #if KD_VERBOSE
; 202  : 
; 203  :     BlVideoPrintf("KD: Sent type %u control packet.\n", PacketType);
; 204  : 
; 205  : #endif
; 206  : 
; 207  :     return TRUE;

  00047	b0 01		 mov	 al, 1
$LN2@BlKdComSen@2:

; 208  : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?BlKdComSendControlPacket@@YIEGK@Z ENDP			; BlKdComSendControlPacket
_TEXT	ENDS
PUBLIC	?BlKdComReceivePacket@@YIEXZ			; BlKdComReceivePacket
; Function compile flags: /Odtp
;	COMDAT ?BlKdComReceivePacket@@YIEXZ
_TEXT	SEGMENT
_Header$ = -8						; size = 4
_TrailingByte$ = -1					; size = 1
?BlKdComReceivePacket@@YIEXZ PROC			; BlKdComReceivePacket, COMDAT

; 228  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 229  :     PKD_PACKET Header;
; 230  :     UINT8 TrailingByte;
; 231  : 
; 232  :     Header = &BlKdStaticPacket.Header;

  00006	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Header$[ebp], OFFSET ?BlKdStaticPacket@@3U<unnamed-tag>@@A ; BlKdStaticPacket
$Retry$3323:

; 233  : 
; 234  : Retry:
; 235  : 
; 236  :     for (;;) {
; 237  : 
; 238  :         if (BlKdComReceiveData(&Header->PacketLeader, sizeof(Header->PacketLeader)) == FALSE) {

  0000d	ba 04 00 00 00	 mov	 edx, 4
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _Header$[ebp]
  00015	e8 00 00 00 00	 call	 ?BlKdComReceiveData@@YIEPAXK@Z ; BlKdComReceiveData
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	85 c0		 test	 eax, eax
  0001f	75 07		 jne	 SHORT $LN12@BlKdComRec@3

; 239  : 
; 240  :             return FALSE;

  00021	32 c0		 xor	 al, al
  00023	e9 ef 00 00 00	 jmp	 $LN15@BlKdComRec@3
$LN12@BlKdComRec@3:

; 241  :         }
; 242  : 
; 243  :         if (Header->PacketLeader == KD_PACKET_LEADER) {

  00028	8b 4d f8	 mov	 ecx, DWORD PTR _Header$[ebp]
  0002b	81 39 30 30 30
	30		 cmp	 DWORD PTR [ecx], 808464432 ; 30303030H
  00031	75 02		 jne	 SHORT $LN11@BlKdComRec@3

; 244  : 
; 245  :             break;

  00033	eb 0f		 jmp	 SHORT $LN13@BlKdComRec@3
$LN11@BlKdComRec@3:

; 246  :         }
; 247  : 
; 248  :         if (Header->PacketLeader == KD_CONTROL_PACKET_LEADER) {

  00035	8b 55 f8	 mov	 edx, DWORD PTR _Header$[ebp]
  00038	81 3a 69 69 69
	69		 cmp	 DWORD PTR [edx], 1768515945 ; 69696969H
  0003e	75 02		 jne	 SHORT $LN10@BlKdComRec@3

; 249  : 
; 250  :             break;

  00040	eb 02		 jmp	 SHORT $LN13@BlKdComRec@3
$LN10@BlKdComRec@3:

; 251  :         }
; 252  :     }

  00042	eb c9		 jmp	 SHORT $Retry$3323
$LN13@BlKdComRec@3:

; 253  : 
; 254  :     if (BlKdComReceiveData(&Header->PacketType, sizeof(Header->PacketType)) == FALSE) {

  00044	8b 4d f8	 mov	 ecx, DWORD PTR _Header$[ebp]
  00047	83 c1 04	 add	 ecx, 4
  0004a	ba 02 00 00 00	 mov	 edx, 2
  0004f	e8 00 00 00 00	 call	 ?BlKdComReceiveData@@YIEPAXK@Z ; BlKdComReceiveData
  00054	0f b6 c0	 movzx	 eax, al
  00057	85 c0		 test	 eax, eax
  00059	75 07		 jne	 SHORT $LN9@BlKdComRec@3

; 255  : 
; 256  :         return FALSE;

  0005b	32 c0		 xor	 al, al
  0005d	e9 b5 00 00 00	 jmp	 $LN15@BlKdComRec@3
$LN9@BlKdComRec@3:

; 257  :     }
; 258  : 
; 259  :     if (BlKdComReceiveData(&Header->ByteCount, sizeof(Header->ByteCount)) == FALSE) {

  00062	8b 4d f8	 mov	 ecx, DWORD PTR _Header$[ebp]
  00065	83 c1 06	 add	 ecx, 6
  00068	ba 02 00 00 00	 mov	 edx, 2
  0006d	e8 00 00 00 00	 call	 ?BlKdComReceiveData@@YIEPAXK@Z ; BlKdComReceiveData
  00072	0f b6 c8	 movzx	 ecx, al
  00075	85 c9		 test	 ecx, ecx
  00077	75 07		 jne	 SHORT $LN8@BlKdComRec@3

; 260  : 
; 261  :         return FALSE;

  00079	32 c0		 xor	 al, al
  0007b	e9 97 00 00 00	 jmp	 $LN15@BlKdComRec@3
$LN8@BlKdComRec@3:

; 262  :     }
; 263  : 
; 264  :     if (BlKdComReceiveData(&Header->PacketId, sizeof(Header->PacketId)) == FALSE) {

  00080	8b 4d f8	 mov	 ecx, DWORD PTR _Header$[ebp]
  00083	83 c1 08	 add	 ecx, 8
  00086	ba 04 00 00 00	 mov	 edx, 4
  0008b	e8 00 00 00 00	 call	 ?BlKdComReceiveData@@YIEPAXK@Z ; BlKdComReceiveData
  00090	0f b6 d0	 movzx	 edx, al
  00093	85 d2		 test	 edx, edx
  00095	75 04		 jne	 SHORT $LN7@BlKdComRec@3

; 265  : 
; 266  :         return FALSE;

  00097	32 c0		 xor	 al, al
  00099	eb 7c		 jmp	 SHORT $LN15@BlKdComRec@3
$LN7@BlKdComRec@3:

; 267  :     }
; 268  : 
; 269  :     if (BlKdComReceiveData(&Header->Checksum, sizeof(Header->Checksum)) == FALSE) {

  0009b	8b 4d f8	 mov	 ecx, DWORD PTR _Header$[ebp]
  0009e	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000a1	ba 04 00 00 00	 mov	 edx, 4
  000a6	e8 00 00 00 00	 call	 ?BlKdComReceiveData@@YIEPAXK@Z ; BlKdComReceiveData
  000ab	0f b6 c0	 movzx	 eax, al
  000ae	85 c0		 test	 eax, eax
  000b0	75 04		 jne	 SHORT $LN6@BlKdComRec@3

; 270  : 
; 271  :         return FALSE;

  000b2	32 c0		 xor	 al, al
  000b4	eb 61		 jmp	 SHORT $LN15@BlKdComRec@3
$LN6@BlKdComRec@3:

; 272  :     }
; 273  : 
; 274  :     if (Header->ByteCount > sizeof(BlKdStaticPacket.Data)) {

  000b6	8b 4d f8	 mov	 ecx, DWORD PTR _Header$[ebp]
  000b9	0f b7 51 06	 movzx	 edx, WORD PTR [ecx+6]
  000bd	81 fa f0 0f 00
	00		 cmp	 edx, 4080		; 00000ff0H
  000c3	76 05		 jbe	 SHORT $LN5@BlKdComRec@3

; 275  : 
; 276  :         goto Retry;

  000c5	e9 43 ff ff ff	 jmp	 $Retry$3323
$LN5@BlKdComRec@3:

; 277  :     }
; 278  : 
; 279  :     if (Header->ByteCount > 0) {

  000ca	8b 45 f8	 mov	 eax, DWORD PTR _Header$[ebp]
  000cd	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  000d1	85 c9		 test	 ecx, ecx
  000d3	7e 40		 jle	 SHORT $LN4@BlKdComRec@3

; 280  : 
; 281  :         if (BlKdComReceiveData(BlKdStaticPacket.Data, Header->ByteCount) == FALSE) {

  000d5	8b 55 f8	 mov	 edx, DWORD PTR _Header$[ebp]
  000d8	0f b7 52 06	 movzx	 edx, WORD PTR [edx+6]
  000dc	b9 10 00 00 00	 mov	 ecx, OFFSET ?BlKdStaticPacket@@3U<unnamed-tag>@@A+16
  000e1	e8 00 00 00 00	 call	 ?BlKdComReceiveData@@YIEPAXK@Z ; BlKdComReceiveData
  000e6	0f b6 c0	 movzx	 eax, al
  000e9	85 c0		 test	 eax, eax
  000eb	75 04		 jne	 SHORT $LN3@BlKdComRec@3

; 282  : 
; 283  :             return FALSE;

  000ed	32 c0		 xor	 al, al
  000ef	eb 26		 jmp	 SHORT $LN15@BlKdComRec@3
$LN3@BlKdComRec@3:

; 284  :         }
; 285  : 
; 286  :         if (BlKdComReceiveByte(&TrailingByte) == FALSE) {

  000f1	8d 4d ff	 lea	 ecx, DWORD PTR _TrailingByte$[ebp]
  000f4	e8 00 00 00 00	 call	 ?BlKdComReceiveByte@@YIEPAE@Z ; BlKdComReceiveByte
  000f9	0f b6 c8	 movzx	 ecx, al
  000fc	85 c9		 test	 ecx, ecx
  000fe	75 04		 jne	 SHORT $LN2@BlKdComRec@3

; 287  : 
; 288  :             return FALSE;

  00100	32 c0		 xor	 al, al
  00102	eb 13		 jmp	 SHORT $LN15@BlKdComRec@3
$LN2@BlKdComRec@3:

; 289  :         }
; 290  : 
; 291  :         if (TrailingByte != KD_PACKET_TRAILING_BYTE) {

  00104	0f b6 55 ff	 movzx	 edx, BYTE PTR _TrailingByte$[ebp]
  00108	81 fa aa 00 00
	00		 cmp	 edx, 170		; 000000aaH
  0010e	74 05		 je	 SHORT $LN4@BlKdComRec@3

; 292  : 
; 293  :             goto Retry;

  00110	e9 f8 fe ff ff	 jmp	 $Retry$3323
$LN4@BlKdComRec@3:

; 294  :         }
; 295  :     }
; 296  : 
; 297  : #if KD_VERBOSE
; 298  : 
; 299  :     BlVideoPrintf("KD: Received type %u packet.\n", Header->PacketType);
; 300  : 
; 301  : #endif
; 302  : 
; 303  :     return TRUE;

  00115	b0 01		 mov	 al, 1
$LN15@BlKdComRec@3:

; 304  : }

  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c3		 ret	 0
?BlKdComReceivePacket@@YIEXZ ENDP			; BlKdComReceivePacket
_TEXT	ENDS
PUBLIC	??_C@_0M@IJFJLPCJ@blkdcom?4cpp?$AA@		; `string'
PUBLIC	?BlKdComSendPacket@@YIEGPBXG0G@Z		; BlKdComSendPacket
EXTRN	?BlKdNextPacketId@@3KA:DWORD			; BlKdNextPacketId
EXTRN	?BlKdComputeChecksum@@YIKPBXK@Z:PROC		; BlKdComputeChecksum
EXTRN	?BlRtlAssertFailed@@YIXPBDK@Z:PROC		; BlRtlAssertFailed
;	COMDAT ??_C@_0M@IJFJLPCJ@blkdcom?4cpp?$AA@
CONST	SEGMENT
??_C@_0M@IJFJLPCJ@blkdcom?4cpp?$AA@ DB 'blkdcom.cpp', 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlKdComSendPacket@@YIEGPBXG0G@Z
_TEXT	SEGMENT
tv147 = -36						; size = 4
_Header$ = -32						; size = 4
_PacketType$ = -28					; size = 2
_Packet$ = -24						; size = 16
_Checksum$ = -8						; size = 4
_ByteCount$ = -4					; size = 2
_HeaderSize$ = 8					; size = 2
_Data$ = 12						; size = 4
_DataSize$ = 16						; size = 2
?BlKdComSendPacket@@YIEGPBXG0G@Z PROC			; BlKdComSendPacket, COMDAT
; _PacketType$ = cx
; _Header$ = edx

; 340  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 55 e0	 mov	 DWORD PTR _Header$[ebp], edx
  00009	66 89 4d e4	 mov	 WORD PTR _PacketType$[ebp], cx

; 341  :     UINT16 ByteCount;
; 342  :     UINT32 Checksum;
; 343  :     KD_PACKET Packet;
; 344  : 
; 345  :     BLASSERT(HeaderSize > 0);

  0000d	0f b7 45 08	 movzx	 eax, WORD PTR _HeaderSize$[ebp]
  00011	85 c0		 test	 eax, eax
  00013	7f 0f		 jg	 SHORT $Resend$3351
  00015	ba 59 01 00 00	 mov	 edx, 345		; 00000159H
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@IJFJLPCJ@blkdcom?4cpp?$AA@
  0001f	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$Resend$3351:

; 346  : 
; 347  : Resend:
; 348  : 
; 349  :     //
; 350  :     // Calculate byte count and checksum.
; 351  :     //
; 352  : 
; 353  :     ByteCount = HeaderSize;

  00024	66 8b 4d 08	 mov	 cx, WORD PTR _HeaderSize$[ebp]
  00028	66 89 4d fc	 mov	 WORD PTR _ByteCount$[ebp], cx

; 354  :     Checksum = BlKdComputeChecksum(Header, HeaderSize);

  0002c	0f b7 55 08	 movzx	 edx, WORD PTR _HeaderSize$[ebp]
  00030	8b 4d e0	 mov	 ecx, DWORD PTR _Header$[ebp]
  00033	e8 00 00 00 00	 call	 ?BlKdComputeChecksum@@YIKPBXK@Z ; BlKdComputeChecksum
  00038	89 45 f8	 mov	 DWORD PTR _Checksum$[ebp], eax

; 355  : 
; 356  :     if (Data != NULL) {

  0003b	83 7d 0c 00	 cmp	 DWORD PTR _Data$[ebp], 0
  0003f	74 37		 je	 SHORT $LN12@BlKdComSen@3

; 357  : 
; 358  :         BLASSERT(DataSize > 0);

  00041	0f b7 55 10	 movzx	 edx, WORD PTR _DataSize$[ebp]
  00045	85 d2		 test	 edx, edx
  00047	7f 0f		 jg	 SHORT $LN11@BlKdComSen@3
  00049	ba 66 01 00 00	 mov	 edx, 358		; 00000166H
  0004e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@IJFJLPCJ@blkdcom?4cpp?$AA@
  00053	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN11@BlKdComSen@3:

; 359  : 
; 360  :         ByteCount = ByteCount + DataSize;

  00058	0f b7 45 fc	 movzx	 eax, WORD PTR _ByteCount$[ebp]
  0005c	0f b7 4d 10	 movzx	 ecx, WORD PTR _DataSize$[ebp]
  00060	03 c1		 add	 eax, ecx
  00062	66 89 45 fc	 mov	 WORD PTR _ByteCount$[ebp], ax

; 361  :         Checksum += BlKdComputeChecksum(Data, DataSize);

  00066	0f b7 55 10	 movzx	 edx, WORD PTR _DataSize$[ebp]
  0006a	8b 4d 0c	 mov	 ecx, DWORD PTR _Data$[ebp]
  0006d	e8 00 00 00 00	 call	 ?BlKdComputeChecksum@@YIKPBXK@Z ; BlKdComputeChecksum
  00072	03 45 f8	 add	 eax, DWORD PTR _Checksum$[ebp]
  00075	89 45 f8	 mov	 DWORD PTR _Checksum$[ebp], eax
$LN12@BlKdComSen@3:

; 362  :     }
; 363  : 
; 364  :     //
; 365  :     // Send packet.
; 366  :     //
; 367  : 
; 368  :     Packet.PacketLeader = KD_PACKET_LEADER;

  00078	c7 45 e8 30 30
	30 30		 mov	 DWORD PTR _Packet$[ebp], 808464432 ; 30303030H

; 369  :     Packet.PacketId = BlKdNextPacketId;

  0007f	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?BlKdNextPacketId@@3KA ; BlKdNextPacketId
  00085	89 55 f0	 mov	 DWORD PTR _Packet$[ebp+8], edx

; 370  :     Packet.PacketType = PacketType;

  00088	66 8b 45 e4	 mov	 ax, WORD PTR _PacketType$[ebp]
  0008c	66 89 45 ec	 mov	 WORD PTR _Packet$[ebp+4], ax

; 371  :     Packet.ByteCount = ByteCount;

  00090	66 8b 4d fc	 mov	 cx, WORD PTR _ByteCount$[ebp]
  00094	66 89 4d ee	 mov	 WORD PTR _Packet$[ebp+6], cx

; 372  :     Packet.Checksum = Checksum;

  00098	8b 55 f8	 mov	 edx, DWORD PTR _Checksum$[ebp]
  0009b	89 55 f4	 mov	 DWORD PTR _Packet$[ebp+12], edx

; 373  : 
; 374  :     if (BlKdComSendData(&Packet, sizeof(Packet)) == FALSE) {

  0009e	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  000a3	8d 4d e8	 lea	 ecx, DWORD PTR _Packet$[ebp]
  000a6	e8 00 00 00 00	 call	 ?BlKdComSendData@@YIEPBXK@Z ; BlKdComSendData
  000ab	0f b6 c0	 movzx	 eax, al
  000ae	85 c0		 test	 eax, eax
  000b0	75 07		 jne	 SHORT $LN10@BlKdComSen@3

; 375  : 
; 376  :         return FALSE;

  000b2	32 c0		 xor	 al, al
  000b4	e9 ac 00 00 00	 jmp	 $LN14@BlKdComSen@3
$LN10@BlKdComSen@3:

; 377  :     }
; 378  : 
; 379  :     if (BlKdComSendData(Header, HeaderSize) == FALSE) {

  000b9	0f b7 55 08	 movzx	 edx, WORD PTR _HeaderSize$[ebp]
  000bd	8b 4d e0	 mov	 ecx, DWORD PTR _Header$[ebp]
  000c0	e8 00 00 00 00	 call	 ?BlKdComSendData@@YIEPBXK@Z ; BlKdComSendData
  000c5	0f b6 c8	 movzx	 ecx, al
  000c8	85 c9		 test	 ecx, ecx
  000ca	75 07		 jne	 SHORT $LN9@BlKdComSen@3

; 380  : 
; 381  :         return FALSE;

  000cc	32 c0		 xor	 al, al
  000ce	e9 92 00 00 00	 jmp	 $LN14@BlKdComSen@3
$LN9@BlKdComSen@3:

; 382  :     }
; 383  : 
; 384  :     if (Data != NULL) {

  000d3	83 7d 0c 00	 cmp	 DWORD PTR _Data$[ebp], 0
  000d7	74 17		 je	 SHORT $LN8@BlKdComSen@3

; 385  : 
; 386  :         if (BlKdComSendData(Data, DataSize) == FALSE) {

  000d9	0f b7 55 10	 movzx	 edx, WORD PTR _DataSize$[ebp]
  000dd	8b 4d 0c	 mov	 ecx, DWORD PTR _Data$[ebp]
  000e0	e8 00 00 00 00	 call	 ?BlKdComSendData@@YIEPBXK@Z ; BlKdComSendData
  000e5	0f b6 d0	 movzx	 edx, al
  000e8	85 d2		 test	 edx, edx
  000ea	75 04		 jne	 SHORT $LN8@BlKdComSen@3

; 387  : 
; 388  :             return FALSE;

  000ec	32 c0		 xor	 al, al
  000ee	eb 75		 jmp	 SHORT $LN14@BlKdComSen@3
$LN8@BlKdComSen@3:

; 389  :         }
; 390  :     }
; 391  : 
; 392  :     if (BlComSendByte(BlKdComPort, KD_PACKET_TRAILING_BYTE) == FALSE) {

  000f0	b2 aa		 mov	 dl, 170			; 000000aaH
  000f2	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?BlKdComPort@@3EA ; BlKdComPort
  000f8	e8 00 00 00 00	 call	 ?BlComSendByte@@YIEEE@Z	; BlComSendByte
  000fd	0f b6 c0	 movzx	 eax, al
  00100	85 c0		 test	 eax, eax
  00102	75 04		 jne	 SHORT $LN6@BlKdComSen@3

; 393  : 
; 394  :         return FALSE;

  00104	32 c0		 xor	 al, al
  00106	eb 5d		 jmp	 SHORT $LN14@BlKdComSen@3
$LN6@BlKdComSen@3:

; 395  :     }
; 396  : 
; 397  : #if KD_VERBOSE
; 398  : 
; 399  :     BlVideoPrintf("KD: Sent type %u packet.\n", Packet.PacketType);
; 400  : 
; 401  : #endif
; 402  : 
; 403  :     //
; 404  :     // Update packet ID.
; 405  :     //
; 406  : 
; 407  :     BlKdNextPacketId &= (~KD_SYNC_PACKET_ID);

  00108	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlKdNextPacketId@@3KA ; BlKdNextPacketId
  0010e	81 e1 ff f7 ff
	ff		 and	 ecx, -2049		; fffff7ffH
  00114	89 0d 00 00 00
	00		 mov	 DWORD PTR ?BlKdNextPacketId@@3KA, ecx ; BlKdNextPacketId

; 408  :     BlKdNextPacketId ^= 1;

  0011a	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?BlKdNextPacketId@@3KA ; BlKdNextPacketId
  00120	83 f2 01	 xor	 edx, 1
  00123	89 15 00 00 00
	00		 mov	 DWORD PTR ?BlKdNextPacketId@@3KA, edx ; BlKdNextPacketId

; 409  : 
; 410  :     if (BlKdComReceivePacket() != FALSE) {

  00129	e8 00 00 00 00	 call	 ?BlKdComReceivePacket@@YIEXZ ; BlKdComReceivePacket
  0012e	0f b6 c0	 movzx	 eax, al
  00131	85 c0		 test	 eax, eax
  00133	74 2e		 je	 SHORT $LN5@BlKdComSen@3

; 411  : 
; 412  :         switch (BlKdStaticPacket.Header.PacketType) {

  00135	0f b7 0d 04 00
	00 00		 movzx	 ecx, WORD PTR ?BlKdStaticPacket@@3U<unnamed-tag>@@A+4
  0013c	89 4d dc	 mov	 DWORD PTR tv147[ebp], ecx
  0013f	83 7d dc 05	 cmp	 DWORD PTR tv147[ebp], 5
  00143	74 19		 je	 SHORT $LN1@BlKdComSen@3
  00145	83 7d dc 06	 cmp	 DWORD PTR tv147[ebp], 6
  00149	74 02		 je	 SHORT $LN2@BlKdComSen@3
  0014b	eb 16		 jmp	 SHORT $LN5@BlKdComSen@3
$LN2@BlKdComSen@3:

; 413  : 
; 414  :             case KD_PACKET_TYPE_KD_RESET: {
; 415  : 
; 416  : #if KD_VERBOSE
; 417  : 
; 418  :                 BlVideoPrintf("KD: Received RESET after send.\n");
; 419  : 
; 420  : #endif
; 421  : 
; 422  :                 BlKdComSendControlPacket(KD_PACKET_TYPE_KD_RESET, 0);

  0014d	33 d2		 xor	 edx, edx
  0014f	b9 06 00 00 00	 mov	 ecx, 6
  00154	e8 00 00 00 00	 call	 ?BlKdComSendControlPacket@@YIEGK@Z ; BlKdComSendControlPacket

; 423  : 
; 424  :                 goto Resend;

  00159	e9 c6 fe ff ff	 jmp	 $Resend$3351
$LN1@BlKdComSen@3:

; 425  :             }
; 426  : 
; 427  :             case KD_PACKET_TYPE_KD_RESEND: {
; 428  : 
; 429  : #if KD_VERBOSE
; 430  : 
; 431  :                 BlVideoPrintf("KD: Received RESEND after send.\n");
; 432  : 
; 433  : #endif
; 434  : 
; 435  :                 goto Resend;

  0015e	e9 c1 fe ff ff	 jmp	 $Resend$3351
$LN5@BlKdComSen@3:

; 436  :             }
; 437  :         }
; 438  :     }
; 439  : 
; 440  :     return TRUE;

  00163	b0 01		 mov	 al, 1
$LN14@BlKdComSen@3:

; 441  : }

  00165	8b e5		 mov	 esp, ebp
  00167	5d		 pop	 ebp
  00168	c2 0c 00	 ret	 12			; 0000000cH
?BlKdComSendPacket@@YIEGPBXG0G@Z ENDP			; BlKdComSendPacket
_TEXT	ENDS
PUBLIC	?BlKdComConnect@@YIEXZ				; BlKdComConnect
EXTRN	?BlComInitialize@@YIEEK@Z:PROC			; BlComInitialize
; Function compile flags: /Odtp
;	COMDAT ?BlKdComConnect@@YIEXZ
_TEXT	SEGMENT
_Retry$ = -16						; size = 4
_Present$ = -12						; size = 5
_Index$ = -1						; size = 1
?BlKdComConnect@@YIEXZ PROC				; BlKdComConnect, COMDAT

; 461  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 462  :     UINT8 Index;
; 463  :     BOOLEAN Present[COM_MAX_PORT + 1];
; 464  :     UINT32 Retry;
; 465  : 
; 466  : 
; 467  :     //
; 468  :     // Find all COM ports on the system.
; 469  :     //
; 470  : 
; 471  :     for (Index = 1; Index <= COM_MAX_PORT; Index += 1) {

  00006	c6 45 ff 01	 mov	 BYTE PTR _Index$[ebp], 1
  0000a	eb 0a		 jmp	 SHORT $LN11@BlKdComCon
$LN10@BlKdComCon:
  0000c	0f b6 45 ff	 movzx	 eax, BYTE PTR _Index$[ebp]
  00010	83 c0 01	 add	 eax, 1
  00013	88 45 ff	 mov	 BYTE PTR _Index$[ebp], al
$LN11@BlKdComCon:
  00016	0f b6 4d ff	 movzx	 ecx, BYTE PTR _Index$[ebp]
  0001a	83 f9 04	 cmp	 ecx, 4
  0001d	7f 17		 jg	 SHORT $LN9@BlKdComCon

; 472  : 
; 473  :         Present[Index] = BlComInitialize(Index, 115200);

  0001f	ba 00 c2 01 00	 mov	 edx, 115200		; 0001c200H
  00024	8a 4d ff	 mov	 cl, BYTE PTR _Index$[ebp]
  00027	e8 00 00 00 00	 call	 ?BlComInitialize@@YIEEK@Z ; BlComInitialize
  0002c	0f b6 55 ff	 movzx	 edx, BYTE PTR _Index$[ebp]
  00030	88 44 15 f4	 mov	 BYTE PTR _Present$[ebp+edx], al

; 474  : 
; 475  : #if KD_VERBOSE
; 476  : 
; 477  :         BlVideoPrintf("KD: COM%u %s\n",
; 478  :                       Index,
; 479  :                       Present[Index] ? "found." : "not found.");
; 480  : 
; 481  : #endif
; 482  : 
; 483  :     }

  00034	eb d6		 jmp	 SHORT $LN10@BlKdComCon
$LN9@BlKdComCon:

; 484  : 
; 485  :     //
; 486  :     // Set initial packet ID.
; 487  :     //
; 488  : 
; 489  :     BlKdNextPacketId = KD_INITIAL_PACKET_ID | KD_SYNC_PACKET_ID;

  00036	c7 05 00 00 00
	00 00 08 80 80	 mov	 DWORD PTR ?BlKdNextPacketId@@3KA, -2139092992 ; BlKdNextPacketId, 80800800H

; 490  : 
; 491  :     for (Retry = 0; Retry < KD_RETRY_COUNT; Retry += 1) {

  00040	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Retry$[ebp], 0
  00047	eb 09		 jmp	 SHORT $LN8@BlKdComCon
$LN7@BlKdComCon:
  00049	8b 45 f0	 mov	 eax, DWORD PTR _Retry$[ebp]
  0004c	83 c0 01	 add	 eax, 1
  0004f	89 45 f0	 mov	 DWORD PTR _Retry$[ebp], eax
$LN8@BlKdComCon:
  00052	83 7d f0 10	 cmp	 DWORD PTR _Retry$[ebp], 16 ; 00000010H
  00056	73 4f		 jae	 SHORT $LN6@BlKdComCon

; 492  : 
; 493  :         for (Index = 1; Index <= COM_MAX_PORT; Index += 1) {

  00058	c6 45 ff 01	 mov	 BYTE PTR _Index$[ebp], 1
  0005c	eb 0a		 jmp	 SHORT $LN5@BlKdComCon
$LN4@BlKdComCon:
  0005e	0f b6 4d ff	 movzx	 ecx, BYTE PTR _Index$[ebp]
  00062	83 c1 01	 add	 ecx, 1
  00065	88 4d ff	 mov	 BYTE PTR _Index$[ebp], cl
$LN5@BlKdComCon:
  00068	0f b6 55 ff	 movzx	 edx, BYTE PTR _Index$[ebp]
  0006c	83 fa 04	 cmp	 edx, 4
  0006f	7f 34		 jg	 SHORT $LN3@BlKdComCon

; 494  : 
; 495  :             if (Present[Index] != FALSE) {

  00071	0f b6 45 ff	 movzx	 eax, BYTE PTR _Index$[ebp]
  00075	0f b6 4c 05 f4	 movzx	 ecx, BYTE PTR _Present$[ebp+eax]
  0007a	85 c9		 test	 ecx, ecx
  0007c	74 25		 je	 SHORT $LN2@BlKdComCon

; 496  : 
; 497  : #if KD_VERBOSE
; 498  : 
; 499  :                 BlVideoPrintf("KD: Trying COM%u ...\n", Index);
; 500  : 
; 501  : #endif
; 502  : 
; 503  :                 BlKdComPort = Index;

  0007e	8a 55 ff	 mov	 dl, BYTE PTR _Index$[ebp]
  00081	88 15 00 00 00
	00		 mov	 BYTE PTR ?BlKdComPort@@3EA, dl ; BlKdComPort

; 504  : 
; 505  :                 BlKdComSendControlPacket(KD_PACKET_TYPE_KD_RESET, 0);

  00087	33 d2		 xor	 edx, edx
  00089	b9 06 00 00 00	 mov	 ecx, 6
  0008e	e8 00 00 00 00	 call	 ?BlKdComSendControlPacket@@YIEGK@Z ; BlKdComSendControlPacket

; 506  : 
; 507  :                 if (BlKdComReceivePacket() != FALSE) {

  00093	e8 00 00 00 00	 call	 ?BlKdComReceivePacket@@YIEXZ ; BlKdComReceivePacket
  00098	0f b6 c0	 movzx	 eax, al
  0009b	85 c0		 test	 eax, eax
  0009d	74 04		 je	 SHORT $LN2@BlKdComCon

; 508  : 
; 509  :                     return TRUE;

  0009f	b0 01		 mov	 al, 1
  000a1	eb 0d		 jmp	 SHORT $LN12@BlKdComCon
$LN2@BlKdComCon:

; 510  :                 }
; 511  :             }
; 512  :         }

  000a3	eb b9		 jmp	 SHORT $LN4@BlKdComCon
$LN3@BlKdComCon:

; 513  :     }

  000a5	eb a2		 jmp	 SHORT $LN7@BlKdComCon
$LN6@BlKdComCon:

; 514  : 
; 515  :     BlKdComPort = 0;

  000a7	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?BlKdComPort@@3EA, 0 ; BlKdComPort

; 516  : 
; 517  :     return FALSE;

  000ae	32 c0		 xor	 al, al
$LN12@BlKdComCon:

; 518  : }

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
?BlKdComConnect@@YIEXZ ENDP				; BlKdComConnect
_TEXT	ENDS
END
