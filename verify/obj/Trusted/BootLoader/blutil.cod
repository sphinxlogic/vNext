; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\OSes\VERVE\verify\src\Trusted\BootLoader\SingLdrPc\blutil.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BlFsReadFile@@3P6IEPBDPAXK@ZA			; BlFsReadFile
PUBLIC	?BlInt13AddressPacket@@3U_INT13_DISK_ADDRESS_PACKET@@A ; BlInt13AddressPacket
PUBLIC	?BlFsGetFileSize@@3P6IEPBDPAK@ZA		; BlFsGetFileSize
_BSS	SEGMENT
?BlFsReadFile@@3P6IEPBDPAXK@ZA DD 01H DUP (?)		; BlFsReadFile
?BlInt13AddressPacket@@3U_INT13_DISK_ADDRESS_PACKET@@A DB 010H DUP (?) ; BlInt13AddressPacket
?BlFsGetFileSize@@3P6IEPBDPAK@ZA DD 01H DUP (?)		; BlFsGetFileSize
_BSS	ENDS
PUBLIC	?BlRtlInitializeListHead@@YIXPAU_LIST_ENTRY@@@Z	; BlRtlInitializeListHead
; Function compile flags: /Odtp
; File d:\oses\verve\verify\src\trusted\bootloader\singldrpc\blutil.cpp
;	COMDAT ?BlRtlInitializeListHead@@YIXPAU_LIST_ENTRY@@@Z
_TEXT	SEGMENT
_Head$ = -4						; size = 4
?BlRtlInitializeListHead@@YIXPAU_LIST_ENTRY@@@Z PROC	; BlRtlInitializeListHead, COMDAT
; _Head$ = ecx

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _Head$[ebp], ecx

; 40   :     Head->Flink = Head->Blink = Head;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _Head$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _Head$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	8b 55 fc	 mov	 edx, DWORD PTR _Head$[ebp]
  00013	8b 45 fc	 mov	 eax, DWORD PTR _Head$[ebp]
  00016	89 02		 mov	 DWORD PTR [edx], eax

; 41   : }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?BlRtlInitializeListHead@@YIXPAU_LIST_ENTRY@@@Z ENDP	; BlRtlInitializeListHead
_TEXT	ENDS
PUBLIC	?BlRtlIsListEmpty@@YIEPAU_LIST_ENTRY@@@Z	; BlRtlIsListEmpty
; Function compile flags: /Odtp
;	COMDAT ?BlRtlIsListEmpty@@YIEPAU_LIST_ENTRY@@@Z
_TEXT	SEGMENT
_Head$ = -4						; size = 4
?BlRtlIsListEmpty@@YIEPAU_LIST_ENTRY@@@Z PROC		; BlRtlIsListEmpty, COMDAT
; _Head$ = ecx

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _Head$[ebp], ecx

; 66   :     return (BOOLEAN) (Head->Flink == Head);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _Head$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	3b 4d fc	 cmp	 ecx, DWORD PTR _Head$[ebp]
  0000f	0f 94 c0	 sete	 al

; 67   : }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?BlRtlIsListEmpty@@YIEPAU_LIST_ENTRY@@@Z ENDP		; BlRtlIsListEmpty
_TEXT	ENDS
PUBLIC	?BlRtlAssertFailed@@YIXPBDK@Z			; BlRtlAssertFailed
PUBLIC	??_C@_0L@IIIBICNN@blutil?4cpp?$AA@		; `string'
PUBLIC	?BlRtlRemoveEntryList@@YIEPAU_LIST_ENTRY@@@Z	; BlRtlRemoveEntryList
;	COMDAT ??_C@_0L@IIIBICNN@blutil?4cpp?$AA@
CONST	SEGMENT
??_C@_0L@IIIBICNN@blutil?4cpp?$AA@ DB 'blutil.cpp', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlRtlRemoveEntryList@@YIEPAU_LIST_ENTRY@@@Z
_TEXT	SEGMENT
_Entry$ = -12						; size = 4
_Blink$ = -8						; size = 4
_Flink$ = -4						; size = 4
?BlRtlRemoveEntryList@@YIEPAU_LIST_ENTRY@@@Z PROC	; BlRtlRemoveEntryList, COMDAT
; _Entry$ = ecx

; 91   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _Entry$[ebp], ecx

; 92   :     PLIST_ENTRY Blink;
; 93   :     PLIST_ENTRY Flink;
; 94   : 
; 95   :     Blink = Entry->Blink;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _Entry$[ebp]
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	89 4d f8	 mov	 DWORD PTR _Blink$[ebp], ecx

; 96   :     Flink = Entry->Flink;

  00012	8b 55 f4	 mov	 edx, DWORD PTR _Entry$[ebp]
  00015	8b 02		 mov	 eax, DWORD PTR [edx]
  00017	89 45 fc	 mov	 DWORD PTR _Flink$[ebp], eax

; 97   : 
; 98   :     BLASSERT(Blink != Entry);

  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _Blink$[ebp]
  0001d	3b 4d f4	 cmp	 ecx, DWORD PTR _Entry$[ebp]
  00020	75 0f		 jne	 SHORT $LN2@BlRtlRemov
  00022	ba 62 00 00 00	 mov	 edx, 98			; 00000062H
  00027	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IIIBICNN@blutil?4cpp?$AA@
  0002c	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN2@BlRtlRemov:

; 99   :     BLASSERT(Flink != Entry);

  00031	8b 55 fc	 mov	 edx, DWORD PTR _Flink$[ebp]
  00034	3b 55 f4	 cmp	 edx, DWORD PTR _Entry$[ebp]
  00037	75 0f		 jne	 SHORT $LN1@BlRtlRemov
  00039	ba 63 00 00 00	 mov	 edx, 99			; 00000063H
  0003e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IIIBICNN@blutil?4cpp?$AA@
  00043	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN1@BlRtlRemov:

; 100  : 
; 101  :     Blink->Flink = Flink;

  00048	8b 45 f8	 mov	 eax, DWORD PTR _Blink$[ebp]
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _Flink$[ebp]
  0004e	89 08		 mov	 DWORD PTR [eax], ecx

; 102  :     Flink->Blink = Blink;

  00050	8b 55 fc	 mov	 edx, DWORD PTR _Flink$[ebp]
  00053	8b 45 f8	 mov	 eax, DWORD PTR _Blink$[ebp]
  00056	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 103  : 
; 104  :     return (BOOLEAN) (Flink == Blink);

  00059	8b 4d fc	 mov	 ecx, DWORD PTR _Flink$[ebp]
  0005c	3b 4d f8	 cmp	 ecx, DWORD PTR _Blink$[ebp]
  0005f	0f 94 c0	 sete	 al

; 105  : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?BlRtlRemoveEntryList@@YIEPAU_LIST_ENTRY@@@Z ENDP	; BlRtlRemoveEntryList
_TEXT	ENDS
PUBLIC	?BlRtlRemoveHeadList@@YIPAU_LIST_ENTRY@@PAU1@@Z	; BlRtlRemoveHeadList
; Function compile flags: /Odtp
;	COMDAT ?BlRtlRemoveHeadList@@YIPAU_LIST_ENTRY@@PAU1@@Z
_TEXT	SEGMENT
_Head$ = -12						; size = 4
_Flink$ = -8						; size = 4
_Entry$ = -4						; size = 4
?BlRtlRemoveHeadList@@YIPAU_LIST_ENTRY@@PAU1@@Z PROC	; BlRtlRemoveHeadList, COMDAT
; _Head$ = ecx

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _Head$[ebp], ecx

; 129  :     PLIST_ENTRY Entry;
; 130  :     PLIST_ENTRY Flink;
; 131  : 
; 132  :     BLASSERT(BlRtlIsListEmpty(Head) == FALSE);

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _Head$[ebp]
  0000c	e8 00 00 00 00	 call	 ?BlRtlIsListEmpty@@YIEPAU_LIST_ENTRY@@@Z ; BlRtlIsListEmpty
  00011	0f b6 c0	 movzx	 eax, al
  00014	85 c0		 test	 eax, eax
  00016	74 0f		 je	 SHORT $LN1@BlRtlRemov@2
  00018	ba 84 00 00 00	 mov	 edx, 132		; 00000084H
  0001d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IIIBICNN@blutil?4cpp?$AA@
  00022	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN1@BlRtlRemov@2:

; 133  : 
; 134  :     Entry = Head->Flink;

  00027	8b 4d f4	 mov	 ecx, DWORD PTR _Head$[ebp]
  0002a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002c	89 55 fc	 mov	 DWORD PTR _Entry$[ebp], edx

; 135  :     Flink = Entry->Flink;

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _Entry$[ebp]
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	89 4d f8	 mov	 DWORD PTR _Flink$[ebp], ecx

; 136  : 
; 137  :     Head->Flink = Flink;

  00037	8b 55 f4	 mov	 edx, DWORD PTR _Head$[ebp]
  0003a	8b 45 f8	 mov	 eax, DWORD PTR _Flink$[ebp]
  0003d	89 02		 mov	 DWORD PTR [edx], eax

; 138  :     Flink->Blink = Head;

  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _Flink$[ebp]
  00042	8b 55 f4	 mov	 edx, DWORD PTR _Head$[ebp]
  00045	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 139  : 
; 140  :     return Entry;

  00048	8b 45 fc	 mov	 eax, DWORD PTR _Entry$[ebp]

; 141  : }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
?BlRtlRemoveHeadList@@YIPAU_LIST_ENTRY@@PAU1@@Z ENDP	; BlRtlRemoveHeadList
_TEXT	ENDS
PUBLIC	?BlRtlRemoveTailList@@YIPAU_LIST_ENTRY@@PAU1@@Z	; BlRtlRemoveTailList
; Function compile flags: /Odtp
;	COMDAT ?BlRtlRemoveTailList@@YIPAU_LIST_ENTRY@@PAU1@@Z
_TEXT	SEGMENT
_Head$ = -12						; size = 4
_Blink$ = -8						; size = 4
_Entry$ = -4						; size = 4
?BlRtlRemoveTailList@@YIPAU_LIST_ENTRY@@PAU1@@Z PROC	; BlRtlRemoveTailList, COMDAT
; _Head$ = ecx

; 164  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _Head$[ebp], ecx

; 165  :     PLIST_ENTRY Blink;
; 166  :     PLIST_ENTRY Entry;
; 167  : 
; 168  :     BLASSERT(BlRtlIsListEmpty(Head) == FALSE);

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _Head$[ebp]
  0000c	e8 00 00 00 00	 call	 ?BlRtlIsListEmpty@@YIEPAU_LIST_ENTRY@@@Z ; BlRtlIsListEmpty
  00011	0f b6 c0	 movzx	 eax, al
  00014	85 c0		 test	 eax, eax
  00016	74 0f		 je	 SHORT $LN1@BlRtlRemov@3
  00018	ba a8 00 00 00	 mov	 edx, 168		; 000000a8H
  0001d	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IIIBICNN@blutil?4cpp?$AA@
  00022	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN1@BlRtlRemov@3:

; 169  : 
; 170  :     Entry = Head->Blink;

  00027	8b 4d f4	 mov	 ecx, DWORD PTR _Head$[ebp]
  0002a	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002d	89 55 fc	 mov	 DWORD PTR _Entry$[ebp], edx

; 171  :     Blink = Entry->Blink;

  00030	8b 45 fc	 mov	 eax, DWORD PTR _Entry$[ebp]
  00033	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00036	89 4d f8	 mov	 DWORD PTR _Blink$[ebp], ecx

; 172  : 
; 173  :     Head->Blink = Blink;

  00039	8b 55 f4	 mov	 edx, DWORD PTR _Head$[ebp]
  0003c	8b 45 f8	 mov	 eax, DWORD PTR _Blink$[ebp]
  0003f	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 174  :     Blink->Flink = Head;

  00042	8b 4d f8	 mov	 ecx, DWORD PTR _Blink$[ebp]
  00045	8b 55 f4	 mov	 edx, DWORD PTR _Head$[ebp]
  00048	89 11		 mov	 DWORD PTR [ecx], edx

; 175  : 
; 176  :     return Entry;

  0004a	8b 45 fc	 mov	 eax, DWORD PTR _Entry$[ebp]

; 177  : }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?BlRtlRemoveTailList@@YIPAU_LIST_ENTRY@@PAU1@@Z ENDP	; BlRtlRemoveTailList
_TEXT	ENDS
PUBLIC	?BlRtlInsertTailList@@YIXPAU_LIST_ENTRY@@0@Z	; BlRtlInsertTailList
; Function compile flags: /Odtp
;	COMDAT ?BlRtlInsertTailList@@YIXPAU_LIST_ENTRY@@0@Z
_TEXT	SEGMENT
_Entry$ = -12						; size = 4
_Head$ = -8						; size = 4
_Blink$ = -4						; size = 4
?BlRtlInsertTailList@@YIXPAU_LIST_ENTRY@@0@Z PROC	; BlRtlInsertTailList, COMDAT
; _Head$ = ecx
; _Entry$ = edx

; 199  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 55 f4	 mov	 DWORD PTR _Entry$[ebp], edx
  00009	89 4d f8	 mov	 DWORD PTR _Head$[ebp], ecx

; 200  :     PLIST_ENTRY Blink;
; 201  : 
; 202  :     Blink = Head->Blink;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR _Head$[ebp]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	89 4d fc	 mov	 DWORD PTR _Blink$[ebp], ecx

; 203  : 
; 204  :     Entry->Flink = Head;

  00015	8b 55 f4	 mov	 edx, DWORD PTR _Entry$[ebp]
  00018	8b 45 f8	 mov	 eax, DWORD PTR _Head$[ebp]
  0001b	89 02		 mov	 DWORD PTR [edx], eax

; 205  :     Entry->Blink = Blink;

  0001d	8b 4d f4	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00020	8b 55 fc	 mov	 edx, DWORD PTR _Blink$[ebp]
  00023	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 206  : 
; 207  :     Head->Blink = Entry;

  00026	8b 45 f8	 mov	 eax, DWORD PTR _Head$[ebp]
  00029	8b 4d f4	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0002c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 208  :     Blink->Flink = Entry;

  0002f	8b 55 fc	 mov	 edx, DWORD PTR _Blink$[ebp]
  00032	8b 45 f4	 mov	 eax, DWORD PTR _Entry$[ebp]
  00035	89 02		 mov	 DWORD PTR [edx], eax

; 209  : }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?BlRtlInsertTailList@@YIXPAU_LIST_ENTRY@@0@Z ENDP	; BlRtlInsertTailList
_TEXT	ENDS
PUBLIC	?BlRtlInsertHeadList@@YIXPAU_LIST_ENTRY@@0@Z	; BlRtlInsertHeadList
; Function compile flags: /Odtp
;	COMDAT ?BlRtlInsertHeadList@@YIXPAU_LIST_ENTRY@@0@Z
_TEXT	SEGMENT
_Entry$ = -12						; size = 4
_Head$ = -8						; size = 4
_Flink$ = -4						; size = 4
?BlRtlInsertHeadList@@YIXPAU_LIST_ENTRY@@0@Z PROC	; BlRtlInsertHeadList, COMDAT
; _Head$ = ecx
; _Entry$ = edx

; 231  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 55 f4	 mov	 DWORD PTR _Entry$[ebp], edx
  00009	89 4d f8	 mov	 DWORD PTR _Head$[ebp], ecx

; 232  :     PLIST_ENTRY Flink;
; 233  : 
; 234  :     Flink = Head->Flink;

  0000c	8b 45 f8	 mov	 eax, DWORD PTR _Head$[ebp]
  0000f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00011	89 4d fc	 mov	 DWORD PTR _Flink$[ebp], ecx

; 235  : 
; 236  :     Entry->Flink = Flink;

  00014	8b 55 f4	 mov	 edx, DWORD PTR _Entry$[ebp]
  00017	8b 45 fc	 mov	 eax, DWORD PTR _Flink$[ebp]
  0001a	89 02		 mov	 DWORD PTR [edx], eax

; 237  :     Entry->Blink = Head;

  0001c	8b 4d f4	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0001f	8b 55 f8	 mov	 edx, DWORD PTR _Head$[ebp]
  00022	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 238  : 
; 239  :     Head->Flink = Entry;

  00025	8b 45 f8	 mov	 eax, DWORD PTR _Head$[ebp]
  00028	8b 4d f4	 mov	 ecx, DWORD PTR _Entry$[ebp]
  0002b	89 08		 mov	 DWORD PTR [eax], ecx

; 240  :     Flink->Blink = Entry;

  0002d	8b 55 fc	 mov	 edx, DWORD PTR _Flink$[ebp]
  00030	8b 45 f4	 mov	 eax, DWORD PTR _Entry$[ebp]
  00033	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 241  : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?BlRtlInsertHeadList@@YIXPAU_LIST_ENTRY@@0@Z ENDP	; BlRtlInsertHeadList
_TEXT	ENDS
PUBLIC	?BlRtlConvertLinearPointerToFarPointer@@YIXPAXPAU_FAR_POINTER@@@Z ; BlRtlConvertLinearPointerToFarPointer
; Function compile flags: /Odtp
;	COMDAT ?BlRtlConvertLinearPointerToFarPointer@@YIXPAXPAU_FAR_POINTER@@@Z
_TEXT	SEGMENT
_FarPointer$ = -8					; size = 4
_LinearPointer$ = -4					; size = 4
?BlRtlConvertLinearPointerToFarPointer@@YIXPAXPAU_FAR_POINTER@@@Z PROC ; BlRtlConvertLinearPointerToFarPointer, COMDAT
; _LinearPointer$ = ecx
; _FarPointer$ = edx

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 55 f8	 mov	 DWORD PTR _FarPointer$[ebp], edx
  00009	89 4d fc	 mov	 DWORD PTR _LinearPointer$[ebp], ecx

; 264  :     BLASSERT((ULONG_PTR) LinearPointer < LEGACY_MEMORY_LIMIT);

  0000c	81 7d fc 00 00
	10 00		 cmp	 DWORD PTR _LinearPointer$[ebp], 1048576 ; 00100000H
  00013	72 0f		 jb	 SHORT $LN1@BlRtlConve
  00015	ba 08 01 00 00	 mov	 edx, 264		; 00000108H
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IIIBICNN@blutil?4cpp?$AA@
  0001f	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN1@BlRtlConve:

; 265  : 
; 266  :     FarPointer->Segment = (UINT16) (((ULONG_PTR) LinearPointer) >> 4);

  00024	8b 45 fc	 mov	 eax, DWORD PTR _LinearPointer$[ebp]
  00027	c1 e8 04	 shr	 eax, 4
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _FarPointer$[ebp]
  0002d	66 89 41 02	 mov	 WORD PTR [ecx+2], ax

; 267  :     FarPointer->Offset = (((UINT16) (ULONG_PTR) LinearPointer) & 0xF);

  00031	0f b7 55 fc	 movzx	 edx, WORD PTR _LinearPointer$[ebp]
  00035	83 e2 0f	 and	 edx, 15			; 0000000fH
  00038	8b 45 f8	 mov	 eax, DWORD PTR _FarPointer$[ebp]
  0003b	66 89 10	 mov	 WORD PTR [eax], dx

; 268  : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?BlRtlConvertLinearPointerToFarPointer@@YIXPAXPAU_FAR_POINTER@@@Z ENDP ; BlRtlConvertLinearPointerToFarPointer
_TEXT	ENDS
PUBLIC	?BlRtlConvertFarPointerToLinearPointer@@YIPAXPAU_FAR_POINTER@@@Z ; BlRtlConvertFarPointerToLinearPointer
; Function compile flags: /Odtp
;	COMDAT ?BlRtlConvertFarPointerToLinearPointer@@YIPAXPAU_FAR_POINTER@@@Z
_TEXT	SEGMENT
_FarPointer$ = -4					; size = 4
?BlRtlConvertFarPointerToLinearPointer@@YIPAXPAU_FAR_POINTER@@@Z PROC ; BlRtlConvertFarPointerToLinearPointer, COMDAT
; _FarPointer$ = ecx

; 291  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _FarPointer$[ebp], ecx

; 292  : 
; 293  :     return (PVOID) (((ULONG_PTR) FarPointer->Segment << 4) + ((ULONG_PTR) FarPointer->Offset));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _FarPointer$[ebp]
  0000a	0f b7 40 02	 movzx	 eax, WORD PTR [eax+2]
  0000e	c1 e0 04	 shl	 eax, 4
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _FarPointer$[ebp]
  00014	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00017	03 c2		 add	 eax, edx

; 294  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?BlRtlConvertFarPointerToLinearPointer@@YIPAXPAU_FAR_POINTER@@@Z ENDP ; BlRtlConvertFarPointerToLinearPointer
_TEXT	ENDS
PUBLIC	?BlRtlZeroMemory@@YIXPAXK@Z			; BlRtlZeroMemory
; Function compile flags: /Odtp
;	COMDAT ?BlRtlZeroMemory@@YIXPAXK@Z
_TEXT	SEGMENT
_Length$ = -16						; size = 4
_Buffer$ = -12						; size = 4
_Next$ = -8						; size = 4
_Limit$ = -4						; size = 4
?BlRtlZeroMemory@@YIXPAXK@Z PROC			; BlRtlZeroMemory, COMDAT
; _Buffer$ = ecx
; _Length$ = edx

; 316  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 55 f0	 mov	 DWORD PTR _Length$[ebp], edx
  00009	89 4d f4	 mov	 DWORD PTR _Buffer$[ebp], ecx

; 317  :     PUINT8 Limit;
; 318  :     PUINT8 Next;
; 319  : 
; 320  :     Next = (PUINT8) Buffer;

  0000c	8b 45 f4	 mov	 eax, DWORD PTR _Buffer$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR _Next$[ebp], eax

; 321  :     Limit = Next + Length;

  00012	8b 4d f8	 mov	 ecx, DWORD PTR _Next$[ebp]
  00015	03 4d f0	 add	 ecx, DWORD PTR _Length$[ebp]
  00018	89 4d fc	 mov	 DWORD PTR _Limit$[ebp], ecx
$LN2@BlRtlZeroM:

; 322  : 
; 323  :     while (Next < Limit) {

  0001b	8b 55 f8	 mov	 edx, DWORD PTR _Next$[ebp]
  0001e	3b 55 fc	 cmp	 edx, DWORD PTR _Limit$[ebp]
  00021	73 11		 jae	 SHORT $LN3@BlRtlZeroM

; 324  : 
; 325  :         *Next = 0;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _Next$[ebp]
  00026	c6 00 00	 mov	 BYTE PTR [eax], 0

; 326  :         Next += 1;

  00029	8b 4d f8	 mov	 ecx, DWORD PTR _Next$[ebp]
  0002c	83 c1 01	 add	 ecx, 1
  0002f	89 4d f8	 mov	 DWORD PTR _Next$[ebp], ecx

; 327  :     }

  00032	eb e7		 jmp	 SHORT $LN2@BlRtlZeroM
$LN3@BlRtlZeroM:

; 328  : }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?BlRtlZeroMemory@@YIXPAXK@Z ENDP			; BlRtlZeroMemory
_TEXT	ENDS
PUBLIC	?BlRtlCopyMemory@@YIXPAXPBXK@Z			; BlRtlCopyMemory
; Function compile flags: /Odtp
;	COMDAT ?BlRtlCopyMemory@@YIXPAXPBXK@Z
_TEXT	SEGMENT
_Source$ = -28						; size = 4
_Destination$ = -24					; size = 4
_SourceEnd$ = -20					; size = 4
_DestinationStart$ = -16				; size = 4
_SourceStart$ = -12					; size = 4
_DestinationEnd$ = -8					; size = 4
_Index$ = -4						; size = 4
_Length$ = 8						; size = 4
?BlRtlCopyMemory@@YIXPAXPBXK@Z PROC			; BlRtlCopyMemory, COMDAT
; _Destination$ = ecx
; _Source$ = edx

; 353  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 55 e4	 mov	 DWORD PTR _Source$[ebp], edx
  00009	89 4d e8	 mov	 DWORD PTR _Destination$[ebp], ecx

; 354  :     ULONG_PTR DestinationEnd;
; 355  :     ULONG_PTR DestinationStart;
; 356  :     ULONG_PTR Index;
; 357  :     ULONG_PTR SourceEnd;
; 358  :     ULONG_PTR SourceStart;
; 359  : 
; 360  :     if (Length == 0) {

  0000c	83 7d 08 00	 cmp	 DWORD PTR _Length$[ebp], 0
  00010	75 05		 jne	 SHORT $LN9@BlRtlCopyM

; 361  : 
; 362  :         return;

  00012	e9 81 00 00 00	 jmp	 $LN10@BlRtlCopyM
$LN9@BlRtlCopyM:

; 363  :     }
; 364  : 
; 365  :     SourceStart = (ULONG_PTR) Source;

  00017	8b 45 e4	 mov	 eax, DWORD PTR _Source$[ebp]
  0001a	89 45 f4	 mov	 DWORD PTR _SourceStart$[ebp], eax

; 366  :     SourceEnd = SourceStart + Length;

  0001d	8b 4d f4	 mov	 ecx, DWORD PTR _SourceStart$[ebp]
  00020	03 4d 08	 add	 ecx, DWORD PTR _Length$[ebp]
  00023	89 4d ec	 mov	 DWORD PTR _SourceEnd$[ebp], ecx

; 367  :     DestinationStart = (ULONG_PTR) Destination;

  00026	8b 55 e8	 mov	 edx, DWORD PTR _Destination$[ebp]
  00029	89 55 f0	 mov	 DWORD PTR _DestinationStart$[ebp], edx

; 368  :     DestinationEnd = DestinationStart + Length;

  0002c	8b 45 f0	 mov	 eax, DWORD PTR _DestinationStart$[ebp]
  0002f	03 45 08	 add	 eax, DWORD PTR _Length$[ebp]
  00032	89 45 f8	 mov	 DWORD PTR _DestinationEnd$[ebp], eax

; 369  : 
; 370  :     //
; 371  :     // If the higher part of the source buffer intersects with the destination
; 372  :     // buffer, then perform a reverse copy. Otherwise, perform a regular copy.
; 373  :     //
; 374  : 
; 375  :     if ((SourceStart < DestinationStart) && (SourceEnd > DestinationStart)) {

  00035	8b 4d f4	 mov	 ecx, DWORD PTR _SourceStart$[ebp]
  00038	3b 4d f0	 cmp	 ecx, DWORD PTR _DestinationStart$[ebp]
  0003b	73 2f		 jae	 SHORT $LN8@BlRtlCopyM
  0003d	8b 55 ec	 mov	 edx, DWORD PTR _SourceEnd$[ebp]
  00040	3b 55 f0	 cmp	 edx, DWORD PTR _DestinationStart$[ebp]
  00043	76 27		 jbe	 SHORT $LN8@BlRtlCopyM

; 376  : 
; 377  :         Index = Length;

  00045	8b 45 08	 mov	 eax, DWORD PTR _Length$[ebp]
  00048	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax
$LN7@BlRtlCopyM:

; 378  : 
; 379  :         do {
; 380  : 
; 381  :             Index -= 1;

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  0004e	83 e9 01	 sub	 ecx, 1
  00051	89 4d fc	 mov	 DWORD PTR _Index$[ebp], ecx

; 382  : 
; 383  :             ((PUINT8) Destination)[Index] = ((PUINT8) Source)[Index];

  00054	8b 55 e8	 mov	 edx, DWORD PTR _Destination$[ebp]
  00057	03 55 fc	 add	 edx, DWORD PTR _Index$[ebp]
  0005a	8b 45 e4	 mov	 eax, DWORD PTR _Source$[ebp]
  0005d	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  00060	8a 08		 mov	 cl, BYTE PTR [eax]
  00062	88 0a		 mov	 BYTE PTR [edx], cl

; 384  : 
; 385  :         } while (Index > 0);

  00064	83 7d fc 00	 cmp	 DWORD PTR _Index$[ebp], 0
  00068	77 e1		 ja	 SHORT $LN7@BlRtlCopyM

; 386  : 
; 387  :     } else {

  0006a	eb 2c		 jmp	 SHORT $LN10@BlRtlCopyM
$LN8@BlRtlCopyM:

; 388  : 
; 389  :         for (Index = 0; Index < Length; Index += 1) {

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0
  00073	eb 09		 jmp	 SHORT $LN3@BlRtlCopyM
$LN2@BlRtlCopyM:
  00075	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  00078	83 c2 01	 add	 edx, 1
  0007b	89 55 fc	 mov	 DWORD PTR _Index$[ebp], edx
$LN3@BlRtlCopyM:
  0007e	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00081	3b 45 08	 cmp	 eax, DWORD PTR _Length$[ebp]
  00084	73 12		 jae	 SHORT $LN10@BlRtlCopyM

; 390  : 
; 391  :             ((PUINT8) Destination)[Index] = ((PUINT8) Source)[Index];

  00086	8b 4d e8	 mov	 ecx, DWORD PTR _Destination$[ebp]
  00089	03 4d fc	 add	 ecx, DWORD PTR _Index$[ebp]
  0008c	8b 55 e4	 mov	 edx, DWORD PTR _Source$[ebp]
  0008f	03 55 fc	 add	 edx, DWORD PTR _Index$[ebp]
  00092	8a 02		 mov	 al, BYTE PTR [edx]
  00094	88 01		 mov	 BYTE PTR [ecx], al

; 392  :         }

  00096	eb dd		 jmp	 SHORT $LN2@BlRtlCopyM
$LN10@BlRtlCopyM:

; 393  :     }
; 394  : }

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 04 00	 ret	 4
?BlRtlCopyMemory@@YIXPAXPBXK@Z ENDP			; BlRtlCopyMemory
_TEXT	ENDS
PUBLIC	?BlRtlCompareMemory@@YIEPBX0K@Z			; BlRtlCompareMemory
; Function compile flags: /Odtp
;	COMDAT ?BlRtlCompareMemory@@YIEPBX0K@Z
_TEXT	SEGMENT
_Buffer2$ = -12						; size = 4
_Buffer1$ = -8						; size = 4
_Index$ = -4						; size = 4
_Length$ = 8						; size = 4
?BlRtlCompareMemory@@YIEPBX0K@Z PROC			; BlRtlCompareMemory, COMDAT
; _Buffer1$ = ecx
; _Buffer2$ = edx

; 424  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 55 f4	 mov	 DWORD PTR _Buffer2$[ebp], edx
  00009	89 4d f8	 mov	 DWORD PTR _Buffer1$[ebp], ecx

; 425  :     ULONG_PTR Index;
; 426  : 
; 427  :     for (Index = 0; Index < Length; Index += 1) {

  0000c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0
  00013	eb 09		 jmp	 SHORT $LN4@BlRtlCompa
$LN3@BlRtlCompa:
  00015	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00018	83 c0 01	 add	 eax, 1
  0001b	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax
$LN4@BlRtlCompa:
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  00021	3b 4d 08	 cmp	 ecx, DWORD PTR _Length$[ebp]
  00024	73 1c		 jae	 SHORT $LN2@BlRtlCompa

; 428  : 
; 429  :         if (((PUINT8) Buffer1)[Index] != ((PUINT8) Buffer2)[Index]) {

  00026	8b 55 f8	 mov	 edx, DWORD PTR _Buffer1$[ebp]
  00029	03 55 fc	 add	 edx, DWORD PTR _Index$[ebp]
  0002c	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0002f	8b 4d f4	 mov	 ecx, DWORD PTR _Buffer2$[ebp]
  00032	03 4d fc	 add	 ecx, DWORD PTR _Index$[ebp]
  00035	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00038	3b c2		 cmp	 eax, edx
  0003a	74 04		 je	 SHORT $LN1@BlRtlCompa

; 430  : 
; 431  :             return FALSE;

  0003c	32 c0		 xor	 al, al
  0003e	eb 04		 jmp	 SHORT $LN5@BlRtlCompa
$LN1@BlRtlCompa:

; 432  :         }
; 433  :     }

  00040	eb d3		 jmp	 SHORT $LN3@BlRtlCompa
$LN2@BlRtlCompa:

; 434  : 
; 435  :     return TRUE;

  00042	b0 01		 mov	 al, 1
$LN5@BlRtlCompa:

; 436  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?BlRtlCompareMemory@@YIEPBX0K@Z ENDP			; BlRtlCompareMemory
_TEXT	ENDS
PUBLIC	?BlRtlMakeLegacyCall@@YIXXZ			; BlRtlMakeLegacyCall
EXTRN	?BlMmEnableA20Gate@@YIXXZ:PROC			; BlMmEnableA20Gate
EXTRN	?BlReturnToLegacyMode@@YIXXZ:PROC		; BlReturnToLegacyMode
; Function compile flags: /Odtp
;	COMDAT ?BlRtlMakeLegacyCall@@YIXXZ
_TEXT	SEGMENT
?BlRtlMakeLegacyCall@@YIXXZ PROC			; BlRtlMakeLegacyCall, COMDAT

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 453  :     //
; 454  :     // Return to legacy mode.
; 455  :     //
; 456  : 
; 457  :     BlReturnToLegacyMode();

  00003	e8 00 00 00 00	 call	 ?BlReturnToLegacyMode@@YIXXZ ; BlReturnToLegacyMode

; 458  : 
; 459  :     //
; 460  :     // Re-enable A20 gate -- this is absolutely necessary, because some
; 461  :     // legacy calls (such as some PXE implementations) modify A20 state.
; 462  :     //
; 463  : 
; 464  :     BlMmEnableA20Gate();

  00008	e8 00 00 00 00	 call	 ?BlMmEnableA20Gate@@YIXXZ ; BlMmEnableA20Gate

; 465  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?BlRtlMakeLegacyCall@@YIXXZ ENDP			; BlRtlMakeLegacyCall
_TEXT	ENDS
PUBLIC	?BlGetBeb@@YIPAU_BEB@@XZ			; BlGetBeb
PUBLIC	?BlRtlCallLegacyInterruptService@@YIXEPAU_BL_LEGACY_CALL_CONTEXT@@0@Z ; BlRtlCallLegacyInterruptService
; Function compile flags: /Odtp
;	COMDAT ?BlRtlCallLegacyInterruptService@@YIXEPAU_BL_LEGACY_CALL_CONTEXT@@0@Z
_TEXT	SEGMENT
_Input$ = -12						; size = 4
_Vector$ = -8						; size = 1
_Beb$ = -4						; size = 4
_Output$ = 8						; size = 4
?BlRtlCallLegacyInterruptService@@YIXEPAU_BL_LEGACY_CALL_CONTEXT@@0@Z PROC ; BlRtlCallLegacyInterruptService, COMDAT
; _Vector$ = cl
; _Input$ = edx

; 490  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 55 f4	 mov	 DWORD PTR _Input$[ebp], edx
  00009	88 4d f8	 mov	 BYTE PTR _Vector$[ebp], cl

; 491  :     PBEB Beb;
; 492  : 
; 493  :     Beb = BlGetBeb();

  0000c	e8 00 00 00 00	 call	 ?BlGetBeb@@YIPAU_BEB@@XZ ; BlGetBeb
  00011	89 45 fc	 mov	 DWORD PTR _Beb$[ebp], eax

; 494  : 
; 495  :     Beb->LegacyCall_OpCode = LC_INTXX;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  00017	c7 40 20 01 00
	00 00		 mov	 DWORD PTR [eax+32], 1

; 496  :     Beb->LegacyCall_Vector = Vector;

  0001e	0f b6 4d f8	 movzx	 ecx, BYTE PTR _Vector$[ebp]
  00022	8b 55 fc	 mov	 edx, DWORD PTR _Beb$[ebp]
  00025	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 497  :     Beb->LegacyCall_ax = Input->eax;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  0002b	8b 4d f4	 mov	 ecx, DWORD PTR _Input$[ebp]
  0002e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00030	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 498  :     Beb->LegacyCall_bx = Input->ebx;

  00033	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  00036	8b 4d f4	 mov	 ecx, DWORD PTR _Input$[ebp]
  00039	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003c	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 499  :     Beb->LegacyCall_cx = Input->ecx;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  00042	8b 4d f4	 mov	 ecx, DWORD PTR _Input$[ebp]
  00045	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00048	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 500  :     Beb->LegacyCall_dx = Input->edx;

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR _Input$[ebp]
  00051	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00054	89 50 34	 mov	 DWORD PTR [eax+52], edx

; 501  :     Beb->LegacyCall_si = Input->esi;

  00057	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR _Input$[ebp]
  0005d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00060	89 50 38	 mov	 DWORD PTR [eax+56], edx

; 502  :     Beb->LegacyCall_di = Input->edi;

  00063	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  00066	8b 4d f4	 mov	 ecx, DWORD PTR _Input$[ebp]
  00069	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0006c	89 50 3c	 mov	 DWORD PTR [eax+60], edx

; 503  :     Beb->LegacyCall_ds = Input->ds;

  0006f	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  00072	8b 4d f4	 mov	 ecx, DWORD PTR _Input$[ebp]
  00075	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00078	89 50 40	 mov	 DWORD PTR [eax+64], edx

; 504  :     Beb->LegacyCall_es = Input->es;

  0007b	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  0007e	8b 4d f4	 mov	 ecx, DWORD PTR _Input$[ebp]
  00081	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00084	89 50 44	 mov	 DWORD PTR [eax+68], edx

; 505  : 
; 506  :     BlRtlMakeLegacyCall();

  00087	e8 00 00 00 00	 call	 ?BlRtlMakeLegacyCall@@YIXXZ ; BlRtlMakeLegacyCall

; 507  : 
; 508  :     Output->eax = Beb->LegacyCall_ax;

  0008c	8b 45 08	 mov	 eax, DWORD PTR _Output$[ebp]
  0008f	8b 4d fc	 mov	 ecx, DWORD PTR _Beb$[ebp]
  00092	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00095	89 10		 mov	 DWORD PTR [eax], edx

; 509  :     Output->ebx = Beb->LegacyCall_bx;

  00097	8b 45 08	 mov	 eax, DWORD PTR _Output$[ebp]
  0009a	8b 4d fc	 mov	 ecx, DWORD PTR _Beb$[ebp]
  0009d	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  000a0	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 510  :     Output->ecx = Beb->LegacyCall_cx;

  000a3	8b 45 08	 mov	 eax, DWORD PTR _Output$[ebp]
  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _Beb$[ebp]
  000a9	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  000ac	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 511  :     Output->edx = Beb->LegacyCall_dx;

  000af	8b 45 08	 mov	 eax, DWORD PTR _Output$[ebp]
  000b2	8b 4d fc	 mov	 ecx, DWORD PTR _Beb$[ebp]
  000b5	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000b8	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 512  :     Output->esi = Beb->LegacyCall_si;

  000bb	8b 45 08	 mov	 eax, DWORD PTR _Output$[ebp]
  000be	8b 4d fc	 mov	 ecx, DWORD PTR _Beb$[ebp]
  000c1	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  000c4	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 513  :     Output->edi = Beb->LegacyCall_di;

  000c7	8b 45 08	 mov	 eax, DWORD PTR _Output$[ebp]
  000ca	8b 4d fc	 mov	 ecx, DWORD PTR _Beb$[ebp]
  000cd	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  000d0	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 514  :     Output->ds = Beb->LegacyCall_ds;

  000d3	8b 45 08	 mov	 eax, DWORD PTR _Output$[ebp]
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR _Beb$[ebp]
  000d9	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  000dc	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 515  :     Output->es = Beb->LegacyCall_es;

  000df	8b 45 08	 mov	 eax, DWORD PTR _Output$[ebp]
  000e2	8b 4d fc	 mov	 ecx, DWORD PTR _Beb$[ebp]
  000e5	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  000e8	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 516  :     Output->eflags = Beb->LegacyCall_flags;

  000eb	8b 45 08	 mov	 eax, DWORD PTR _Output$[ebp]
  000ee	8b 4d fc	 mov	 ecx, DWORD PTR _Beb$[ebp]
  000f1	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  000f4	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 517  : }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 04 00	 ret	 4
?BlRtlCallLegacyInterruptService@@YIXEPAU_BL_LEGACY_CALL_CONTEXT@@0@Z ENDP ; BlRtlCallLegacyInterruptService
; Function compile flags: /Odtp
; File d:\oses\verve\verify\src\trusted\bootloader\singldrpc\bl.h
_TEXT	ENDS
;	COMDAT ?BlGetBeb@@YIPAU_BEB@@XZ
_TEXT	SEGMENT
?BlGetBeb@@YIPAU_BEB@@XZ PROC				; BlGetBeb, COMDAT

; 355  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 356  :     return ((PBEB) BEB_BASE);

  00003	b8 00 f0 02 00	 mov	 eax, 192512		; 0002f000H

; 357  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?BlGetBeb@@YIPAU_BEB@@XZ ENDP				; BlGetBeb
_TEXT	ENDS
PUBLIC	?BlRtlCallLegacyFunction@@YIXGGPAXKPAU_BL_LEGACY_CALL_CONTEXT@@1@Z ; BlRtlCallLegacyFunction
; Function compile flags: /Odtp
; File d:\oses\verve\verify\src\trusted\bootloader\singldrpc\blutil.cpp
;	COMDAT ?BlRtlCallLegacyFunction@@YIXGGPAXKPAU_BL_LEGACY_CALL_CONTEXT@@1@Z
_TEXT	SEGMENT
_CodeOffset16$ = -12					; size = 2
_CodeSegment16$ = -8					; size = 2
_Beb$ = -4						; size = 4
_CallFrame$ = 8						; size = 4
_CallFrameSize$ = 12					; size = 4
_Input$ = 16						; size = 4
_Output$ = 20						; size = 4
?BlRtlCallLegacyFunction@@YIXGGPAXKPAU_BL_LEGACY_CALL_CONTEXT@@1@Z PROC ; BlRtlCallLegacyFunction, COMDAT
; _CodeSegment16$ = cx
; _CodeOffset16$ = dx

; 551  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	66 89 55 f4	 mov	 WORD PTR _CodeOffset16$[ebp], dx
  0000a	66 89 4d f8	 mov	 WORD PTR _CodeSegment16$[ebp], cx

; 552  :     PBEB Beb;
; 553  : 
; 554  :     BLASSERT((ULONG_PTR) CallFrame < LEGACY_MEMORY_LIMIT);

  0000e	81 7d 08 00 00
	10 00		 cmp	 DWORD PTR _CallFrame$[ebp], 1048576 ; 00100000H
  00015	72 0f		 jb	 SHORT $LN2@BlRtlCallL
  00017	ba 2a 02 00 00	 mov	 edx, 554		; 0000022aH
  0001c	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IIIBICNN@blutil?4cpp?$AA@
  00021	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN2@BlRtlCallL:

; 555  : 
; 556  :     BLASSERT(((ULONG_PTR) CallFrame + CallFrameSize) < LEGACY_MEMORY_LIMIT);

  00026	8b 45 08	 mov	 eax, DWORD PTR _CallFrame$[ebp]
  00029	03 45 0c	 add	 eax, DWORD PTR _CallFrameSize$[ebp]
  0002c	3d 00 00 10 00	 cmp	 eax, 1048576		; 00100000H
  00031	72 0f		 jb	 SHORT $LN1@BlRtlCallL
  00033	ba 2c 02 00 00	 mov	 edx, 556		; 0000022cH
  00038	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IIIBICNN@blutil?4cpp?$AA@
  0003d	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN1@BlRtlCallL:

; 557  : 
; 558  :     Beb = BlGetBeb();

  00042	e8 00 00 00 00	 call	 ?BlGetBeb@@YIPAU_BEB@@XZ ; BlGetBeb
  00047	89 45 fc	 mov	 DWORD PTR _Beb$[ebp], eax

; 559  : 
; 560  :     Beb->LegacyCall_OpCode = LC_FARCALL;

  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _Beb$[ebp]
  0004d	c7 41 20 02 00
	00 00		 mov	 DWORD PTR [ecx+32], 2

; 561  :     Beb->LegacyCall_FuncPtr.Segment = CodeSegment16;

  00054	8b 55 fc	 mov	 edx, DWORD PTR _Beb$[ebp]
  00057	66 8b 45 f8	 mov	 ax, WORD PTR _CodeSegment16$[ebp]
  0005b	66 89 42 56	 mov	 WORD PTR [edx+86], ax

; 562  :     Beb->LegacyCall_FuncPtr.Offset = CodeOffset16;

  0005f	8b 4d fc	 mov	 ecx, DWORD PTR _Beb$[ebp]
  00062	66 8b 55 f4	 mov	 dx, WORD PTR _CodeOffset16$[ebp]
  00066	66 89 51 54	 mov	 WORD PTR [ecx+84], dx

; 563  :     BlRtlConvertLinearPointerToFarPointer(CallFrame, &Beb->LegacyCall_FramePtr);

  0006a	8b 55 fc	 mov	 edx, DWORD PTR _Beb$[ebp]
  0006d	83 c2 4c	 add	 edx, 76			; 0000004cH
  00070	8b 4d 08	 mov	 ecx, DWORD PTR _CallFrame$[ebp]
  00073	e8 00 00 00 00	 call	 ?BlRtlConvertLinearPointerToFarPointer@@YIXPAXPAU_FAR_POINTER@@@Z ; BlRtlConvertLinearPointerToFarPointer

; 564  :     Beb->LegacyCall_FrameSize = CallFrameSize;

  00078	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  0007b	8b 4d 0c	 mov	 ecx, DWORD PTR _CallFrameSize$[ebp]
  0007e	89 48 50	 mov	 DWORD PTR [eax+80], ecx

; 565  :     Beb->LegacyCall_ax = Input->eax;

  00081	8b 55 fc	 mov	 edx, DWORD PTR _Beb$[ebp]
  00084	8b 45 10	 mov	 eax, DWORD PTR _Input$[ebp]
  00087	8b 08		 mov	 ecx, DWORD PTR [eax]
  00089	89 4a 28	 mov	 DWORD PTR [edx+40], ecx

; 566  :     Beb->LegacyCall_bx = Input->ebx;

  0008c	8b 55 fc	 mov	 edx, DWORD PTR _Beb$[ebp]
  0008f	8b 45 10	 mov	 eax, DWORD PTR _Input$[ebp]
  00092	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00095	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 567  :     Beb->LegacyCall_cx = Input->ecx;

  00098	8b 55 fc	 mov	 edx, DWORD PTR _Beb$[ebp]
  0009b	8b 45 10	 mov	 eax, DWORD PTR _Input$[ebp]
  0009e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000a1	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 568  :     Beb->LegacyCall_dx = Input->edx;

  000a4	8b 55 fc	 mov	 edx, DWORD PTR _Beb$[ebp]
  000a7	8b 45 10	 mov	 eax, DWORD PTR _Input$[ebp]
  000aa	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000ad	89 4a 34	 mov	 DWORD PTR [edx+52], ecx

; 569  :     Beb->LegacyCall_si = Input->esi;

  000b0	8b 55 fc	 mov	 edx, DWORD PTR _Beb$[ebp]
  000b3	8b 45 10	 mov	 eax, DWORD PTR _Input$[ebp]
  000b6	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000b9	89 4a 38	 mov	 DWORD PTR [edx+56], ecx

; 570  :     Beb->LegacyCall_di = Input->edi;

  000bc	8b 55 fc	 mov	 edx, DWORD PTR _Beb$[ebp]
  000bf	8b 45 10	 mov	 eax, DWORD PTR _Input$[ebp]
  000c2	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000c5	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 571  :     Beb->LegacyCall_ds = Input->ds;

  000c8	8b 55 fc	 mov	 edx, DWORD PTR _Beb$[ebp]
  000cb	8b 45 10	 mov	 eax, DWORD PTR _Input$[ebp]
  000ce	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  000d1	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 572  :     Beb->LegacyCall_es = Input->es;

  000d4	8b 55 fc	 mov	 edx, DWORD PTR _Beb$[ebp]
  000d7	8b 45 10	 mov	 eax, DWORD PTR _Input$[ebp]
  000da	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000dd	89 4a 44	 mov	 DWORD PTR [edx+68], ecx

; 573  : 
; 574  :     BlRtlMakeLegacyCall();

  000e0	e8 00 00 00 00	 call	 ?BlRtlMakeLegacyCall@@YIXXZ ; BlRtlMakeLegacyCall

; 575  : 
; 576  :     Output->eax = Beb->LegacyCall_ax;

  000e5	8b 55 14	 mov	 edx, DWORD PTR _Output$[ebp]
  000e8	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  000eb	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000ee	89 0a		 mov	 DWORD PTR [edx], ecx

; 577  :     Output->ebx = Beb->LegacyCall_bx;

  000f0	8b 55 14	 mov	 edx, DWORD PTR _Output$[ebp]
  000f3	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  000f6	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  000f9	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 578  :     Output->ecx = Beb->LegacyCall_cx;

  000fc	8b 55 14	 mov	 edx, DWORD PTR _Output$[ebp]
  000ff	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  00102	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  00105	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 579  :     Output->edx = Beb->LegacyCall_dx;

  00108	8b 55 14	 mov	 edx, DWORD PTR _Output$[ebp]
  0010b	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  0010e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00111	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 580  :     Output->esi = Beb->LegacyCall_si;

  00114	8b 55 14	 mov	 edx, DWORD PTR _Output$[ebp]
  00117	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  0011a	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0011d	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 581  :     Output->edi = Beb->LegacyCall_di;

  00120	8b 55 14	 mov	 edx, DWORD PTR _Output$[ebp]
  00123	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  00126	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00129	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 582  :     Output->ds = Beb->LegacyCall_ds;

  0012c	8b 55 14	 mov	 edx, DWORD PTR _Output$[ebp]
  0012f	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  00132	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00135	89 4a 18	 mov	 DWORD PTR [edx+24], ecx

; 583  :     Output->es = Beb->LegacyCall_es;

  00138	8b 55 14	 mov	 edx, DWORD PTR _Output$[ebp]
  0013b	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  0013e	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00141	89 4a 1c	 mov	 DWORD PTR [edx+28], ecx

; 584  :     Output->eflags = Beb->LegacyCall_flags;

  00144	8b 55 14	 mov	 edx, DWORD PTR _Output$[ebp]
  00147	8b 45 fc	 mov	 eax, DWORD PTR _Beb$[ebp]
  0014a	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0014d	89 4a 20	 mov	 DWORD PTR [edx+32], ecx

; 585  : }

  00150	8b e5		 mov	 esp, ebp
  00152	5d		 pop	 ebp
  00153	c2 10 00	 ret	 16			; 00000010H
?BlRtlCallLegacyFunction@@YIXGGPAXKPAU_BL_LEGACY_CALL_CONTEXT@@1@Z ENDP ; BlRtlCallLegacyFunction
_TEXT	ENDS
PUBLIC	??_C@_0BC@HFDKJDBG@BL?3?5Halt?$CB?5?$CFs?$CI?$CFd?$CJ?6?$AA@ ; `string'
PUBLIC	?BlRtlHaltInternal@@YIXPBDK@Z			; BlRtlHaltInternal
EXTRN	?BlRtlPrintf@@YAEPBDZZ:PROC			; BlRtlPrintf
;	COMDAT ??_C@_0BC@HFDKJDBG@BL?3?5Halt?$CB?5?$CFs?$CI?$CFd?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BC@HFDKJDBG@BL?3?5Halt?$CB?5?$CFs?$CI?$CFd?$CJ?6?$AA@ DB 'BL: Halt'
	DB	'! %s(%d)', 0aH, 00H				; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlRtlHaltInternal@@YIXPBDK@Z
_TEXT	SEGMENT
_LineNumber$ = -8					; size = 4
_FileName$ = -4						; size = 4
?BlRtlHaltInternal@@YIXPBDK@Z PROC			; BlRtlHaltInternal, COMDAT
; _FileName$ = ecx
; _LineNumber$ = edx

; 607  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 55 f8	 mov	 DWORD PTR _LineNumber$[ebp], edx
  00009	89 4d fc	 mov	 DWORD PTR _FileName$[ebp], ecx

; 608  :     BlRtlPrintf("BL: Halt! %s(%d)\n", FileName, LineNumber);

  0000c	8b 45 f8	 mov	 eax, DWORD PTR _LineNumber$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _FileName$[ebp]
  00013	51		 push	 ecx
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@HFDKJDBG@BL?3?5Halt?$CB?5?$CFs?$CI?$CFd?$CJ?6?$AA@
  00019	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  0001e	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@BlRtlHaltI:

; 609  : 
; 610  :     for (;;) {
; 611  :         ;
; 612  :     }

  00021	eb fe		 jmp	 SHORT $LN2@BlRtlHaltI

; 613  : }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?BlRtlHaltInternal@@YIXPBDK@Z ENDP			; BlRtlHaltInternal
_TEXT	ENDS
PUBLIC	??_C@_0CA@MFMJIBJG@BL?3?5Assert?5failed?$CB?5?$CFs?$CI?$CFd?$CJ?5?$CI?$CFp?$CJ?6?$AA@ ; `string'
PUBLIC	?BlRtlAssertFailedPtr@@YIXPBDKK@Z		; BlRtlAssertFailedPtr
;	COMDAT ??_C@_0CA@MFMJIBJG@BL?3?5Assert?5failed?$CB?5?$CFs?$CI?$CFd?$CJ?5?$CI?$CFp?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0CA@MFMJIBJG@BL?3?5Assert?5failed?$CB?5?$CFs?$CI?$CFd?$CJ?5?$CI?$CFp?$CJ?6?$AA@ DB 'B'
	DB	'L: Assert failed! %s(%d) (%p)', 0aH, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlRtlAssertFailedPtr@@YIXPBDKK@Z
_TEXT	SEGMENT
_LineNumber$ = -8					; size = 4
_FileName$ = -4						; size = 4
_Param$ = 8						; size = 4
?BlRtlAssertFailedPtr@@YIXPBDKK@Z PROC			; BlRtlAssertFailedPtr, COMDAT
; _FileName$ = ecx
; _LineNumber$ = edx

; 636  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 55 f8	 mov	 DWORD PTR _LineNumber$[ebp], edx
  00009	89 4d fc	 mov	 DWORD PTR _FileName$[ebp], ecx

; 637  :     BlRtlPrintf("BL: Assert failed! %s(%d) (%p)\n", FileName, LineNumber, Param);

  0000c	8b 45 08	 mov	 eax, DWORD PTR _Param$[ebp]
  0000f	50		 push	 eax
  00010	8b 4d f8	 mov	 ecx, DWORD PTR _LineNumber$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 fc	 mov	 edx, DWORD PTR _FileName$[ebp]
  00017	52		 push	 edx
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@MFMJIBJG@BL?3?5Assert?5failed?$CB?5?$CFs?$CI?$CFd?$CJ?5?$CI?$CFp?$CJ?6?$AA@
  0001d	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00022	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@BlRtlAsser:

; 638  : 
; 639  :     for (;;) {
; 640  :         ;
; 641  :     }

  00025	eb fe		 jmp	 SHORT $LN2@BlRtlAsser

; 642  : }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?BlRtlAssertFailedPtr@@YIXPBDKK@Z ENDP			; BlRtlAssertFailedPtr
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?BlRtlAssertFailed@@YIXPBDK@Z
_TEXT	SEGMENT
_LineNumber$ = -8					; size = 4
_FileName$ = -4						; size = 4
?BlRtlAssertFailed@@YIXPBDK@Z PROC			; BlRtlAssertFailed, COMDAT
; _FileName$ = ecx
; _LineNumber$ = edx

; 664  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 55 f8	 mov	 DWORD PTR _LineNumber$[ebp], edx
  00009	89 4d fc	 mov	 DWORD PTR _FileName$[ebp], ecx

; 665  :     BlRtlAssertFailedPtr(FileName, LineNumber, 0);

  0000c	6a 00		 push	 0
  0000e	8b 55 f8	 mov	 edx, DWORD PTR _LineNumber$[ebp]
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _FileName$[ebp]
  00014	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr

; 666  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?BlRtlAssertFailed@@YIXPBDK@Z ENDP			; BlRtlAssertFailed
_TEXT	ENDS
PUBLIC	?BlRtlComputeChecksum8@@YIEPBXK@Z		; BlRtlComputeChecksum8
; Function compile flags: /Odtp
;	COMDAT ?BlRtlComputeChecksum8@@YIEPBXK@Z
_TEXT	SEGMENT
_Size$ = -16						; size = 4
_Buffer$ = -12						; size = 4
_Checksum$ = -5						; size = 1
_Index$ = -4						; size = 4
?BlRtlComputeChecksum8@@YIEPBXK@Z PROC			; BlRtlComputeChecksum8, COMDAT
; _Buffer$ = ecx
; _Size$ = edx

; 692  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 55 f0	 mov	 DWORD PTR _Size$[ebp], edx
  00009	89 4d f4	 mov	 DWORD PTR _Buffer$[ebp], ecx

; 693  :     UINT8 Checksum;
; 694  :     UINT32 Index;
; 695  : 
; 696  :     Checksum = 0;

  0000c	c6 45 fb 00	 mov	 BYTE PTR _Checksum$[ebp], 0

; 697  : 
; 698  :     for (Index = 0; Index < Size; Index += 1) {

  00010	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN3@BlRtlCompu
$LN2@BlRtlCompu:
  00019	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax
$LN3@BlRtlCompu:
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  00025	3b 4d f0	 cmp	 ecx, DWORD PTR _Size$[ebp]
  00028	73 14		 jae	 SHORT $LN1@BlRtlCompu

; 699  : 
; 700  :         Checksum = Checksum + ((PUINT8) Buffer)[Index];

  0002a	0f b6 55 fb	 movzx	 edx, BYTE PTR _Checksum$[ebp]
  0002e	8b 45 f4	 mov	 eax, DWORD PTR _Buffer$[ebp]
  00031	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  00034	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00037	03 d1		 add	 edx, ecx
  00039	88 55 fb	 mov	 BYTE PTR _Checksum$[ebp], dl

; 701  :     }

  0003c	eb db		 jmp	 SHORT $LN2@BlRtlCompu
$LN1@BlRtlCompu:

; 702  : 
; 703  :     return Checksum;

  0003e	8a 45 fb	 mov	 al, BYTE PTR _Checksum$[ebp]

; 704  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
?BlRtlComputeChecksum8@@YIEPBXK@Z ENDP			; BlRtlComputeChecksum8
_TEXT	ENDS
PUBLIC	?BlRtlGetDriveParameters@@YIEEPAU_INT13_DRIVE_PARAMETERS@@@Z ; BlRtlGetDriveParameters
; Function compile flags: /Odtp
;	COMDAT ?BlRtlGetDriveParameters@@YIEEPAU_INT13_DRIVE_PARAMETERS@@@Z
_TEXT	SEGMENT
_DriveParameters$ = -48					; size = 4
_DriveId$ = -44						; size = 1
_Context$ = -40						; size = 36
_FarPointer$ = -4					; size = 4
?BlRtlGetDriveParameters@@YIEEPAU_INT13_DRIVE_PARAMETERS@@@Z PROC ; BlRtlGetDriveParameters, COMDAT
; _DriveId$ = cl
; _DriveParameters$ = edx

; 731  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 55 d0	 mov	 DWORD PTR _DriveParameters$[ebp], edx
  00009	88 4d d4	 mov	 BYTE PTR _DriveId$[ebp], cl

; 732  :     BL_LEGACY_CALL_CONTEXT Context;
; 733  :     FAR_POINTER FarPointer;
; 734  : 
; 735  :     BlRtlZeroMemory(DriveParameters, sizeof(INT13_DRIVE_PARAMETERS));

  0000c	ba 1a 00 00 00	 mov	 edx, 26			; 0000001aH
  00011	8b 4d d0	 mov	 ecx, DWORD PTR _DriveParameters$[ebp]
  00014	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 736  : 
; 737  :     DriveParameters->StructureSize = sizeof(INT13_DRIVE_PARAMETERS);

  00019	8b 45 d0	 mov	 eax, DWORD PTR _DriveParameters$[ebp]
  0001c	66 c7 00 1a 00	 mov	 WORD PTR [eax], 26	; 0000001aH

; 738  : 
; 739  :     BlRtlConvertLinearPointerToFarPointer(DriveParameters, &FarPointer);

  00021	8d 55 fc	 lea	 edx, DWORD PTR _FarPointer$[ebp]
  00024	8b 4d d0	 mov	 ecx, DWORD PTR _DriveParameters$[ebp]
  00027	e8 00 00 00 00	 call	 ?BlRtlConvertLinearPointerToFarPointer@@YIXPAXPAU_FAR_POINTER@@@Z ; BlRtlConvertLinearPointerToFarPointer

; 740  : 
; 741  :     BlRtlZeroMemory(&Context, sizeof(Context));

  0002c	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
  00031	8d 4d d8	 lea	 ecx, DWORD PTR _Context$[ebp]
  00034	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 742  : 
; 743  :     Context.eax = 0x4800;

  00039	c7 45 d8 00 48
	00 00		 mov	 DWORD PTR _Context$[ebp], 18432 ; 00004800H

; 744  :     Context.edx = DriveId;

  00040	0f b6 4d d4	 movzx	 ecx, BYTE PTR _DriveId$[ebp]
  00044	89 4d e4	 mov	 DWORD PTR _Context$[ebp+12], ecx

; 745  :     Context.ds = FarPointer.Segment;

  00047	0f b7 55 fe	 movzx	 edx, WORD PTR _FarPointer$[ebp+2]
  0004b	89 55 f0	 mov	 DWORD PTR _Context$[ebp+24], edx

; 746  :     Context.esi = FarPointer.Offset;

  0004e	0f b7 45 fc	 movzx	 eax, WORD PTR _FarPointer$[ebp]
  00052	89 45 e8	 mov	 DWORD PTR _Context$[ebp+16], eax

; 747  : 
; 748  :     BlRtlCallLegacyInterruptService(0x13,
; 749  :                                     &Context,
; 750  :                                     &Context);

  00055	8d 4d d8	 lea	 ecx, DWORD PTR _Context$[ebp]
  00058	51		 push	 ecx
  00059	8d 55 d8	 lea	 edx, DWORD PTR _Context$[ebp]
  0005c	b1 13		 mov	 cl, 19			; 00000013H
  0005e	e8 00 00 00 00	 call	 ?BlRtlCallLegacyInterruptService@@YIXEPAU_BL_LEGACY_CALL_CONTEXT@@0@Z ; BlRtlCallLegacyInterruptService

; 751  : 
; 752  :     if (((Context.eflags & RFLAGS_CF) != 0) || ((Context.eax & 0xFF00) != 0)) {

  00063	8b 55 f8	 mov	 edx, DWORD PTR _Context$[ebp+32]
  00066	83 e2 01	 and	 edx, 1
  00069	75 0a		 jne	 SHORT $LN1@BlRtlGetDr
  0006b	8b 45 d8	 mov	 eax, DWORD PTR _Context$[ebp]
  0006e	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00073	74 04		 je	 SHORT $LN2@BlRtlGetDr
$LN1@BlRtlGetDr:

; 753  : 
; 754  :         return FALSE;

  00075	32 c0		 xor	 al, al
  00077	eb 02		 jmp	 SHORT $LN3@BlRtlGetDr
$LN2@BlRtlGetDr:

; 755  :     }
; 756  : 
; 757  :     return TRUE;

  00079	b0 01		 mov	 al, 1
$LN3@BlRtlGetDr:

; 758  : }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?BlRtlGetDriveParameters@@YIEEPAU_INT13_DRIVE_PARAMETERS@@@Z ENDP ; BlRtlGetDriveParameters
_TEXT	ENDS
PUBLIC	?BlRtlReadDrive@@YIEE_KGPAX@Z			; BlRtlReadDrive
; Function compile flags: /Odtp
;	COMDAT ?BlRtlReadDrive@@YIEE_KGPAX@Z
_TEXT	SEGMENT
_NumberOfBlocks$ = -48					; size = 2
_DriveId$ = -44						; size = 1
_AddressPacketPointer$ = -40				; size = 4
_Context$ = -36						; size = 36
_FirstBlock$ = 8					; size = 8
_Buffer$ = 16						; size = 4
?BlRtlReadDrive@@YIEE_KGPAX@Z PROC			; BlRtlReadDrive, COMDAT
; _DriveId$ = cl
; _NumberOfBlocks$ = dx

; 807  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	66 89 55 d0	 mov	 WORD PTR _NumberOfBlocks$[ebp], dx
  0000a	88 4d d4	 mov	 BYTE PTR _DriveId$[ebp], cl

; 808  :     FAR_POINTER AddressPacketPointer;
; 809  :     BL_LEGACY_CALL_CONTEXT Context;
; 810  : 
; 811  :     BlRtlZeroMemory(&BlInt13AddressPacket, sizeof(BlInt13AddressPacket));

  0000d	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  00012	b9 00 00 00 00	 mov	 ecx, OFFSET ?BlInt13AddressPacket@@3U_INT13_DISK_ADDRESS_PACKET@@A ; BlInt13AddressPacket
  00017	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 812  :     BlRtlZeroMemory(&Context, sizeof(Context));

  0001c	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
  00021	8d 4d dc	 lea	 ecx, DWORD PTR _Context$[ebp]
  00024	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 813  : 
; 814  :     BLASSERT(((ULONG_PTR) &BlInt13AddressPacket) < LEGACY_MEMORY_LIMIT);

  00029	b8 00 00 00 00	 mov	 eax, OFFSET ?BlInt13AddressPacket@@3U_INT13_DISK_ADDRESS_PACKET@@A ; BlInt13AddressPacket
  0002e	3d 00 00 10 00	 cmp	 eax, 1048576		; 00100000H
  00033	72 0f		 jb	 SHORT $LN4@BlRtlReadD
  00035	ba 2e 03 00 00	 mov	 edx, 814		; 0000032eH
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IIIBICNN@blutil?4cpp?$AA@
  0003f	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN4@BlRtlReadD:

; 815  :     BLASSERT((ULONG_PTR) Buffer < LEGACY_MEMORY_LIMIT);

  00044	81 7d 10 00 00
	10 00		 cmp	 DWORD PTR _Buffer$[ebp], 1048576 ; 00100000H
  0004b	72 0f		 jb	 SHORT $LN3@BlRtlReadD
  0004d	ba 2f 03 00 00	 mov	 edx, 815		; 0000032fH
  00052	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IIIBICNN@blutil?4cpp?$AA@
  00057	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN3@BlRtlReadD:

; 816  : 
; 817  :     BlInt13AddressPacket.PacketSize = sizeof(BlInt13AddressPacket);

  0005c	c6 05 00 00 00
	00 10		 mov	 BYTE PTR ?BlInt13AddressPacket@@3U_INT13_DISK_ADDRESS_PACKET@@A, 16 ; 00000010H

; 818  :     BlInt13AddressPacket.FirstBlock = FirstBlock;

  00063	8b 4d 08	 mov	 ecx, DWORD PTR _FirstBlock$[ebp]
  00066	89 0d 08 00 00
	00		 mov	 DWORD PTR ?BlInt13AddressPacket@@3U_INT13_DISK_ADDRESS_PACKET@@A+8, ecx
  0006c	8b 55 0c	 mov	 edx, DWORD PTR _FirstBlock$[ebp+4]
  0006f	89 15 0c 00 00
	00		 mov	 DWORD PTR ?BlInt13AddressPacket@@3U_INT13_DISK_ADDRESS_PACKET@@A+12, edx

; 819  :     BlInt13AddressPacket.NumberOfBlocks = NumberOfBlocks;

  00075	66 8b 45 d0	 mov	 ax, WORD PTR _NumberOfBlocks$[ebp]
  00079	66 a3 02 00 00
	00		 mov	 WORD PTR ?BlInt13AddressPacket@@3U_INT13_DISK_ADDRESS_PACKET@@A+2, ax

; 820  :     BlRtlConvertLinearPointerToFarPointer(Buffer, &BlInt13AddressPacket.Buffer);

  0007f	ba 04 00 00 00	 mov	 edx, OFFSET ?BlInt13AddressPacket@@3U_INT13_DISK_ADDRESS_PACKET@@A+4
  00084	8b 4d 10	 mov	 ecx, DWORD PTR _Buffer$[ebp]
  00087	e8 00 00 00 00	 call	 ?BlRtlConvertLinearPointerToFarPointer@@YIXPAXPAU_FAR_POINTER@@@Z ; BlRtlConvertLinearPointerToFarPointer

; 821  : 
; 822  :     BlRtlConvertLinearPointerToFarPointer(&BlInt13AddressPacket, &AddressPacketPointer);

  0008c	8d 55 d8	 lea	 edx, DWORD PTR _AddressPacketPointer$[ebp]
  0008f	b9 00 00 00 00	 mov	 ecx, OFFSET ?BlInt13AddressPacket@@3U_INT13_DISK_ADDRESS_PACKET@@A ; BlInt13AddressPacket
  00094	e8 00 00 00 00	 call	 ?BlRtlConvertLinearPointerToFarPointer@@YIXPAXPAU_FAR_POINTER@@@Z ; BlRtlConvertLinearPointerToFarPointer

; 823  : 
; 824  :     Context.eax = 0x4200;

  00099	c7 45 dc 00 42
	00 00		 mov	 DWORD PTR _Context$[ebp], 16896 ; 00004200H

; 825  :     Context.edx = DriveId;

  000a0	0f b6 4d d4	 movzx	 ecx, BYTE PTR _DriveId$[ebp]
  000a4	89 4d e8	 mov	 DWORD PTR _Context$[ebp+12], ecx

; 826  :     Context.ds = AddressPacketPointer.Segment;

  000a7	0f b7 55 da	 movzx	 edx, WORD PTR _AddressPacketPointer$[ebp+2]
  000ab	89 55 f4	 mov	 DWORD PTR _Context$[ebp+24], edx

; 827  :     Context.esi = AddressPacketPointer.Offset;

  000ae	0f b7 45 d8	 movzx	 eax, WORD PTR _AddressPacketPointer$[ebp]
  000b2	89 45 ec	 mov	 DWORD PTR _Context$[ebp+16], eax

; 828  : 
; 829  :     BlRtlCallLegacyInterruptService(0x13,
; 830  :                                     &Context,
; 831  :                                     &Context);

  000b5	8d 4d dc	 lea	 ecx, DWORD PTR _Context$[ebp]
  000b8	51		 push	 ecx
  000b9	8d 55 dc	 lea	 edx, DWORD PTR _Context$[ebp]
  000bc	b1 13		 mov	 cl, 19			; 00000013H
  000be	e8 00 00 00 00	 call	 ?BlRtlCallLegacyInterruptService@@YIXEPAU_BL_LEGACY_CALL_CONTEXT@@0@Z ; BlRtlCallLegacyInterruptService

; 832  : 
; 833  :     if (((Context.eflags & RFLAGS_CF) != 0) || ((Context.eax & 0xFF00) != 0)) {

  000c3	8b 55 fc	 mov	 edx, DWORD PTR _Context$[ebp+32]
  000c6	83 e2 01	 and	 edx, 1
  000c9	75 0a		 jne	 SHORT $LN1@BlRtlReadD
  000cb	8b 45 dc	 mov	 eax, DWORD PTR _Context$[ebp]
  000ce	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  000d3	74 04		 je	 SHORT $LN2@BlRtlReadD
$LN1@BlRtlReadD:

; 834  : 
; 835  :         return FALSE;

  000d5	32 c0		 xor	 al, al
  000d7	eb 02		 jmp	 SHORT $LN5@BlRtlReadD
$LN2@BlRtlReadD:

; 836  :     }
; 837  : 
; 838  :     return TRUE;

  000d9	b0 01		 mov	 al, 1
$LN5@BlRtlReadD:

; 839  : }

  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c2 0c 00	 ret	 12			; 0000000cH
?BlRtlReadDrive@@YIEE_KGPAX@Z ENDP			; BlRtlReadDrive
_TEXT	ENDS
PUBLIC	?BlCmosReadRegister@@YIEE@Z			; BlCmosReadRegister
EXTRN	?BlRtlReadPort8@@YIEG@Z:PROC			; BlRtlReadPort8
EXTRN	?BlRtlWritePort8@@YIXGE@Z:PROC			; BlRtlWritePort8
; Function compile flags: /Odtp
;	COMDAT ?BlCmosReadRegister@@YIEE@Z
_TEXT	SEGMENT
_Register$ = -4						; size = 1
?BlCmosReadRegister@@YIEE@Z PROC			; BlCmosReadRegister, COMDAT
; _Register$ = cl

; 893  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	88 4d fc	 mov	 BYTE PTR _Register$[ebp], cl

; 894  :     BlRtlWritePort8(CMOS_CONTROL_REGISTER, Register);

  00007	8a 55 fc	 mov	 dl, BYTE PTR _Register$[ebp]
  0000a	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  0000f	e8 00 00 00 00	 call	 ?BlRtlWritePort8@@YIXGE@Z ; BlRtlWritePort8

; 895  : 
; 896  :     return BlRtlReadPort8(CMOS_DATA_REGISTER);

  00014	b9 71 00 00 00	 mov	 ecx, 113		; 00000071H
  00019	e8 00 00 00 00	 call	 ?BlRtlReadPort8@@YIEG@Z	; BlRtlReadPort8

; 897  : }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?BlCmosReadRegister@@YIEE@Z ENDP			; BlCmosReadRegister
_TEXT	ENDS
PUBLIC	?BlCmosWriteRegister@@YIXEE@Z			; BlCmosWriteRegister
; Function compile flags: /Odtp
;	COMDAT ?BlCmosWriteRegister@@YIXEE@Z
_TEXT	SEGMENT
_Value$ = -8						; size = 1
_Register$ = -4						; size = 1
?BlCmosWriteRegister@@YIXEE@Z PROC			; BlCmosWriteRegister, COMDAT
; _Register$ = cl
; _Value$ = dl

; 919  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	88 55 f8	 mov	 BYTE PTR _Value$[ebp], dl
  00009	88 4d fc	 mov	 BYTE PTR _Register$[ebp], cl

; 920  :     BlRtlWritePort8(CMOS_CONTROL_REGISTER, Register);

  0000c	8a 55 fc	 mov	 dl, BYTE PTR _Register$[ebp]
  0000f	b9 70 00 00 00	 mov	 ecx, 112		; 00000070H
  00014	e8 00 00 00 00	 call	 ?BlRtlWritePort8@@YIXGE@Z ; BlRtlWritePort8

; 921  : 
; 922  :     BlRtlWritePort8(CMOS_DATA_REGISTER, Value);

  00019	8a 55 f8	 mov	 dl, BYTE PTR _Value$[ebp]
  0001c	b9 71 00 00 00	 mov	 ecx, 113		; 00000071H
  00021	e8 00 00 00 00	 call	 ?BlRtlWritePort8@@YIXGE@Z ; BlRtlWritePort8

; 923  : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?BlCmosWriteRegister@@YIXEE@Z ENDP			; BlCmosWriteRegister
_TEXT	ENDS
PUBLIC	??_C@_0DA@IAHEEPOL@BL?3?5Attempting?5reset?5with?5keyboa@ ; `string'
PUBLIC	??_C@_0CB@EPLCKFAB@BL?3?5Attempting?5reset?5with?5ACPI?4?6@ ; `string'
PUBLIC	?BlRtlResetSystem@@YIXXZ			; BlRtlResetSystem
EXTRN	?BlAcpiResetSystem@@YIXXZ:PROC			; BlAcpiResetSystem
;	COMDAT ??_C@_0DA@IAHEEPOL@BL?3?5Attempting?5reset?5with?5keyboa@
CONST	SEGMENT
??_C@_0DA@IAHEEPOL@BL?3?5Attempting?5reset?5with?5keyboa@ DB 'BL: Attempt'
	DB	'ing reset with keyboard controller.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EPLCKFAB@BL?3?5Attempting?5reset?5with?5ACPI?4?6@
CONST	SEGMENT
??_C@_0CB@EPLCKFAB@BL?3?5Attempting?5reset?5with?5ACPI?4?6@ DB 'BL: Attem'
	DB	'pting reset with ACPI.', 0aH, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlRtlResetSystem@@YIXXZ
_TEXT	SEGMENT
_Context$ = -40						; size = 36
_Value$ = -1						; size = 1
?BlRtlResetSystem@@YIXXZ PROC				; BlRtlResetSystem, COMDAT

; 938  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 939  :     BL_LEGACY_CALL_CONTEXT Context;
; 940  :     UINT8 Value;
; 941  : 
; 942  :     //
; 943  :     // Issue a no-op legacy operation to restore legacy context.
; 944  :     //
; 945  : 
; 946  :     BlGetBeb()->LegacyCall_OpCode = LC_NOP;

  00006	e8 00 00 00 00	 call	 ?BlGetBeb@@YIPAU_BEB@@XZ ; BlGetBeb
  0000b	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 947  :     BlRtlMakeLegacyCall();

  00012	e8 00 00 00 00	 call	 ?BlRtlMakeLegacyCall@@YIXXZ ; BlRtlMakeLegacyCall

; 948  : 
; 949  :     //
; 950  :     // Disable periodic interrupt.
; 951  :     //
; 952  : 
; 953  :     Value = BlCmosReadRegister(CMOS_STATUS_REGISTER_B);

  00017	b1 0b		 mov	 cl, 11			; 0000000bH
  00019	e8 00 00 00 00	 call	 ?BlCmosReadRegister@@YIEE@Z ; BlCmosReadRegister
  0001e	88 45 ff	 mov	 BYTE PTR _Value$[ebp], al

; 954  :     Value &= ~CMOS_ENABLE_PERIODIC_TIMER;

  00021	0f b6 45 ff	 movzx	 eax, BYTE PTR _Value$[ebp]
  00025	83 e0 bf	 and	 eax, -65		; ffffffbfH
  00028	88 45 ff	 mov	 BYTE PTR _Value$[ebp], al

; 955  :     BlCmosWriteRegister(CMOS_STATUS_REGISTER_B, Value);

  0002b	8a 55 ff	 mov	 dl, BYTE PTR _Value$[ebp]
  0002e	b1 0b		 mov	 cl, 11			; 0000000bH
  00030	e8 00 00 00 00	 call	 ?BlCmosWriteRegister@@YIXEE@Z ; BlCmosWriteRegister

; 956  : 
; 957  :     //
; 958  :     // Set default rate.
; 959  :     //
; 960  : 
; 961  :     Value = BlCmosReadRegister(CMOS_STATUS_REGISTER_A);

  00035	b1 0a		 mov	 cl, 10			; 0000000aH
  00037	e8 00 00 00 00	 call	 ?BlCmosReadRegister@@YIEE@Z ; BlCmosReadRegister
  0003c	88 45 ff	 mov	 BYTE PTR _Value$[ebp], al

; 962  :     Value &= ~CMOS_RATE_MASK;

  0003f	0f b6 4d ff	 movzx	 ecx, BYTE PTR _Value$[ebp]
  00043	83 e1 f0	 and	 ecx, -16		; fffffff0H
  00046	88 4d ff	 mov	 BYTE PTR _Value$[ebp], cl

; 963  :     Value |= CMOS_DEFAULT_RATE;

  00049	0f b6 55 ff	 movzx	 edx, BYTE PTR _Value$[ebp]
  0004d	83 ca 06	 or	 edx, 6
  00050	88 55 ff	 mov	 BYTE PTR _Value$[ebp], dl

; 964  :     BlCmosWriteRegister(CMOS_STATUS_REGISTER_A, Value);

  00053	8a 55 ff	 mov	 dl, BYTE PTR _Value$[ebp]
  00056	b1 0a		 mov	 cl, 10			; 0000000aH
  00058	e8 00 00 00 00	 call	 ?BlCmosWriteRegister@@YIXEE@Z ; BlCmosWriteRegister

; 965  : 
; 966  :     //
; 967  :     // Set reset reason.
; 968  :     //
; 969  : 
; 970  :     BlCmosWriteRegister(CMOS_SHUTDOWN_REGISTER, 0);

  0005d	32 d2		 xor	 dl, dl
  0005f	b1 0f		 mov	 cl, 15			; 0000000fH
  00061	e8 00 00 00 00	 call	 ?BlCmosWriteRegister@@YIXEE@Z ; BlCmosWriteRegister

; 971  : 
; 972  :     //
; 973  :     // Try to reset using ACPI.
; 974  :     //
; 975  : 
; 976  :     BlRtlPrintf("BL: Attempting reset with ACPI.\n");

  00066	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@EPLCKFAB@BL?3?5Attempting?5reset?5with?5ACPI?4?6@
  0006b	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00070	83 c4 04	 add	 esp, 4

; 977  : 
; 978  :     BlAcpiResetSystem();

  00073	e8 00 00 00 00	 call	 ?BlAcpiResetSystem@@YIXXZ ; BlAcpiResetSystem

; 979  : 
; 980  :     //
; 981  :     // If the ACPI call returned, then it indicates that ACPI reset is
; 982  :     // not supported, so try to reset with the keyboard controller.
; 983  :     //
; 984  : 
; 985  :     BlRtlPrintf("BL: Attempting reset with keyboard controller.\n");

  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@IAHEEPOL@BL?3?5Attempting?5reset?5with?5keyboa@
  0007d	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00082	83 c4 04	 add	 esp, 4
$LN6@BlRtlReset:

; 986  : 
; 987  :     BL_KEYBOARD_WRITE_COMMAND(BL_KEYBOARD_COMMAND_PULSE_RESET_BIT);

  00085	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  0008a	e8 00 00 00 00	 call	 ?BlRtlReadPort8@@YIEG@Z	; BlRtlReadPort8
  0008f	0f b6 c0	 movzx	 eax, al
  00092	83 e0 02	 and	 eax, 2
  00095	74 02		 je	 SHORT $LN5@BlRtlReset
  00097	eb ec		 jmp	 SHORT $LN6@BlRtlReset
$LN5@BlRtlReset:
  00099	b2 fe		 mov	 dl, 254			; 000000feH
  0009b	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000a0	e8 00 00 00 00	 call	 ?BlRtlWritePort8@@YIXGE@Z ; BlRtlWritePort8
$LN4@BlRtlReset:
  000a5	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  000aa	e8 00 00 00 00	 call	 ?BlRtlReadPort8@@YIEG@Z	; BlRtlReadPort8
  000af	0f b6 c8	 movzx	 ecx, al
  000b2	83 e1 02	 and	 ecx, 2
  000b5	74 02		 je	 SHORT $LN3@BlRtlReset
  000b7	eb ec		 jmp	 SHORT $LN4@BlRtlReset
$LN3@BlRtlReset:

; 988  : 
; 989  :     //
; 990  :     // Issue INT19 as last resort.
; 991  :     //
; 992  : 
; 993  :     BlRtlZeroMemory(&Context, sizeof(Context));

  000b9	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
  000be	8d 4d d8	 lea	 ecx, DWORD PTR _Context$[ebp]
  000c1	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 994  : 
; 995  :     BlRtlCallLegacyInterruptService(0x19,
; 996  :                                     &Context,
; 997  :                                     &Context);

  000c6	8d 55 d8	 lea	 edx, DWORD PTR _Context$[ebp]
  000c9	52		 push	 edx
  000ca	8d 55 d8	 lea	 edx, DWORD PTR _Context$[ebp]
  000cd	b1 19		 mov	 cl, 25			; 00000019H
  000cf	e8 00 00 00 00	 call	 ?BlRtlCallLegacyInterruptService@@YIXEPAU_BL_LEGACY_CALL_CONTEXT@@0@Z ; BlRtlCallLegacyInterruptService
$LN2@BlRtlReset:

; 998  : 
; 999  :     for (;;) {
; 1000 : 
; 1001 :     }

  000d4	eb fe		 jmp	 SHORT $LN2@BlRtlReset

; 1002 : }

  000d6	8b e5		 mov	 esp, ebp
  000d8	5d		 pop	 ebp
  000d9	c3		 ret	 0
?BlRtlResetSystem@@YIXXZ ENDP				; BlRtlResetSystem
_TEXT	ENDS
PUBLIC	??_C@_0BJ@CAHBLCHL@APM?3?5Power?9off?5via?5APM?4?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@KBFMJDBH@APM?3?5INT15?1530Eh?5failed?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0BK@IGBACJJM@APM?3?5INT15?15301h?5failed?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@HKIPIEFE@APM?3?5Not?5available?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@EAPDPEPL@BL?3?5Attempting?5system?5shutdown?5t@ ; `string'
PUBLIC	?BlRtlShutdownSystem@@YIXXZ			; BlRtlShutdownSystem
;	COMDAT ??_C@_0BJ@CAHBLCHL@APM?3?5Power?9off?5via?5APM?4?6?$AA@
CONST	SEGMENT
??_C@_0BJ@CAHBLCHL@APM?3?5Power?9off?5via?5APM?4?6?$AA@ DB 'APM: Power-of'
	DB	'f via APM.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@KBFMJDBH@APM?3?5INT15?1530Eh?5failed?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BK@KBFMJDBH@APM?3?5INT15?1530Eh?5failed?$CB?6?$AA@ DB 'APM: INT15/'
	DB	'530Eh failed!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IGBACJJM@APM?3?5INT15?15301h?5failed?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BK@IGBACJJM@APM?3?5INT15?15301h?5failed?$CB?6?$AA@ DB 'APM: INT15/'
	DB	'5301h failed!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HKIPIEFE@APM?3?5Not?5available?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BF@HKIPIEFE@APM?3?5Not?5available?$CB?6?$AA@ DB 'APM: Not availabl'
	DB	'e!', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EAPDPEPL@BL?3?5Attempting?5system?5shutdown?5t@
CONST	SEGMENT
??_C@_0CN@EAPDPEPL@BL?3?5Attempting?5system?5shutdown?5t@ DB 'BL: Attempt'
	DB	'ing system shutdown through APM.', 0aH, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlRtlShutdownSystem@@YIXXZ
_TEXT	SEGMENT
_Context$ = -40						; size = 36
?BlRtlShutdownSystem@@YIXXZ PROC			; BlRtlShutdownSystem, COMDAT

; 1017 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H

; 1018 :     BL_LEGACY_CALL_CONTEXT Context;
; 1019 :     UINT32 Index;
; 1020 : 
; 1021 :     //
; 1022 :     // AIFIX: Add ACPI shutdown logic here.
; 1023 :     //
; 1024 : 
; 1025 :     BlRtlPrintf("BL: Attempting system shutdown through APM.\n");

  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@EAPDPEPL@BL?3?5Attempting?5system?5shutdown?5t@
  0000b	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00010	83 c4 04	 add	 esp, 4

; 1026 : 
; 1027 :     //
; 1028 :     // APM installation check.
; 1029 :     //
; 1030 : 
; 1031 : #if APM_VERBOSE
; 1032 : 
; 1033 :     BlRtlPrintf("APM: INT15/5300h [Installation Check]\n");
; 1034 : 
; 1035 : #endif
; 1036 : 
; 1037 :     BlRtlZeroMemory(&Context, sizeof(Context));

  00013	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
  00018	8d 4d d8	 lea	 ecx, DWORD PTR _Context$[ebp]
  0001b	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 1038 : 
; 1039 :     Context.eax = 0x5300;

  00020	c7 45 d8 00 53
	00 00		 mov	 DWORD PTR _Context$[ebp], 21248 ; 00005300H

; 1040 : 
; 1041 :     BlRtlCallLegacyInterruptService(0x15,
; 1042 :                                     &Context,
; 1043 :                                     &Context);

  00027	8d 45 d8	 lea	 eax, DWORD PTR _Context$[ebp]
  0002a	50		 push	 eax
  0002b	8d 55 d8	 lea	 edx, DWORD PTR _Context$[ebp]
  0002e	b1 15		 mov	 cl, 21			; 00000015H
  00030	e8 00 00 00 00	 call	 ?BlRtlCallLegacyInterruptService@@YIXEPAU_BL_LEGACY_CALL_CONTEXT@@0@Z ; BlRtlCallLegacyInterruptService

; 1044 : 
; 1045 :     if (((Context.eflags & RFLAGS_CF) != 0) || (Context.ebx != 0x504D)) {

  00035	8b 4d f8	 mov	 ecx, DWORD PTR _Context$[ebp+32]
  00038	83 e1 01	 and	 ecx, 1
  0003b	75 09		 jne	 SHORT $LN5@BlRtlShutd
  0003d	81 7d dc 4d 50
	00 00		 cmp	 DWORD PTR _Context$[ebp+4], 20557 ; 0000504dH
  00044	74 1c		 je	 SHORT $LN6@BlRtlShutd
$LN5@BlRtlShutd:

; 1046 : 
; 1047 :         BlRtlPrintf("APM: Not available!\n");

  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@HKIPIEFE@APM?3?5Not?5available?$CB?6?$AA@
  0004b	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00050	83 c4 04	 add	 esp, 4

; 1048 :         BlRtlHalt();

  00053	ba 18 04 00 00	 mov	 edx, 1048		; 00000418H
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IIIBICNN@blutil?4cpp?$AA@
  0005d	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN6@BlRtlShutd:

; 1049 :     }
; 1050 : 
; 1051 : #if APM_VERBOSE
; 1052 : 
; 1053 :     BlRtlPrintf("APM: Found APM v%u.%u.\n",
; 1054 :                 (Context.eax >> 8) & 0xFF,
; 1055 :                 Context.eax && 0xFF);
; 1056 : 
; 1057 : #endif
; 1058 : 
; 1059 :     //
; 1060 :     // Connect real-mode interface.
; 1061 :     //
; 1062 : 
; 1063 : #if APM_VERBOSE
; 1064 : 
; 1065 :     BlRtlPrintf("APM: INT15/5301h [Connect Real-Mode Interface]\n");
; 1066 : 
; 1067 : #endif
; 1068 : 
; 1069 :     BlRtlZeroMemory(&Context, sizeof(Context));

  00062	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
  00067	8d 4d d8	 lea	 ecx, DWORD PTR _Context$[ebp]
  0006a	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 1070 : 
; 1071 :     Context.eax = 0x5301;

  0006f	c7 45 d8 01 53
	00 00		 mov	 DWORD PTR _Context$[ebp], 21249 ; 00005301H

; 1072 : 
; 1073 :     BlRtlCallLegacyInterruptService(0x15,
; 1074 :                                     &Context,
; 1075 :                                     &Context);

  00076	8d 55 d8	 lea	 edx, DWORD PTR _Context$[ebp]
  00079	52		 push	 edx
  0007a	8d 55 d8	 lea	 edx, DWORD PTR _Context$[ebp]
  0007d	b1 15		 mov	 cl, 21			; 00000015H
  0007f	e8 00 00 00 00	 call	 ?BlRtlCallLegacyInterruptService@@YIXEPAU_BL_LEGACY_CALL_CONTEXT@@0@Z ; BlRtlCallLegacyInterruptService

; 1076 : 
; 1077 :     if ((Context.eflags & RFLAGS_CF) != 0) {

  00084	8b 45 f8	 mov	 eax, DWORD PTR _Context$[ebp+32]
  00087	83 e0 01	 and	 eax, 1
  0008a	74 1c		 je	 SHORT $LN4@BlRtlShutd

; 1078 : 
; 1079 :         BlRtlPrintf("APM: INT15/5301h failed!\n");

  0008c	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@IGBACJJM@APM?3?5INT15?15301h?5failed?$CB?6?$AA@
  00091	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00096	83 c4 04	 add	 esp, 4

; 1080 :         BlRtlHalt();

  00099	ba 38 04 00 00	 mov	 edx, 1080		; 00000438H
  0009e	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IIIBICNN@blutil?4cpp?$AA@
  000a3	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN4@BlRtlShutd:

; 1081 :     }
; 1082 : 
; 1083 :     //
; 1084 :     // Set APM driver version.
; 1085 :     //
; 1086 : 
; 1087 : #if APM_VERBOSE
; 1088 : 
; 1089 :     BlRtlPrintf("APM: INT15/530Eh [Set APM Driver Version]\n");
; 1090 : 
; 1091 : #endif
; 1092 : 
; 1093 :     BlRtlZeroMemory(&Context, sizeof(Context));

  000a8	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
  000ad	8d 4d d8	 lea	 ecx, DWORD PTR _Context$[ebp]
  000b0	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 1094 : 
; 1095 :     Context.eax = 0x530E;

  000b5	c7 45 d8 0e 53
	00 00		 mov	 DWORD PTR _Context$[ebp], 21262 ; 0000530eH

; 1096 :     Context.ecx = 0x0102;

  000bc	c7 45 e0 02 01
	00 00		 mov	 DWORD PTR _Context$[ebp+8], 258 ; 00000102H

; 1097 : 
; 1098 :     BlRtlCallLegacyInterruptService(0x15,
; 1099 :                                     &Context,
; 1100 :                                     &Context);

  000c3	8d 4d d8	 lea	 ecx, DWORD PTR _Context$[ebp]
  000c6	51		 push	 ecx
  000c7	8d 55 d8	 lea	 edx, DWORD PTR _Context$[ebp]
  000ca	b1 15		 mov	 cl, 21			; 00000015H
  000cc	e8 00 00 00 00	 call	 ?BlRtlCallLegacyInterruptService@@YIXEPAU_BL_LEGACY_CALL_CONTEXT@@0@Z ; BlRtlCallLegacyInterruptService

; 1101 : 
; 1102 :     if ((Context.eflags & RFLAGS_CF) != 0) {

  000d1	8b 55 f8	 mov	 edx, DWORD PTR _Context$[ebp+32]
  000d4	83 e2 01	 and	 edx, 1
  000d7	74 1c		 je	 SHORT $LN3@BlRtlShutd

; 1103 : 
; 1104 :         BlRtlPrintf("APM: INT15/530Eh failed!\n");

  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@KBFMJDBH@APM?3?5INT15?1530Eh?5failed?$CB?6?$AA@
  000de	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  000e3	83 c4 04	 add	 esp, 4

; 1105 :         BlRtlHalt();

  000e6	ba 51 04 00 00	 mov	 edx, 1105		; 00000451H
  000eb	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IIIBICNN@blutil?4cpp?$AA@
  000f0	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN3@BlRtlShutd:

; 1106 :     }
; 1107 : 
; 1108 : #if APM_VERBOSE
; 1109 : 
; 1110 :     BlRtlPrintf("APM: INT15/5307h [Shutdown]\n");
; 1111 : 
; 1112 : #endif
; 1113 : 
; 1114 :     //
; 1115 :     // Announce shutdown.
; 1116 :     //
; 1117 :     // Note that the lab infrastructure searches for this string
; 1118 :     // when attempting to determine if the host successfully
; 1119 :     // reached shutdown.
; 1120 :     //
; 1121 : 
; 1122 :     BlRtlPrintf("APM: Power-off via APM.\n");

  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@CAHBLCHL@APM?3?5Power?9off?5via?5APM?4?6?$AA@
  000fa	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  000ff	83 c4 04	 add	 esp, 4

; 1123 : 
; 1124 :     //
; 1125 :     // Issue APM shutdown command.
; 1126 :     //
; 1127 : 
; 1128 :     Context.eax = 0x5307;

  00102	c7 45 d8 07 53
	00 00		 mov	 DWORD PTR _Context$[ebp], 21255 ; 00005307H

; 1129 :     Context.ebx = 1;

  00109	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _Context$[ebp+4], 1

; 1130 :     Context.ecx = 3;

  00110	c7 45 e0 03 00
	00 00		 mov	 DWORD PTR _Context$[ebp+8], 3

; 1131 : 
; 1132 :     BlRtlCallLegacyInterruptService(0x15,
; 1133 :                                     &Context,
; 1134 :                                     &Context);

  00117	8d 45 d8	 lea	 eax, DWORD PTR _Context$[ebp]
  0011a	50		 push	 eax
  0011b	8d 55 d8	 lea	 edx, DWORD PTR _Context$[ebp]
  0011e	b1 15		 mov	 cl, 21			; 00000015H
  00120	e8 00 00 00 00	 call	 ?BlRtlCallLegacyInterruptService@@YIXEPAU_BL_LEGACY_CALL_CONTEXT@@0@Z ; BlRtlCallLegacyInterruptService
$LN2@BlRtlShutd:

; 1135 : 
; 1136 :     for (;;) {
; 1137 : 
; 1138 :     }

  00125	eb fe		 jmp	 SHORT $LN2@BlRtlShutd

; 1139 : }

  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c3		 ret	 0
?BlRtlShutdownSystem@@YIXXZ ENDP			; BlRtlShutdownSystem
_TEXT	ENDS
PUBLIC	?BlRtlConvertBcdToBinary8@@YIEE@Z		; BlRtlConvertBcdToBinary8
; Function compile flags: /Odtp
;	COMDAT ?BlRtlConvertBcdToBinary8@@YIEE@Z
_TEXT	SEGMENT
_BcdValue$ = -4						; size = 1
?BlRtlConvertBcdToBinary8@@YIEE@Z PROC			; BlRtlConvertBcdToBinary8, COMDAT
; _BcdValue$ = cl

; 1162 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	88 4d fc	 mov	 BYTE PTR _BcdValue$[ebp], cl

; 1163 :     return (((BcdValue >> 4) & 0xF) * 10) + (BcdValue & 0xF);

  00007	0f b6 45 fc	 movzx	 eax, BYTE PTR _BcdValue$[ebp]
  0000b	c1 f8 04	 sar	 eax, 4
  0000e	83 e0 0f	 and	 eax, 15			; 0000000fH
  00011	6b c0 0a	 imul	 eax, 10			; 0000000aH
  00014	0f b6 4d fc	 movzx	 ecx, BYTE PTR _BcdValue$[ebp]
  00018	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0001b	03 c1		 add	 eax, ecx

; 1164 : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?BlRtlConvertBcdToBinary8@@YIEE@Z ENDP			; BlRtlConvertBcdToBinary8
_TEXT	ENDS
PUBLIC	?BlRtlGetCurrentTime@@YIXPAU_BL_TIME@@@Z	; BlRtlGetCurrentTime
; Function compile flags: /Odtp
;	COMDAT ?BlRtlGetCurrentTime@@YIXPAU_BL_TIME@@@Z
_TEXT	SEGMENT
_Time$ = -4						; size = 4
?BlRtlGetCurrentTime@@YIXPAU_BL_TIME@@@Z PROC		; BlRtlGetCurrentTime, COMDAT
; _Time$ = ecx

; 1183 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _Time$[ebp], ecx

; 1184 :     //
; 1185 :     // Query CMOS RTC.
; 1186 :     //
; 1187 : 
; 1188 :     Time->Year = BlCmosReadRegister(CMOS_YEARS_REGISTER);

  00007	b1 09		 mov	 cl, 9
  00009	e8 00 00 00 00	 call	 ?BlCmosReadRegister@@YIEE@Z ; BlCmosReadRegister
  0000e	0f b6 c0	 movzx	 eax, al
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _Time$[ebp]
  00014	89 01		 mov	 DWORD PTR [ecx], eax

; 1189 :     Time->Month = BlCmosReadRegister(CMOS_MONTHS_REGISTER);

  00016	b1 08		 mov	 cl, 8
  00018	e8 00 00 00 00	 call	 ?BlCmosReadRegister@@YIEE@Z ; BlCmosReadRegister
  0001d	8b 55 fc	 mov	 edx, DWORD PTR _Time$[ebp]
  00020	88 42 04	 mov	 BYTE PTR [edx+4], al

; 1190 :     Time->Day = BlCmosReadRegister(CMOS_DAYS_REGISTER);

  00023	b1 07		 mov	 cl, 7
  00025	e8 00 00 00 00	 call	 ?BlCmosReadRegister@@YIEE@Z ; BlCmosReadRegister
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _Time$[ebp]
  0002d	88 41 05	 mov	 BYTE PTR [ecx+5], al

; 1191 :     Time->Hour = BlCmosReadRegister(CMOS_HOURS_REGISTER);

  00030	b1 04		 mov	 cl, 4
  00032	e8 00 00 00 00	 call	 ?BlCmosReadRegister@@YIEE@Z ; BlCmosReadRegister
  00037	8b 55 fc	 mov	 edx, DWORD PTR _Time$[ebp]
  0003a	88 42 06	 mov	 BYTE PTR [edx+6], al

; 1192 :     Time->Minute = BlCmosReadRegister(CMOS_MINUTES_REGISTER);

  0003d	b1 02		 mov	 cl, 2
  0003f	e8 00 00 00 00	 call	 ?BlCmosReadRegister@@YIEE@Z ; BlCmosReadRegister
  00044	8b 4d fc	 mov	 ecx, DWORD PTR _Time$[ebp]
  00047	88 41 07	 mov	 BYTE PTR [ecx+7], al

; 1193 :     Time->Second = BlCmosReadRegister(CMOS_SECONDS_REGISTER);

  0004a	32 c9		 xor	 cl, cl
  0004c	e8 00 00 00 00	 call	 ?BlCmosReadRegister@@YIEE@Z ; BlCmosReadRegister
  00051	8b 55 fc	 mov	 edx, DWORD PTR _Time$[ebp]
  00054	88 42 08	 mov	 BYTE PTR [edx+8], al

; 1194 : 
; 1195 :     //
; 1196 :     // If the clock is in BCD format, then convert it to binary.
; 1197 :     //
; 1198 : 
; 1199 :     if ((BlCmosReadRegister(CMOS_STATUS_REGISTER_B) & CMOS_CLOCK_IN_BINARY) == 0) {

  00057	b1 0b		 mov	 cl, 11			; 0000000bH
  00059	e8 00 00 00 00	 call	 ?BlCmosReadRegister@@YIEE@Z ; BlCmosReadRegister
  0005e	0f b6 c0	 movzx	 eax, al
  00061	83 e0 04	 and	 eax, 4
  00064	75 67		 jne	 SHORT $LN2@BlRtlGetCu

; 1200 : 
; 1201 :         Time->Year = BlRtlConvertBcdToBinary8((UINT8) Time->Year);

  00066	8b 4d fc	 mov	 ecx, DWORD PTR _Time$[ebp]
  00069	8a 09		 mov	 cl, BYTE PTR [ecx]
  0006b	e8 00 00 00 00	 call	 ?BlRtlConvertBcdToBinary8@@YIEE@Z ; BlRtlConvertBcdToBinary8
  00070	0f b6 d0	 movzx	 edx, al
  00073	8b 45 fc	 mov	 eax, DWORD PTR _Time$[ebp]
  00076	89 10		 mov	 DWORD PTR [eax], edx

; 1202 :         Time->Month = BlRtlConvertBcdToBinary8(Time->Month);

  00078	8b 4d fc	 mov	 ecx, DWORD PTR _Time$[ebp]
  0007b	8a 49 04	 mov	 cl, BYTE PTR [ecx+4]
  0007e	e8 00 00 00 00	 call	 ?BlRtlConvertBcdToBinary8@@YIEE@Z ; BlRtlConvertBcdToBinary8
  00083	8b 55 fc	 mov	 edx, DWORD PTR _Time$[ebp]
  00086	88 42 04	 mov	 BYTE PTR [edx+4], al

; 1203 :         Time->Day = BlRtlConvertBcdToBinary8(Time->Day);

  00089	8b 45 fc	 mov	 eax, DWORD PTR _Time$[ebp]
  0008c	8a 48 05	 mov	 cl, BYTE PTR [eax+5]
  0008f	e8 00 00 00 00	 call	 ?BlRtlConvertBcdToBinary8@@YIEE@Z ; BlRtlConvertBcdToBinary8
  00094	8b 4d fc	 mov	 ecx, DWORD PTR _Time$[ebp]
  00097	88 41 05	 mov	 BYTE PTR [ecx+5], al

; 1204 :         Time->Hour = BlRtlConvertBcdToBinary8(Time->Hour);

  0009a	8b 55 fc	 mov	 edx, DWORD PTR _Time$[ebp]
  0009d	8a 4a 06	 mov	 cl, BYTE PTR [edx+6]
  000a0	e8 00 00 00 00	 call	 ?BlRtlConvertBcdToBinary8@@YIEE@Z ; BlRtlConvertBcdToBinary8
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _Time$[ebp]
  000a8	88 41 06	 mov	 BYTE PTR [ecx+6], al

; 1205 :         Time->Minute = BlRtlConvertBcdToBinary8(Time->Minute);

  000ab	8b 55 fc	 mov	 edx, DWORD PTR _Time$[ebp]
  000ae	8a 4a 07	 mov	 cl, BYTE PTR [edx+7]
  000b1	e8 00 00 00 00	 call	 ?BlRtlConvertBcdToBinary8@@YIEE@Z ; BlRtlConvertBcdToBinary8
  000b6	8b 4d fc	 mov	 ecx, DWORD PTR _Time$[ebp]
  000b9	88 41 07	 mov	 BYTE PTR [ecx+7], al

; 1206 :         Time->Second = BlRtlConvertBcdToBinary8(Time->Second);

  000bc	8b 55 fc	 mov	 edx, DWORD PTR _Time$[ebp]
  000bf	8a 4a 08	 mov	 cl, BYTE PTR [edx+8]
  000c2	e8 00 00 00 00	 call	 ?BlRtlConvertBcdToBinary8@@YIEE@Z ; BlRtlConvertBcdToBinary8
  000c7	8b 4d fc	 mov	 ecx, DWORD PTR _Time$[ebp]
  000ca	88 41 08	 mov	 BYTE PTR [ecx+8], al
$LN2@BlRtlGetCu:

; 1207 :     }
; 1208 : }

  000cd	8b e5		 mov	 esp, ebp
  000cf	5d		 pop	 ebp
  000d0	c3		 ret	 0
?BlRtlGetCurrentTime@@YIXPAU_BL_TIME@@@Z ENDP		; BlRtlGetCurrentTime
_TEXT	ENDS
END
