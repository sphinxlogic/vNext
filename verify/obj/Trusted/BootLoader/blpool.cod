; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\OSes\VERVE\verify\src\Trusted\BootLoader\SingLdrPc\blpool.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BlPoolSegmentList@@3U_LIST_ENTRY@@A		; BlPoolSegmentList
_BSS	SEGMENT
?BlPoolSegmentList@@3U_LIST_ENTRY@@A DQ 01H DUP (?)	; BlPoolSegmentList
_BSS	ENDS
PUBLIC	?BlPoolInitialize@@YIXXZ			; BlPoolInitialize
EXTRN	?BlRtlInitializeListHead@@YIXPAU_LIST_ENTRY@@@Z:PROC ; BlRtlInitializeListHead
; Function compile flags: /Odtp
; File d:\oses\verve\verify\src\trusted\bootloader\singldrpc\blpool.cpp
;	COMDAT ?BlPoolInitialize@@YIXXZ
_TEXT	SEGMENT
?BlPoolInitialize@@YIXXZ PROC				; BlPoolInitialize, COMDAT

; 93   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 94   :     BlRtlInitializeListHead(&BlPoolSegmentList);

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?BlPoolSegmentList@@3U_LIST_ENTRY@@A ; BlPoolSegmentList
  00008	e8 00 00 00 00	 call	 ?BlRtlInitializeListHead@@YIXPAU_LIST_ENTRY@@@Z ; BlRtlInitializeListHead

; 95   : 
; 96   : #if POOL_VERBOSE
; 97   : 
; 98   :     BlRtlPrintf("POOL: Segment list @ %p.\n", &BlPoolSegmentList);
; 99   : 
; 100  : #endif
; 101  : 
; 102  :     return;
; 103  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?BlPoolInitialize@@YIXXZ ENDP				; BlPoolInitialize
_TEXT	ENDS
PUBLIC	??_C@_0L@IABHNPNF@blpool?4cpp?$AA@		; `string'
PUBLIC	?BlPoolVerify@@YIXXZ				; BlPoolVerify
EXTRN	?BlRtlAssertFailedPtr@@YIXPBDKK@Z:PROC		; BlRtlAssertFailedPtr
EXTRN	?BlRtlAssertFailed@@YIXPBDK@Z:PROC		; BlRtlAssertFailed
;	COMDAT ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
CONST	SEGMENT
??_C@_0L@IABHNPNF@blpool?4cpp?$AA@ DB 'blpool.cpp', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlPoolVerify@@YIXXZ
_TEXT	SEGMENT
_BlockEntry$ = -28					; size = 4
_Block$ = -24						; size = 4
_BlockHead$ = -20					; size = 4
_NextBlock$ = -16					; size = 4
_SegmentHead$ = -12					; size = 4
_SegmentEntry$ = -8					; size = 4
_Segment$ = -4						; size = 4
?BlPoolVerify@@YIXXZ PROC				; BlPoolVerify, COMDAT

; 175  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 176  :     PBL_POOL_BLOCK Block;
; 177  :     PLIST_ENTRY BlockEntry;
; 178  :     PLIST_ENTRY BlockHead;
; 179  :     PBL_POOL_BLOCK NextBlock;
; 180  :     PBL_POOL_SEGMENT Segment;
; 181  :     PLIST_ENTRY SegmentEntry;
; 182  :     PLIST_ENTRY SegmentHead;
; 183  : 
; 184  :     SegmentHead = &BlPoolSegmentList;

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _SegmentHead$[ebp], OFFSET ?BlPoolSegmentList@@3U_LIST_ENTRY@@A ; BlPoolSegmentList

; 185  : 
; 186  :     BLASSERT(SegmentHead->Flink->Blink == SegmentHead);

  0000d	8b 45 f4	 mov	 eax, DWORD PTR _SegmentHead$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00015	3b 55 f4	 cmp	 edx, DWORD PTR _SegmentHead$[ebp]
  00018	74 0f		 je	 SHORT $LN22@BlPoolVeri
  0001a	ba ba 00 00 00	 mov	 edx, 186		; 000000baH
  0001f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00024	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN22@BlPoolVeri:

; 187  :     BLASSERT(SegmentHead->Blink->Flink == SegmentHead);

  00029	8b 45 f4	 mov	 eax, DWORD PTR _SegmentHead$[ebp]
  0002c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00031	3b 55 f4	 cmp	 edx, DWORD PTR _SegmentHead$[ebp]
  00034	74 0f		 je	 SHORT $LN21@BlPoolVeri
  00036	ba bb 00 00 00	 mov	 edx, 187		; 000000bbH
  0003b	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00040	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN21@BlPoolVeri:

; 188  : 
; 189  :     for (SegmentEntry = SegmentHead->Flink; SegmentEntry != SegmentHead; SegmentEntry = SegmentEntry->Flink) {

  00045	8b 45 f4	 mov	 eax, DWORD PTR _SegmentHead$[ebp]
  00048	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004a	89 4d f8	 mov	 DWORD PTR _SegmentEntry$[ebp], ecx
  0004d	eb 08		 jmp	 SHORT $LN20@BlPoolVeri
$LN19@BlPoolVeri:
  0004f	8b 55 f8	 mov	 edx, DWORD PTR _SegmentEntry$[ebp]
  00052	8b 02		 mov	 eax, DWORD PTR [edx]
  00054	89 45 f8	 mov	 DWORD PTR _SegmentEntry$[ebp], eax
$LN20@BlPoolVeri:
  00057	8b 4d f8	 mov	 ecx, DWORD PTR _SegmentEntry$[ebp]
  0005a	3b 4d f4	 cmp	 ecx, DWORD PTR _SegmentHead$[ebp]
  0005d	0f 84 0d 02 00
	00		 je	 $LN23@BlPoolVeri

; 190  : 
; 191  :         Segment = CONTAINING_RECORD(SegmentEntry,
; 192  :                                     BL_POOL_SEGMENT,
; 193  :                                     Entry);

  00063	8b 55 f8	 mov	 edx, DWORD PTR _SegmentEntry$[ebp]
  00066	83 ea 04	 sub	 edx, 4
  00069	89 55 fc	 mov	 DWORD PTR _Segment$[ebp], edx

; 194  : 
; 195  :         BLASSERT_PTR(Segment->Magic1 == BL_POOL_SEGMENT_MAGIC1, Segment);

  0006c	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  0006f	81 38 fc fd fe
	ff		 cmp	 DWORD PTR [eax], -66052	; fffefdfcH
  00075	74 13		 je	 SHORT $LN17@BlPoolVeri
  00077	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  0007a	51		 push	 ecx
  0007b	ba c3 00 00 00	 mov	 edx, 195		; 000000c3H
  00080	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00085	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN17@BlPoolVeri:

; 196  :         BLASSERT_PTR(Segment->Magic2 == BL_POOL_SEGMENT_MAGIC2, Segment);

  0008a	8b 55 fc	 mov	 edx, DWORD PTR _Segment$[ebp]
  0008d	81 7a 20 f8 f9
	fa fb		 cmp	 DWORD PTR [edx+32], -67438088 ; fbfaf9f8H
  00094	74 13		 je	 SHORT $LN16@BlPoolVeri
  00096	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  00099	50		 push	 eax
  0009a	ba c4 00 00 00	 mov	 edx, 196		; 000000c4H
  0009f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  000a4	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN16@BlPoolVeri:

; 197  : 
; 198  :         BLASSERT_PTR(Segment->Entry.Flink->Blink == &Segment->Entry, Segment);

  000a9	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  000ac	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000af	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  000b2	83 c0 04	 add	 eax, 4
  000b5	39 42 04	 cmp	 DWORD PTR [edx+4], eax
  000b8	74 13		 je	 SHORT $LN15@BlPoolVeri
  000ba	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  000bd	51		 push	 ecx
  000be	ba c6 00 00 00	 mov	 edx, 198		; 000000c6H
  000c3	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  000c8	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN15@BlPoolVeri:

; 199  :         BLASSERT_PTR(Segment->Entry.Blink->Flink == &Segment->Entry, Segment);

  000cd	8b 55 fc	 mov	 edx, DWORD PTR _Segment$[ebp]
  000d0	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  000d3	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  000d6	83 c1 04	 add	 ecx, 4
  000d9	39 08		 cmp	 DWORD PTR [eax], ecx
  000db	74 13		 je	 SHORT $LN14@BlPoolVeri
  000dd	8b 55 fc	 mov	 edx, DWORD PTR _Segment$[ebp]
  000e0	52		 push	 edx
  000e1	ba c7 00 00 00	 mov	 edx, 199		; 000000c7H
  000e6	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  000eb	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN14@BlPoolVeri:

; 200  : 
; 201  : 
; 202  :         BlockHead = &Segment->BlockList;

  000f0	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  000f3	83 c0 18	 add	 eax, 24			; 00000018H
  000f6	89 45 ec	 mov	 DWORD PTR _BlockHead$[ebp], eax

; 203  : 
; 204  :         for (BlockEntry = BlockHead->Flink; BlockEntry != BlockHead; BlockEntry = BlockEntry->Flink) {

  000f9	8b 4d ec	 mov	 ecx, DWORD PTR _BlockHead$[ebp]
  000fc	8b 11		 mov	 edx, DWORD PTR [ecx]
  000fe	89 55 e4	 mov	 DWORD PTR _BlockEntry$[ebp], edx
  00101	eb 08		 jmp	 SHORT $LN13@BlPoolVeri
$LN12@BlPoolVeri:
  00103	8b 45 e4	 mov	 eax, DWORD PTR _BlockEntry$[ebp]
  00106	8b 08		 mov	 ecx, DWORD PTR [eax]
  00108	89 4d e4	 mov	 DWORD PTR _BlockEntry$[ebp], ecx
$LN13@BlPoolVeri:
  0010b	8b 55 e4	 mov	 edx, DWORD PTR _BlockEntry$[ebp]
  0010e	3b 55 ec	 cmp	 edx, DWORD PTR _BlockHead$[ebp]
  00111	0f 84 54 01 00
	00		 je	 $LN11@BlPoolVeri

; 205  : 
; 206  :             Block = CONTAINING_RECORD(BlockEntry,
; 207  :                                       BL_POOL_BLOCK,
; 208  :                                       Entry);

  00117	8b 45 e4	 mov	 eax, DWORD PTR _BlockEntry$[ebp]
  0011a	83 e8 04	 sub	 eax, 4
  0011d	89 45 e8	 mov	 DWORD PTR _Block$[ebp], eax

; 209  : 
; 210  :             BLASSERT_PTR(Block->Magic1 == BL_POOL_BLOCK_MAGIC1, Block);

  00120	8b 4d e8	 mov	 ecx, DWORD PTR _Block$[ebp]
  00123	81 39 04 03 02
	01		 cmp	 DWORD PTR [ecx], 16909060 ; 01020304H
  00129	74 13		 je	 SHORT $LN10@BlPoolVeri
  0012b	8b 55 e8	 mov	 edx, DWORD PTR _Block$[ebp]
  0012e	52		 push	 edx
  0012f	ba d2 00 00 00	 mov	 edx, 210		; 000000d2H
  00134	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00139	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN10@BlPoolVeri:

; 211  :             BLASSERT_PTR(Block->Magic2 == BL_POOL_BLOCK_MAGIC2, Block);

  0013e	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  00141	81 78 1c 08 07
	06 05		 cmp	 DWORD PTR [eax+28], 84281096 ; 05060708H
  00148	74 13		 je	 SHORT $LN9@BlPoolVeri
  0014a	8b 4d e8	 mov	 ecx, DWORD PTR _Block$[ebp]
  0014d	51		 push	 ecx
  0014e	ba d3 00 00 00	 mov	 edx, 211		; 000000d3H
  00153	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00158	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN9@BlPoolVeri:

; 212  : 
; 213  :             BLASSERT_PTR((Block->State == BL_POOL_FREE) || ((Block->State == BL_POOL_BUSY)), Block);

  0015d	8b 55 e8	 mov	 edx, DWORD PTR _Block$[ebp]
  00160	83 7a 10 01	 cmp	 DWORD PTR [edx+16], 1
  00164	74 1c		 je	 SHORT $LN8@BlPoolVeri
  00166	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  00169	83 78 10 02	 cmp	 DWORD PTR [eax+16], 2
  0016d	74 13		 je	 SHORT $LN8@BlPoolVeri
  0016f	8b 4d e8	 mov	 ecx, DWORD PTR _Block$[ebp]
  00172	51		 push	 ecx
  00173	ba d5 00 00 00	 mov	 edx, 213		; 000000d5H
  00178	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  0017d	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN8@BlPoolVeri:

; 214  : 
; 215  :             BLASSERT_PTR(((ULONG_PTR) Block % BL_POOL_GRANULARITY) == 0, Block);

  00182	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  00185	33 d2		 xor	 edx, edx
  00187	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0018c	f7 f1		 div	 ecx
  0018e	85 d2		 test	 edx, edx
  00190	74 13		 je	 SHORT $LN7@BlPoolVeri
  00192	8b 55 e8	 mov	 edx, DWORD PTR _Block$[ebp]
  00195	52		 push	 edx
  00196	ba d7 00 00 00	 mov	 edx, 215		; 000000d7H
  0019b	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  001a0	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN7@BlPoolVeri:

; 216  : 
; 217  :             BLASSERT_PTR(Block->Size > sizeof(BL_POOL_BLOCK), Block);

  001a5	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  001a8	83 78 0c 20	 cmp	 DWORD PTR [eax+12], 32	; 00000020H
  001ac	77 13		 ja	 SHORT $LN6@BlPoolVeri
  001ae	8b 4d e8	 mov	 ecx, DWORD PTR _Block$[ebp]
  001b1	51		 push	 ecx
  001b2	ba d9 00 00 00	 mov	 edx, 217		; 000000d9H
  001b7	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  001bc	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN6@BlPoolVeri:

; 218  :             BLASSERT_PTR((Block->Size % BL_POOL_GRANULARITY) == 0, Block);

  001c1	8b 55 e8	 mov	 edx, DWORD PTR _Block$[ebp]
  001c4	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  001c7	33 d2		 xor	 edx, edx
  001c9	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  001ce	f7 f1		 div	 ecx
  001d0	85 d2		 test	 edx, edx
  001d2	74 13		 je	 SHORT $LN5@BlPoolVeri
  001d4	8b 55 e8	 mov	 edx, DWORD PTR _Block$[ebp]
  001d7	52		 push	 edx
  001d8	ba da 00 00 00	 mov	 edx, 218		; 000000daH
  001dd	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  001e2	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN5@BlPoolVeri:

; 219  : 
; 220  :             if (Block->Entry.Flink != BlockHead) {

  001e7	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  001ea	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  001ed	3b 4d ec	 cmp	 ecx, DWORD PTR _BlockHead$[ebp]
  001f0	74 2d		 je	 SHORT $LN4@BlPoolVeri

; 221  : 
; 222  :                 NextBlock = CONTAINING_RECORD(Block->Entry.Flink,
; 223  :                                               BL_POOL_BLOCK,
; 224  :                                               Entry);

  001f2	8b 55 e8	 mov	 edx, DWORD PTR _Block$[ebp]
  001f5	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  001f8	83 e8 04	 sub	 eax, 4
  001fb	89 45 f0	 mov	 DWORD PTR _NextBlock$[ebp], eax

; 225  : 
; 226  :                 BLASSERT_PTR(((ULONG_PTR) Block + Block->Size) == ((ULONG_PTR) NextBlock), Block);

  001fe	8b 4d e8	 mov	 ecx, DWORD PTR _Block$[ebp]
  00201	8b 55 e8	 mov	 edx, DWORD PTR _Block$[ebp]
  00204	03 51 0c	 add	 edx, DWORD PTR [ecx+12]
  00207	3b 55 f0	 cmp	 edx, DWORD PTR _NextBlock$[ebp]
  0020a	74 13		 je	 SHORT $LN4@BlPoolVeri
  0020c	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  0020f	50		 push	 eax
  00210	ba e2 00 00 00	 mov	 edx, 226		; 000000e2H
  00215	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  0021a	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN4@BlPoolVeri:

; 227  :             }
; 228  : 
; 229  :             BLASSERT_PTR(Block->Entry.Flink->Blink == &Block->Entry, Block);

  0021f	8b 4d e8	 mov	 ecx, DWORD PTR _Block$[ebp]
  00222	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00225	8b 45 e8	 mov	 eax, DWORD PTR _Block$[ebp]
  00228	83 c0 04	 add	 eax, 4
  0022b	39 42 04	 cmp	 DWORD PTR [edx+4], eax
  0022e	74 13		 je	 SHORT $LN2@BlPoolVeri
  00230	8b 4d e8	 mov	 ecx, DWORD PTR _Block$[ebp]
  00233	51		 push	 ecx
  00234	ba e5 00 00 00	 mov	 edx, 229		; 000000e5H
  00239	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  0023e	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN2@BlPoolVeri:

; 230  :             BLASSERT_PTR(Block->Entry.Blink->Flink == &Block->Entry, Block);

  00243	8b 55 e8	 mov	 edx, DWORD PTR _Block$[ebp]
  00246	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00249	8b 4d e8	 mov	 ecx, DWORD PTR _Block$[ebp]
  0024c	83 c1 04	 add	 ecx, 4
  0024f	39 08		 cmp	 DWORD PTR [eax], ecx
  00251	74 13		 je	 SHORT $LN1@BlPoolVeri
  00253	8b 55 e8	 mov	 edx, DWORD PTR _Block$[ebp]
  00256	52		 push	 edx
  00257	ba e6 00 00 00	 mov	 edx, 230		; 000000e6H
  0025c	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00261	e8 00 00 00 00	 call	 ?BlRtlAssertFailedPtr@@YIXPBDKK@Z ; BlRtlAssertFailedPtr
$LN1@BlPoolVeri:

; 231  :         }

  00266	e9 98 fe ff ff	 jmp	 $LN12@BlPoolVeri
$LN11@BlPoolVeri:

; 232  :     }

  0026b	e9 df fd ff ff	 jmp	 $LN19@BlPoolVeri
$LN23@BlPoolVeri:

; 233  : 
; 234  :     return;
; 235  : }

  00270	8b e5		 mov	 esp, ebp
  00272	5d		 pop	 ebp
  00273	c3		 ret	 0
?BlPoolVerify@@YIXXZ ENDP				; BlPoolVerify
_TEXT	ENDS
PUBLIC	?BlPoolGrow@@YIXK@Z				; BlPoolGrow
EXTRN	?BlRtlInsertTailList@@YIXPAU_LIST_ENTRY@@0@Z:PROC ; BlRtlInsertTailList
EXTRN	?BlRtlZeroMemory@@YIXPAXK@Z:PROC		; BlRtlZeroMemory
EXTRN	?BlMmAllocatePhysicalRegion@@YI_KKK@Z:PROC	; BlMmAllocatePhysicalRegion
; Function compile flags: /Odtp
;	COMDAT ?BlPoolGrow@@YIXK@Z
_TEXT	SEGMENT
_Size$ = -12						; size = 4
_Block$ = -8						; size = 4
_Segment$ = -4						; size = 4
?BlPoolGrow@@YIXK@Z PROC				; BlPoolGrow, COMDAT
; _Size$ = ecx

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _Size$[ebp], ecx

; 255  :     PBL_POOL_BLOCK Block;
; 256  :     PBL_POOL_SEGMENT Segment;
; 257  : 
; 258  :     BlPoolVerify();

  00009	e8 00 00 00 00	 call	 ?BlPoolVerify@@YIXXZ	; BlPoolVerify

; 259  : 
; 260  :     BLASSERT(Size > 0);

  0000e	83 7d f4 00	 cmp	 DWORD PTR _Size$[ebp], 0
  00012	77 0f		 ja	 SHORT $LN1@BlPoolGrow
  00014	ba 04 01 00 00	 mov	 edx, 260		; 00000104H
  00019	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  0001e	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN1@BlPoolGrow:

; 261  : 
; 262  :     Size = ROUND_UP_TO_PAGES(Size);

  00023	8b 45 f4	 mov	 eax, DWORD PTR _Size$[ebp]
  00026	05 ff 0f 00 00	 add	 eax, 4095		; 00000fffH
  0002b	25 00 f0 ff ff	 and	 eax, -4096		; fffff000H
  00030	89 45 f4	 mov	 DWORD PTR _Size$[ebp], eax

; 263  : 
; 264  :     Segment = (PBL_POOL_SEGMENT) (ULONG_PTR) BlMmAllocatePhysicalRegion(Size, BL_MM_PHYSICAL_REGION_BOOT_LOADER);

  00033	ba 03 00 00 00	 mov	 edx, 3
  00038	8b 4d f4	 mov	 ecx, DWORD PTR _Size$[ebp]
  0003b	e8 00 00 00 00	 call	 ?BlMmAllocatePhysicalRegion@@YI_KKK@Z ; BlMmAllocatePhysicalRegion
  00040	89 45 fc	 mov	 DWORD PTR _Segment$[ebp], eax

; 265  : 
; 266  :     BlRtlZeroMemory(Segment, Size);

  00043	8b 55 f4	 mov	 edx, DWORD PTR _Size$[ebp]
  00046	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  00049	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 267  : 
; 268  :     Segment->Magic1 = BL_POOL_SEGMENT_MAGIC1;

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  00051	c7 01 fc fd fe
	ff		 mov	 DWORD PTR [ecx], -66052	; fffefdfcH

; 269  :     Segment->Magic2 = BL_POOL_SEGMENT_MAGIC2;

  00057	8b 55 fc	 mov	 edx, DWORD PTR _Segment$[ebp]
  0005a	c7 42 20 f8 f9
	fa fb		 mov	 DWORD PTR [edx+32], -67438088 ; fbfaf9f8H

; 270  :     Segment->Start = (ULONG_PTR) Segment;

  00061	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  00064	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  00067	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 271  :     Segment->Size = Size;

  0006a	8b 55 fc	 mov	 edx, DWORD PTR _Segment$[ebp]
  0006d	8b 45 f4	 mov	 eax, DWORD PTR _Size$[ebp]
  00070	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 272  :     Segment->Limit = Segment->Start + Segment->Size;

  00073	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  00076	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00079	8b 45 fc	 mov	 eax, DWORD PTR _Segment$[ebp]
  0007c	03 50 0c	 add	 edx, DWORD PTR [eax+12]
  0007f	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  00082	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 273  :     BlRtlInitializeListHead(&Segment->BlockList);

  00085	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  00088	83 c1 18	 add	 ecx, 24			; 00000018H
  0008b	e8 00 00 00 00	 call	 ?BlRtlInitializeListHead@@YIXPAU_LIST_ENTRY@@@Z ; BlRtlInitializeListHead

; 274  : 
; 275  :     Block = (PBL_POOL_BLOCK) (BL_POOL_ROUND_UP(((ULONG_PTR) (Segment + 1))));

  00090	8b 55 fc	 mov	 edx, DWORD PTR _Segment$[ebp]
  00093	81 c2 23 01 00
	00		 add	 edx, 291		; 00000123H
  00099	81 e2 00 ff ff
	ff		 and	 edx, -256		; ffffff00H
  0009f	89 55 f8	 mov	 DWORD PTR _Block$[ebp], edx

; 276  :     Block->Magic1 = BL_POOL_BLOCK_MAGIC1;

  000a2	8b 45 f8	 mov	 eax, DWORD PTR _Block$[ebp]
  000a5	c7 00 04 03 02
	01		 mov	 DWORD PTR [eax], 16909060 ; 01020304H

; 277  :     Block->Magic2 = BL_POOL_BLOCK_MAGIC2;

  000ab	8b 4d f8	 mov	 ecx, DWORD PTR _Block$[ebp]
  000ae	c7 41 1c 08 07
	06 05		 mov	 DWORD PTR [ecx+28], 84281096 ; 05060708H

; 278  :     Block->Size = Segment->Limit - (ULONG_PTR) Block;

  000b5	8b 55 fc	 mov	 edx, DWORD PTR _Segment$[ebp]
  000b8	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000bb	2b 45 f8	 sub	 eax, DWORD PTR _Block$[ebp]
  000be	8b 4d f8	 mov	 ecx, DWORD PTR _Block$[ebp]
  000c1	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 279  :     Block->State = BL_POOL_FREE;

  000c4	8b 55 f8	 mov	 edx, DWORD PTR _Block$[ebp]
  000c7	c7 42 10 01 00
	00 00		 mov	 DWORD PTR [edx+16], 1

; 280  :     Block->Allocator = NULL;

  000ce	8b 45 f8	 mov	 eax, DWORD PTR _Block$[ebp]
  000d1	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 281  : 
; 282  :     BlRtlInsertTailList(&Segment->BlockList, &Block->Entry);

  000d8	8b 55 f8	 mov	 edx, DWORD PTR _Block$[ebp]
  000db	83 c2 04	 add	 edx, 4
  000de	8b 4d fc	 mov	 ecx, DWORD PTR _Segment$[ebp]
  000e1	83 c1 18	 add	 ecx, 24			; 00000018H
  000e4	e8 00 00 00 00	 call	 ?BlRtlInsertTailList@@YIXPAU_LIST_ENTRY@@0@Z ; BlRtlInsertTailList

; 283  : 
; 284  :     BlRtlInsertTailList(&BlPoolSegmentList, &Segment->Entry);

  000e9	8b 55 fc	 mov	 edx, DWORD PTR _Segment$[ebp]
  000ec	83 c2 04	 add	 edx, 4
  000ef	b9 00 00 00 00	 mov	 ecx, OFFSET ?BlPoolSegmentList@@3U_LIST_ENTRY@@A ; BlPoolSegmentList
  000f4	e8 00 00 00 00	 call	 ?BlRtlInsertTailList@@YIXPAU_LIST_ENTRY@@0@Z ; BlRtlInsertTailList

; 285  : 
; 286  :     BlPoolVerify();

  000f9	e8 00 00 00 00	 call	 ?BlPoolVerify@@YIXXZ	; BlPoolVerify

; 287  : 
; 288  :     return;
; 289  : }

  000fe	8b e5		 mov	 esp, ebp
  00100	5d		 pop	 ebp
  00101	c3		 ret	 0
?BlPoolGrow@@YIXK@Z ENDP				; BlPoolGrow
_TEXT	ENDS
PUBLIC	__$ReturnAddr$
PUBLIC	?BlPoolAllocateBlock@@YIPAXK@Z			; BlPoolAllocateBlock
EXTRN	?BlRtlInsertHeadList@@YIXPAU_LIST_ENTRY@@0@Z:PROC ; BlRtlInsertHeadList
; Function compile flags: /Odtp
;	COMDAT ?BlPoolAllocateBlock@@YIPAXK@Z
_TEXT	SEGMENT
_Size$ = -36						; size = 4
_BlockEntry$ = -32					; size = 4
_Block$ = -28						; size = 4
_BlockHead$ = -24					; size = 4
_SegmentHead$ = -20					; size = 4
_GrowthSize$ = -16					; size = 4
_NewBlock$ = -12					; size = 4
_SegmentEntry$ = -8					; size = 4
_Segment$ = -4						; size = 4
__$ReturnAddr$ = 4					; size = 4
?BlPoolAllocateBlock@@YIPAXK@Z PROC			; BlPoolAllocateBlock, COMDAT
; _Size$ = ecx

; 312  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d dc	 mov	 DWORD PTR _Size$[ebp], ecx

; 313  :     PBL_POOL_BLOCK Block;
; 314  :     PLIST_ENTRY BlockEntry;
; 315  :     PLIST_ENTRY BlockHead;
; 316  :     UINT32 GrowthSize;
; 317  :     PBL_POOL_BLOCK NewBlock;
; 318  :     PBL_POOL_SEGMENT Segment;
; 319  :     PLIST_ENTRY SegmentEntry;
; 320  :     PLIST_ENTRY SegmentHead;
; 321  : 
; 322  :     BlPoolVerify();

  00009	e8 00 00 00 00	 call	 ?BlPoolVerify@@YIXXZ	; BlPoolVerify

; 323  : 
; 324  :     BLASSERT(Size > 0);

  0000e	83 7d dc 00	 cmp	 DWORD PTR _Size$[ebp], 0
  00012	77 0f		 ja	 SHORT $LN11@BlPoolAllo
  00014	ba 44 01 00 00	 mov	 edx, 324		; 00000144H
  00019	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  0001e	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN11@BlPoolAllo:

; 325  : 
; 326  :     Size += sizeof(BL_POOL_BLOCK);

  00023	8b 45 dc	 mov	 eax, DWORD PTR _Size$[ebp]
  00026	83 c0 20	 add	 eax, 32			; 00000020H
  00029	89 45 dc	 mov	 DWORD PTR _Size$[ebp], eax

; 327  :     Size = BL_POOL_ROUND_UP(Size);

  0002c	8b 4d dc	 mov	 ecx, DWORD PTR _Size$[ebp]
  0002f	81 c1 ff 00 00
	00		 add	 ecx, 255		; 000000ffH
  00035	81 e1 00 ff ff
	ff		 and	 ecx, -256		; ffffff00H
  0003b	89 4d dc	 mov	 DWORD PTR _Size$[ebp], ecx

; 328  : 
; 329  :     SegmentHead = &BlPoolSegmentList;

  0003e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _SegmentHead$[ebp], OFFSET ?BlPoolSegmentList@@3U_LIST_ENTRY@@A ; BlPoolSegmentList
$LN10@BlPoolAllo:

; 330  : 
; 331  :     for (;;) {
; 332  : 
; 333  :         for (SegmentEntry = SegmentHead->Flink; SegmentEntry != SegmentHead; SegmentEntry = SegmentEntry->Flink) {

  00045	8b 55 ec	 mov	 edx, DWORD PTR _SegmentHead$[ebp]
  00048	8b 02		 mov	 eax, DWORD PTR [edx]
  0004a	89 45 f8	 mov	 DWORD PTR _SegmentEntry$[ebp], eax
  0004d	eb 08		 jmp	 SHORT $LN8@BlPoolAllo
$LN7@BlPoolAllo:
  0004f	8b 4d f8	 mov	 ecx, DWORD PTR _SegmentEntry$[ebp]
  00052	8b 11		 mov	 edx, DWORD PTR [ecx]
  00054	89 55 f8	 mov	 DWORD PTR _SegmentEntry$[ebp], edx
$LN8@BlPoolAllo:
  00057	8b 45 f8	 mov	 eax, DWORD PTR _SegmentEntry$[ebp]
  0005a	3b 45 ec	 cmp	 eax, DWORD PTR _SegmentHead$[ebp]
  0005d	0f 84 04 01 00
	00		 je	 $LN6@BlPoolAllo

; 334  : 
; 335  :             Segment = CONTAINING_RECORD(SegmentEntry,
; 336  :                                         BL_POOL_SEGMENT,
; 337  :                                         Entry);

  00063	8b 4d f8	 mov	 ecx, DWORD PTR _SegmentEntry$[ebp]
  00066	83 e9 04	 sub	 ecx, 4
  00069	89 4d fc	 mov	 DWORD PTR _Segment$[ebp], ecx

; 338  : 
; 339  :             BlockHead = &Segment->BlockList;

  0006c	8b 55 fc	 mov	 edx, DWORD PTR _Segment$[ebp]
  0006f	83 c2 18	 add	 edx, 24			; 00000018H
  00072	89 55 e8	 mov	 DWORD PTR _BlockHead$[ebp], edx

; 340  : 
; 341  :             for (BlockEntry = BlockHead->Flink; BlockEntry != BlockHead; BlockEntry = BlockEntry->Flink) {

  00075	8b 45 e8	 mov	 eax, DWORD PTR _BlockHead$[ebp]
  00078	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007a	89 4d e0	 mov	 DWORD PTR _BlockEntry$[ebp], ecx
  0007d	eb 08		 jmp	 SHORT $LN5@BlPoolAllo
$LN4@BlPoolAllo:
  0007f	8b 55 e0	 mov	 edx, DWORD PTR _BlockEntry$[ebp]
  00082	8b 02		 mov	 eax, DWORD PTR [edx]
  00084	89 45 e0	 mov	 DWORD PTR _BlockEntry$[ebp], eax
$LN5@BlPoolAllo:
  00087	8b 4d e0	 mov	 ecx, DWORD PTR _BlockEntry$[ebp]
  0008a	3b 4d e8	 cmp	 ecx, DWORD PTR _BlockHead$[ebp]
  0008d	0f 84 cf 00 00
	00		 je	 $LN3@BlPoolAllo

; 342  : 
; 343  :                 Block = CONTAINING_RECORD(BlockEntry,
; 344  :                                           BL_POOL_BLOCK,
; 345  :                                           Entry);

  00093	8b 55 e0	 mov	 edx, DWORD PTR _BlockEntry$[ebp]
  00096	83 ea 04	 sub	 edx, 4
  00099	89 55 e4	 mov	 DWORD PTR _Block$[ebp], edx

; 346  : 
; 347  :                 if ((Block->State == BL_POOL_FREE) && (Block->Size >= Size)) {

  0009c	8b 45 e4	 mov	 eax, DWORD PTR _Block$[ebp]
  0009f	83 78 10 01	 cmp	 DWORD PTR [eax+16], 1
  000a3	0f 85 b4 00 00
	00		 jne	 $LN2@BlPoolAllo
  000a9	8b 4d e4	 mov	 ecx, DWORD PTR _Block$[ebp]
  000ac	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  000af	3b 55 dc	 cmp	 edx, DWORD PTR _Size$[ebp]
  000b2	0f 82 a5 00 00
	00		 jb	 $LN2@BlPoolAllo

; 348  : 
; 349  :                     if (Block->Size > Size) {

  000b8	8b 45 e4	 mov	 eax, DWORD PTR _Block$[ebp]
  000bb	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000be	3b 4d dc	 cmp	 ecx, DWORD PTR _Size$[ebp]
  000c1	76 66		 jbe	 SHORT $LN1@BlPoolAllo

; 350  : 
; 351  :                         NewBlock = (PBL_POOL_BLOCK) ((ULONG_PTR) Block + Size);

  000c3	8b 55 e4	 mov	 edx, DWORD PTR _Block$[ebp]
  000c6	03 55 dc	 add	 edx, DWORD PTR _Size$[ebp]
  000c9	89 55 f4	 mov	 DWORD PTR _NewBlock$[ebp], edx

; 352  : 
; 353  :                         BlRtlZeroMemory(NewBlock, sizeof(BL_POOL_BLOCK));

  000cc	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000d1	8b 4d f4	 mov	 ecx, DWORD PTR _NewBlock$[ebp]
  000d4	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 354  : 
; 355  :                         NewBlock->Magic1 = BL_POOL_BLOCK_MAGIC1;

  000d9	8b 45 f4	 mov	 eax, DWORD PTR _NewBlock$[ebp]
  000dc	c7 00 04 03 02
	01		 mov	 DWORD PTR [eax], 16909060 ; 01020304H

; 356  :                         NewBlock->Magic2 = BL_POOL_BLOCK_MAGIC2;

  000e2	8b 4d f4	 mov	 ecx, DWORD PTR _NewBlock$[ebp]
  000e5	c7 41 1c 08 07
	06 05		 mov	 DWORD PTR [ecx+28], 84281096 ; 05060708H

; 357  :                         NewBlock->Size = Block->Size - Size;

  000ec	8b 55 e4	 mov	 edx, DWORD PTR _Block$[ebp]
  000ef	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000f2	2b 45 dc	 sub	 eax, DWORD PTR _Size$[ebp]
  000f5	8b 4d f4	 mov	 ecx, DWORD PTR _NewBlock$[ebp]
  000f8	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 358  :                         NewBlock->State = BL_POOL_FREE;

  000fb	8b 55 f4	 mov	 edx, DWORD PTR _NewBlock$[ebp]
  000fe	c7 42 10 01 00
	00 00		 mov	 DWORD PTR [edx+16], 1

; 359  :                         NewBlock->Allocator = NULL;

  00105	8b 45 f4	 mov	 eax, DWORD PTR _NewBlock$[ebp]
  00108	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 360  : 
; 361  :                         BlRtlInsertHeadList(&Block->Entry, &NewBlock->Entry);

  0010f	8b 55 f4	 mov	 edx, DWORD PTR _NewBlock$[ebp]
  00112	83 c2 04	 add	 edx, 4
  00115	8b 4d e4	 mov	 ecx, DWORD PTR _Block$[ebp]
  00118	83 c1 04	 add	 ecx, 4
  0011b	e8 00 00 00 00	 call	 ?BlRtlInsertHeadList@@YIXPAU_LIST_ENTRY@@0@Z ; BlRtlInsertHeadList

; 362  : 
; 363  :                         Block->Size = Size;

  00120	8b 4d e4	 mov	 ecx, DWORD PTR _Block$[ebp]
  00123	8b 55 dc	 mov	 edx, DWORD PTR _Size$[ebp]
  00126	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$LN1@BlPoolAllo:

; 364  :                     }
; 365  : 
; 366  :                     Block->State = BL_POOL_BUSY;

  00129	8b 45 e4	 mov	 eax, DWORD PTR _Block$[ebp]
  0012c	c7 40 10 02 00
	00 00		 mov	 DWORD PTR [eax+16], 2

; 367  :                     Block->Allocator = _ReturnAddress();

  00133	8b 4d 04	 mov	 ecx, DWORD PTR __$ReturnAddr$[ebp]
  00136	8b 55 e4	 mov	 edx, DWORD PTR _Block$[ebp]
  00139	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 368  : 
; 369  :                     BlRtlZeroMemory(Block + 1, Block->Size - sizeof(BL_POOL_BLOCK));

  0013c	8b 45 e4	 mov	 eax, DWORD PTR _Block$[ebp]
  0013f	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00142	83 ea 20	 sub	 edx, 32			; 00000020H
  00145	8b 4d e4	 mov	 ecx, DWORD PTR _Block$[ebp]
  00148	83 c1 20	 add	 ecx, 32			; 00000020H
  0014b	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 370  : 
; 371  :                     BlPoolVerify();

  00150	e8 00 00 00 00	 call	 ?BlPoolVerify@@YIXXZ	; BlPoolVerify

; 372  : 
; 373  :                     return (Block + 1);

  00155	8b 45 e4	 mov	 eax, DWORD PTR _Block$[ebp]
  00158	83 c0 20	 add	 eax, 32			; 00000020H
  0015b	eb 29		 jmp	 SHORT $LN12@BlPoolAllo
$LN2@BlPoolAllo:

; 374  :                 }
; 375  :             }

  0015d	e9 1d ff ff ff	 jmp	 $LN4@BlPoolAllo
$LN3@BlPoolAllo:

; 376  :         }

  00162	e9 e8 fe ff ff	 jmp	 $LN7@BlPoolAllo
$LN6@BlPoolAllo:

; 377  : 
; 378  :         GrowthSize = BL_POOL_SEGMENT_ROUND_UP(Size);

  00167	8b 4d dc	 mov	 ecx, DWORD PTR _Size$[ebp]
  0016a	81 c1 ff 7f 00
	00		 add	 ecx, 32767		; 00007fffH
  00170	81 e1 00 80 ff
	ff		 and	 ecx, -32768		; ffff8000H
  00176	89 4d f0	 mov	 DWORD PTR _GrowthSize$[ebp], ecx

; 379  : 
; 380  :         BlPoolGrow(GrowthSize);

  00179	8b 4d f0	 mov	 ecx, DWORD PTR _GrowthSize$[ebp]
  0017c	e8 00 00 00 00	 call	 ?BlPoolGrow@@YIXK@Z	; BlPoolGrow

; 381  :     }

  00181	e9 bf fe ff ff	 jmp	 $LN10@BlPoolAllo
$LN12@BlPoolAllo:

; 382  : }

  00186	8b e5		 mov	 esp, ebp
  00188	5d		 pop	 ebp
  00189	c3		 ret	 0
?BlPoolAllocateBlock@@YIPAXK@Z ENDP			; BlPoolAllocateBlock
_TEXT	ENDS
PUBLIC	?BlPoolFreeBlock@@YIXPAX@Z			; BlPoolFreeBlock
; Function compile flags: /Odtp
;	COMDAT ?BlPoolFreeBlock@@YIXPAX@Z
_TEXT	SEGMENT
_P$ = -8						; size = 4
_Block$ = -4						; size = 4
?BlPoolFreeBlock@@YIXPAX@Z PROC				; BlPoolFreeBlock, COMDAT
; _P$ = ecx

; 401  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _P$[ebp], ecx

; 402  :     PBL_POOL_BLOCK Block;
; 403  : 
; 404  :     BlPoolVerify();

  00009	e8 00 00 00 00	 call	 ?BlPoolVerify@@YIXXZ	; BlPoolVerify

; 405  : 
; 406  :     BLASSERT(((ULONG_PTR) P % __alignof(BL_POOL_BLOCK)) == 0);

  0000e	8b 45 f8	 mov	 eax, DWORD PTR _P$[ebp]
  00011	33 d2		 xor	 edx, edx
  00013	b9 04 00 00 00	 mov	 ecx, 4
  00018	f7 f1		 div	 ecx
  0001a	85 d2		 test	 edx, edx
  0001c	74 0f		 je	 SHORT $LN3@BlPoolFree
  0001e	ba 96 01 00 00	 mov	 edx, 406		; 00000196H
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00028	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN3@BlPoolFree:

; 407  : 
; 408  :     Block = ((PBL_POOL_BLOCK) P) - 1;

  0002d	8b 55 f8	 mov	 edx, DWORD PTR _P$[ebp]
  00030	83 ea 20	 sub	 edx, 32			; 00000020H
  00033	89 55 fc	 mov	 DWORD PTR _Block$[ebp], edx

; 409  : 
; 410  :     BLASSERT(((ULONG_PTR) Block % BL_POOL_GRANULARITY) == 0);

  00036	8b 45 fc	 mov	 eax, DWORD PTR _Block$[ebp]
  00039	33 d2		 xor	 edx, edx
  0003b	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00040	f7 f1		 div	 ecx
  00042	85 d2		 test	 edx, edx
  00044	74 0f		 je	 SHORT $LN2@BlPoolFree
  00046	ba 9a 01 00 00	 mov	 edx, 410		; 0000019aH
  0004b	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00050	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN2@BlPoolFree:

; 411  : 
; 412  :     BLASSERT(Block->State == BL_POOL_BUSY);

  00055	8b 55 fc	 mov	 edx, DWORD PTR _Block$[ebp]
  00058	83 7a 10 02	 cmp	 DWORD PTR [edx+16], 2
  0005c	74 0f		 je	 SHORT $LN1@BlPoolFree
  0005e	ba 9c 01 00 00	 mov	 edx, 412		; 0000019cH
  00063	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0L@IABHNPNF@blpool?4cpp?$AA@
  00068	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN1@BlPoolFree:

; 413  : 
; 414  :     Block->State = BL_POOL_FREE;

  0006d	8b 45 fc	 mov	 eax, DWORD PTR _Block$[ebp]
  00070	c7 40 10 01 00
	00 00		 mov	 DWORD PTR [eax+16], 1

; 415  :     Block->Allocator = NULL;

  00077	8b 4d fc	 mov	 ecx, DWORD PTR _Block$[ebp]
  0007a	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 416  : 
; 417  :     //
; 418  :     // AIFIX: Check for adjacent free blocks and coalesce.
; 419  :     //
; 420  : 
; 421  :     BlPoolVerify();

  00081	e8 00 00 00 00	 call	 ?BlPoolVerify@@YIXXZ	; BlPoolVerify

; 422  : 
; 423  :     return;
; 424  : }

  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
?BlPoolFreeBlock@@YIXPAX@Z ENDP				; BlPoolFreeBlock
_TEXT	ENDS
END
