; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\OSes\VERVE\verify\src\Trusted\BootLoader\SingLdrPc\blkd1394.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
_Kd1394Data DD	01H DUP (?)
_KdRegisters DD	01H DUP (?)
_BSS	ENDS
PUBLIC	?BlKd1394StallExecution@@YIKK@Z			; BlKd1394StallExecution
EXTRN	?BlKdSpin@@YIXXZ:PROC				; BlKdSpin
; Function compile flags: /Odtp
; File d:\oses\verve\verify\src\trusted\bootloader\singldrpc\blkd1394.cpp
;	COMDAT ?BlKd1394StallExecution@@YIKK@Z
_TEXT	SEGMENT
_LoopCount$ = -16					; size = 4
_k$ = -12						; size = 4
_b$ = -8						; size = 4
_i$ = -4						; size = 4
?BlKd1394StallExecution@@YIKK@Z PROC			; BlKd1394StallExecution, COMDAT
; _LoopCount$ = ecx

; 145  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _LoopCount$[ebp], ecx

; 146  :     volatile UINT32 b;
; 147  :     volatile UINT32 k;
; 148  :     volatile UINT32 i;
; 149  : 
; 150  :     b = 1;

  00009	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _b$[ebp], 1

; 151  : 
; 152  :     for (k = 0; k < LoopCount; k++) {

  00010	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _k$[ebp], 0
  00017	eb 09		 jmp	 SHORT $LN6@BlKd1394St
$LN5@BlKd1394St:
  00019	8b 45 f4	 mov	 eax, DWORD PTR _k$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f4	 mov	 DWORD PTR _k$[ebp], eax
$LN6@BlKd1394St:
  00022	8b 4d f4	 mov	 ecx, DWORD PTR _k$[ebp]
  00025	3b 4d f0	 cmp	 ecx, DWORD PTR _LoopCount$[ebp]
  00028	73 35		 jae	 SHORT $LN4@BlKd1394St

; 153  : 
; 154  :         BlKdSpin();

  0002a	e8 00 00 00 00	 call	 ?BlKdSpin@@YIXXZ	; BlKdSpin

; 155  : 
; 156  :         for (i = 1; i < 10000; i++) {

  0002f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  00036	eb 09		 jmp	 SHORT $LN3@BlKd1394St
$LN2@BlKd1394St:
  00038	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0003b	83 c2 01	 add	 edx, 1
  0003e	89 55 fc	 mov	 DWORD PTR _i$[ebp], edx
$LN3@BlKd1394St:
  00041	81 7d fc 10 27
	00 00		 cmp	 DWORD PTR _i$[ebp], 10000 ; 00002710H
  00048	73 13		 jae	 SHORT $LN1@BlKd1394St

; 157  : 
; 158  :             b = b * (i>>k);

  0004a	8a 4d f4	 mov	 cl, BYTE PTR _k$[ebp]
  0004d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00050	d3 e8		 shr	 eax, cl
  00052	8b 4d f8	 mov	 ecx, DWORD PTR _b$[ebp]
  00055	0f af c8	 imul	 ecx, eax
  00058	89 4d f8	 mov	 DWORD PTR _b$[ebp], ecx

; 159  :         }

  0005b	eb db		 jmp	 SHORT $LN2@BlKd1394St
$LN1@BlKd1394St:

; 160  :     }

  0005d	eb ba		 jmp	 SHORT $LN5@BlKd1394St
$LN4@BlKd1394St:

; 161  :     return b;

  0005f	8b 45 f8	 mov	 eax, DWORD PTR _b$[ebp]

; 162  : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?BlKd1394StallExecution@@YIKK@Z ENDP			; BlKd1394StallExecution
_TEXT	ENDS
PUBLIC	?BlKd1394ByteSwap@@YIKK@Z			; BlKd1394ByteSwap
; Function compile flags: /Odtp
;	COMDAT ?BlKd1394ByteSwap@@YIKK@Z
_TEXT	SEGMENT
_Source$ = -4						; size = 4
?BlKd1394ByteSwap@@YIKK@Z PROC				; BlKd1394ByteSwap, COMDAT
; _Source$ = ecx

; 185  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _Source$[ebp], ecx

; 186  :     return (((Source)              << (8 * 3)) |
; 187  :             ((Source & 0x0000FF00) << (8 * 1)) |
; 188  :             ((Source & 0x00FF0000) >> (8 * 1)) |
; 189  :             ((Source)              >> (8 * 3)));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _Source$[ebp]
  0000a	c1 e0 18	 shl	 eax, 24			; 00000018H
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _Source$[ebp]
  00010	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00016	c1 e1 08	 shl	 ecx, 8
  00019	0b c1		 or	 eax, ecx
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _Source$[ebp]
  0001e	81 e2 00 00 ff
	00		 and	 edx, 16711680		; 00ff0000H
  00024	c1 ea 08	 shr	 edx, 8
  00027	0b c2		 or	 eax, edx
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _Source$[ebp]
  0002c	c1 e9 18	 shr	 ecx, 24			; 00000018H
  0002f	0b c1		 or	 eax, ecx

; 190  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?BlKd1394ByteSwap@@YIKK@Z ENDP				; BlKd1394ByteSwap
_TEXT	ENDS
PUBLIC	?BlKd1394Crc16@@YIKKK@Z				; BlKd1394Crc16
; Function compile flags: /Odtp
;	COMDAT ?BlKd1394Crc16@@YIKKK@Z
_TEXT	SEGMENT
_Check$ = -20						; size = 4
_Data$ = -16						; size = 4
_Sum$4057 = -12						; size = 4
_Next$ = -8						; size = 4
_Shift$ = -4						; size = 4
?BlKd1394Crc16@@YIKKK@Z PROC				; BlKd1394Crc16, COMDAT
; _Data$ = ecx
; _Check$ = edx

; 217  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 55 ec	 mov	 DWORD PTR _Check$[ebp], edx
  00009	89 4d f0	 mov	 DWORD PTR _Data$[ebp], ecx

; 218  :     UINT32 Next = Check;

  0000c	8b 45 ec	 mov	 eax, DWORD PTR _Check$[ebp]
  0000f	89 45 f8	 mov	 DWORD PTR _Next$[ebp], eax

; 219  :     INT32 Shift;
; 220  : 
; 221  :     for (Shift = 28; Shift >= 0; Shift -= 4) {

  00012	c7 45 fc 1c 00
	00 00		 mov	 DWORD PTR _Shift$[ebp], 28 ; 0000001cH
  00019	eb 09		 jmp	 SHORT $LN3@BlKd1394Cr
$LN2@BlKd1394Cr:
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _Shift$[ebp]
  0001e	83 e9 04	 sub	 ecx, 4
  00021	89 4d fc	 mov	 DWORD PTR _Shift$[ebp], ecx
$LN3@BlKd1394Cr:
  00024	83 7d fc 00	 cmp	 DWORD PTR _Shift$[ebp], 0
  00028	7c 34		 jl	 SHORT $LN1@BlKd1394Cr

; 222  :         UINT32 Sum;
; 223  : 
; 224  :         Sum = ((Next >> 12) ^ (Data >> Shift)) & 0xf;

  0002a	8b 55 f8	 mov	 edx, DWORD PTR _Next$[ebp]
  0002d	c1 ea 0c	 shr	 edx, 12			; 0000000cH
  00030	8b 45 f0	 mov	 eax, DWORD PTR _Data$[ebp]
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _Shift$[ebp]
  00036	d3 e8		 shr	 eax, cl
  00038	33 d0		 xor	 edx, eax
  0003a	83 e2 0f	 and	 edx, 15			; 0000000fH
  0003d	89 55 f4	 mov	 DWORD PTR _Sum$4057[ebp], edx

; 225  :         Next = (Next << 4) ^ (Sum << 12) ^ (Sum << 5) ^ (Sum);

  00040	8b 4d f8	 mov	 ecx, DWORD PTR _Next$[ebp]
  00043	c1 e1 04	 shl	 ecx, 4
  00046	8b 55 f4	 mov	 edx, DWORD PTR _Sum$4057[ebp]
  00049	c1 e2 0c	 shl	 edx, 12			; 0000000cH
  0004c	33 ca		 xor	 ecx, edx
  0004e	8b 45 f4	 mov	 eax, DWORD PTR _Sum$4057[ebp]
  00051	c1 e0 05	 shl	 eax, 5
  00054	33 c8		 xor	 ecx, eax
  00056	33 4d f4	 xor	 ecx, DWORD PTR _Sum$4057[ebp]
  00059	89 4d f8	 mov	 DWORD PTR _Next$[ebp], ecx

; 226  :     }

  0005c	eb bd		 jmp	 SHORT $LN2@BlKd1394Cr
$LN1@BlKd1394Cr:

; 227  :     return (Next & 0xFFFF);

  0005e	8b 45 f8	 mov	 eax, DWORD PTR _Next$[ebp]
  00061	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH

; 228  : }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
?BlKd1394Crc16@@YIKKK@Z ENDP				; BlKd1394Crc16
_TEXT	ENDS
PUBLIC	?BlKd1394CalculateCrc@@YIGPAKK@Z		; BlKd1394CalculateCrc
; Function compile flags: /Odtp
;	COMDAT ?BlKd1394CalculateCrc@@YIGPAKK@Z
_TEXT	SEGMENT
_Length$ = -16						; size = 4
_Quadlet$ = -12						; size = 4
_Temp$ = -8						; size = 4
_Index$ = -4						; size = 4
?BlKd1394CalculateCrc@@YIGPAKK@Z PROC			; BlKd1394CalculateCrc, COMDAT
; _Quadlet$ = ecx
; _Length$ = edx

; 254  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 55 f0	 mov	 DWORD PTR _Length$[ebp], edx
  00009	89 4d f4	 mov	 DWORD PTR _Quadlet$[ebp], ecx

; 255  :     UINT32 Temp = 0;

  0000c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Temp$[ebp], 0

; 256  :     UINT32 Index;
; 257  : 
; 258  :     Temp = 0;

  00013	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Temp$[ebp], 0

; 259  : 
; 260  :     for (Index = 0; Index < Length; Index++) {

  0001a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0
  00021	eb 09		 jmp	 SHORT $LN3@BlKd1394Ca
$LN2@BlKd1394Ca:
  00023	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00026	83 c0 01	 add	 eax, 1
  00029	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax
$LN3@BlKd1394Ca:
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  0002f	3b 4d f0	 cmp	 ecx, DWORD PTR _Length$[ebp]
  00032	73 16		 jae	 SHORT $LN1@BlKd1394Ca

; 261  : 
; 262  :         Temp = BlKd1394Crc16(Quadlet[Index], Temp);

  00034	8b 55 f8	 mov	 edx, DWORD PTR _Temp$[ebp]
  00037	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR _Quadlet$[ebp]
  0003d	8b 0c 81	 mov	 ecx, DWORD PTR [ecx+eax*4]
  00040	e8 00 00 00 00	 call	 ?BlKd1394Crc16@@YIKKK@Z	; BlKd1394Crc16
  00045	89 45 f8	 mov	 DWORD PTR _Temp$[ebp], eax

; 263  :     }

  00048	eb d9		 jmp	 SHORT $LN2@BlKd1394Ca
$LN1@BlKd1394Ca:

; 264  : 
; 265  :     return (UINT16)Temp;

  0004a	66 8b 45 f8	 mov	 ax, WORD PTR _Temp$[ebp]

; 266  : }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?BlKd1394CalculateCrc@@YIGPAKK@Z ENDP			; BlKd1394CalculateCrc
_TEXT	ENDS
PUBLIC	?BlKd1394InitHardware@@YIEGPAX@Z		; BlKd1394InitHardware
EXTRN	?BlRtlZeroMemory@@YIXPAXK@Z:PROC		; BlRtlZeroMemory
EXTRN	?BlSingularityOhci1394Buffer@@3PAEA:BYTE	; BlSingularityOhci1394Buffer
; Function compile flags: /Odtp
;	COMDAT ?BlKd1394InitHardware@@YIEGPAX@Z
_TEXT	SEGMENT
tv185 = -62						; size = 2
_IoRegion$ = -60					; size = 4
_Channel$ = -56						; size = 2
_Data$ = -49						; size = 1
_retry$ = -48						; size = 4
_LinkControl$ = -44					; size = 4
_DirInfo$ = -40						; size = 4
_ulVersion$ = -36					; size = 4
_PhyControl$ = -32					; size = 4
_Registers$ = -28					; size = 4
_ConfigRomHeader$ = -24					; size = 4
_HCControl$ = -20					; size = 4
_NodeId$ = -16						; size = 4
_MajorVersion$ = -9					; size = 1
_BusOptions$ = -8					; size = 4
_CromEntry$ = -4					; size = 4
?BlKd1394InitHardware@@YIEGPAX@Z PROC			; BlKd1394InitHardware, COMDAT
; _Channel$ = cx
; _IoRegion$ = edx

; 292  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	89 55 c4	 mov	 DWORD PTR _IoRegion$[ebp], edx
  00009	66 89 4d c8	 mov	 WORD PTR _Channel$[ebp], cx

; 293  :     UINT32 ulVersion;
; 294  :     UINT8 MajorVersion;
; 295  :     HC_CONTROL_REGISTER HCControl;
; 296  :     UINT32 retry;
; 297  :     LINK_CONTROL_REGISTER LinkControl;
; 298  :     NODE_ID_REGISTER NodeId;
; 299  :     BUS_OPTIONS_REGISTER BusOptions;
; 300  :     CONFIG_ROM_INFO ConfigRomHeader;
; 301  :     IMMEDIATE_ENTRY CromEntry;
; 302  :     DIRECTORY_INFO DirInfo;
; 303  :     PHY_CONTROL_REGISTER PhyControl;
; 304  :     UINT8 Data;
; 305  :     volatile OHCI_REGISTER_MAP * Registers;
; 306  : 
; 307  : #if KD_VERBOSE
; 308  : 
; 309  :     BlVideoPrintf("1394: IoRegion: %p\n", IoRegion);
; 310  : 
; 311  : #endif
; 312  : 
; 313  :     //
; 314  :     // Note: Kd1394Data must be in the low 32-bits of address space due to
; 315  :     //       limits on valid 1394 DMA addresses.  It must also be contiguous.
; 316  :     //       It must be in the low 24-bits of address space to statisfy KD.
; 317  :     //
; 318  : 
; 319  :     Kd1394Data = (DEBUG_1394_DATA *) BlSingularityOhci1394Buffer;

  0000d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _Kd1394Data, OFFSET ?BlSingularityOhci1394Buffer@@3PAEA ; BlSingularityOhci1394Buffer

; 320  :     BlRtlZeroMemory(Kd1394Data, sizeof(*Kd1394Data));

  00017	ba 00 24 00 00	 mov	 edx, 9216		; 00002400H
  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00022	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 321  : 
; 322  :     //
; 323  :     // Get our base address.
; 324  :     //
; 325  : 
; 326  :     Registers = (volatile OHCI_REGISTER_MAP *)IoRegion;

  00027	8b 45 c4	 mov	 eax, DWORD PTR _IoRegion$[ebp]
  0002a	89 45 e4	 mov	 DWORD PTR _Registers$[ebp], eax

; 327  : 
; 328  :     //
; 329  :     // Initialize our config info for host debugger to read.
; 330  :     //
; 331  : 
; 332  :     Kd1394Data->Config.Tag = DEBUG_1394_CONFIG_TAG;

  0002d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00033	c7 81 e0 03 00
	00 ba ba ba ba	 mov	 DWORD PTR [ecx+992], -1162167622 ; babababaH

; 333  :     Kd1394Data->Config.MajorVersion = DEBUG_1394_MAJOR_VERSION;

  0003d	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Kd1394Data
  00043	66 c7 82 e4 03
	00 00 01 00	 mov	 WORD PTR [edx+996], 1

; 334  :     Kd1394Data->Config.MinorVersion = DEBUG_1394_MINOR_VERSION;

  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  00051	66 c7 80 e6 03
	00 00 00 00	 mov	 WORD PTR [eax+998], 0

; 335  :     Kd1394Data->Config.Id = Channel;

  0005a	0f b7 4d c8	 movzx	 ecx, WORD PTR _Channel$[ebp]
  0005e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Kd1394Data
  00064	89 8a e8 03 00
	00		 mov	 DWORD PTR [edx+1000], ecx

; 336  :     Kd1394Data->Config.BusPresent = FALSE;

  0006a	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  0006f	c7 80 ec 03 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1004], 0

; 337  :     Kd1394Data->Config.SendPacket = (UINT64) &Kd1394Data->SendPacket;

  00079	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  0007e	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  00083	99		 cdq
  00084	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  0008a	89 81 f0 03 00
	00		 mov	 DWORD PTR [ecx+1008], eax
  00090	89 91 f4 03 00
	00		 mov	 DWORD PTR [ecx+1012], edx

; 338  :     Kd1394Data->Config.ReceivePacket = (UINT64) &Kd1394Data->ReceivePacket;

  00096	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  0009b	05 00 14 00 00	 add	 eax, 5120		; 00001400H
  000a0	99		 cdq
  000a1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  000a7	89 81 f8 03 00
	00		 mov	 DWORD PTR [ecx+1016], eax
  000ad	89 91 fc 03 00
	00		 mov	 DWORD PTR [ecx+1020], edx

; 339  : 
; 340  :     //
; 341  :     // Get the transport version.
; 342  :     //
; 343  : 
; 344  :     ulVersion = Registers->Version.all;

  000b3	8b 55 e4	 mov	 edx, DWORD PTR _Registers$[ebp]
  000b6	8b 02		 mov	 eax, DWORD PTR [edx]
  000b8	89 45 dc	 mov	 DWORD PTR _ulVersion$[ebp], eax

; 345  :     MajorVersion = (UINT8)(ulVersion >> 16);

  000bb	8b 4d dc	 mov	 ecx, DWORD PTR _ulVersion$[ebp]
  000be	c1 e9 10	 shr	 ecx, 16			; 00000010H
  000c1	88 4d f7	 mov	 BYTE PTR _MajorVersion$[ebp], cl

; 346  : 
; 347  :     //
; 348  :     // Make sure we have a valid version.
; 349  :     //
; 350  : 
; 351  :     if (MajorVersion != 1) { // INVESTIGATE

  000c4	0f b6 55 f7	 movzx	 edx, BYTE PTR _MajorVersion$[ebp]
  000c8	83 fa 01	 cmp	 edx, 1
  000cb	74 07		 je	 SHORT $LN16@BlKd1394In

; 352  : 
; 353  : #if KD_VERBOSE
; 354  : 
; 355  :         BlVideoPrintf("1394: MajorVersion != 1\n");
; 356  : 
; 357  : #endif
; 358  : 
; 359  :         return FALSE;

  000cd	32 c0		 xor	 al, al
  000cf	e9 6b 04 00 00	 jmp	 $LN17@BlKd1394In
$LN16@BlKd1394In:

; 360  :     }
; 361  : 
; 362  :     //
; 363  :     // Soft reset to initialize the controller.
; 364  :     //
; 365  : 
; 366  :     HCControl.all = 0;

  000d4	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _HCControl$[ebp], 0

; 367  :     HCControl.SoftReset = TRUE;

  000db	8b 45 ec	 mov	 eax, DWORD PTR _HCControl$[ebp]
  000de	0d 00 00 01 00	 or	 eax, 65536		; 00010000H
  000e3	89 45 ec	 mov	 DWORD PTR _HCControl$[ebp], eax

; 368  :     Registers->HCControlSet.all = HCControl.all;

  000e6	8b 4d e4	 mov	 ecx, DWORD PTR _Registers$[ebp]
  000e9	8b 55 ec	 mov	 edx, DWORD PTR _HCControl$[ebp]
  000ec	89 51 50	 mov	 DWORD PTR [ecx+80], edx

; 369  : 
; 370  :     //
; 371  :     // wait until reset completes.
; 372  :     //
; 373  : 
; 374  :     retry = 1000; // ??

  000ef	c7 45 d0 e8 03
	00 00		 mov	 DWORD PTR _retry$[ebp], 1000 ; 000003e8H
$LN15@BlKd1394In:

; 375  : 
; 376  :     do {
; 377  : 
; 378  :         HCControl.all = Registers->HCControlSet.all;

  000f6	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  000f9	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  000fc	89 4d ec	 mov	 DWORD PTR _HCControl$[ebp], ecx

; 379  : 
; 380  :         BlKd1394StallExecution(1);

  000ff	b9 01 00 00 00	 mov	 ecx, 1
  00104	e8 00 00 00 00	 call	 ?BlKd1394StallExecution@@YIKK@Z ; BlKd1394StallExecution

; 381  : 
; 382  :     } while ((HCControl.SoftReset) && (--retry));

  00109	8b 55 ec	 mov	 edx, DWORD PTR _HCControl$[ebp]
  0010c	c1 ea 10	 shr	 edx, 16			; 00000010H
  0010f	83 e2 01	 and	 edx, 1
  00112	74 0b		 je	 SHORT $LN13@BlKd1394In
  00114	8b 45 d0	 mov	 eax, DWORD PTR _retry$[ebp]
  00117	83 e8 01	 sub	 eax, 1
  0011a	89 45 d0	 mov	 DWORD PTR _retry$[ebp], eax
  0011d	75 d7		 jne	 SHORT $LN15@BlKd1394In
$LN13@BlKd1394In:

; 383  : 
; 384  :     if (retry == 0) {

  0011f	83 7d d0 00	 cmp	 DWORD PTR _retry$[ebp], 0
  00123	75 07		 jne	 SHORT $LN11@BlKd1394In

; 385  : 
; 386  : #if KD_VERBOSE
; 387  : 
; 388  :         BlVideoPrintf("1394: Reset failed\n");
; 389  : 
; 390  : #endif
; 391  : 
; 392  :         return FALSE;

  00125	32 c0		 xor	 al, al
  00127	e9 13 04 00 00	 jmp	 $LN17@BlKd1394In
$LN11@BlKd1394In:

; 393  :     }
; 394  : 
; 395  :     //
; 396  :     // Enable link to phy communication.
; 397  :     //
; 398  : 
; 399  :     HCControl.all = 0;

  0012c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _HCControl$[ebp], 0

; 400  :     HCControl.Lps = TRUE;

  00133	8b 4d ec	 mov	 ecx, DWORD PTR _HCControl$[ebp]
  00136	81 c9 00 00 08
	00		 or	 ecx, 524288		; 00080000H
  0013c	89 4d ec	 mov	 DWORD PTR _HCControl$[ebp], ecx

; 401  :     Registers->HCControlSet.all = HCControl.all;

  0013f	8b 55 e4	 mov	 edx, DWORD PTR _Registers$[ebp]
  00142	8b 45 ec	 mov	 eax, DWORD PTR _HCControl$[ebp]
  00145	89 42 50	 mov	 DWORD PTR [edx+80], eax

; 402  : 
; 403  :     BlKd1394StallExecution(20);

  00148	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0014d	e8 00 00 00 00	 call	 ?BlKd1394StallExecution@@YIKK@Z ; BlKd1394StallExecution

; 404  : 
; 405  :     //
; 406  :     // Initialize HCControl register
; 407  :     // Send data in little-endian order (i.e. do byte swap).
; 408  :     //
; 409  : 
; 410  :     HCControl.all = 0;

  00152	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _HCControl$[ebp], 0

; 411  :     HCControl.NoByteSwapData = TRUE;

  00159	8b 4d ec	 mov	 ecx, DWORD PTR _HCControl$[ebp]
  0015c	81 c9 00 00 00
	40		 or	 ecx, 1073741824		; 40000000H
  00162	89 4d ec	 mov	 DWORD PTR _HCControl$[ebp], ecx

; 412  :     Registers->HCControlClear.all = HCControl.all;

  00165	8b 55 e4	 mov	 edx, DWORD PTR _Registers$[ebp]
  00168	8b 45 ec	 mov	 eax, DWORD PTR _HCControl$[ebp]
  0016b	89 42 54	 mov	 DWORD PTR [edx+84], eax

; 413  : 
; 414  :     //
; 415  :     // Enable posted writes.
; 416  :     //
; 417  : 
; 418  :     HCControl.all = 0;

  0016e	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _HCControl$[ebp], 0

; 419  :     HCControl.PostedWriteEnable = TRUE;

  00175	8b 4d ec	 mov	 ecx, DWORD PTR _HCControl$[ebp]
  00178	81 c9 00 00 04
	00		 or	 ecx, 262144		; 00040000H
  0017e	89 4d ec	 mov	 DWORD PTR _HCControl$[ebp], ecx

; 420  :     Registers->HCControlSet.all = HCControl.all;

  00181	8b 55 e4	 mov	 edx, DWORD PTR _Registers$[ebp]
  00184	8b 45 ec	 mov	 eax, DWORD PTR _HCControl$[ebp]
  00187	89 42 50	 mov	 DWORD PTR [edx+80], eax

; 421  : 
; 422  :     //
; 423  :     // Setup the link control.
; 424  :     //
; 425  : 
; 426  :     LinkControl.all = 0;

  0018a	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _LinkControl$[ebp], 0

; 427  :     LinkControl.CycleTimerEnable = TRUE;

  00191	8b 4d d4	 mov	 ecx, DWORD PTR _LinkControl$[ebp]
  00194	81 c9 00 00 10
	00		 or	 ecx, 1048576		; 00100000H
  0019a	89 4d d4	 mov	 DWORD PTR _LinkControl$[ebp], ecx

; 428  :     LinkControl.CycleMaster = TRUE;

  0019d	8b 55 d4	 mov	 edx, DWORD PTR _LinkControl$[ebp]
  001a0	81 ca 00 00 20
	00		 or	 edx, 2097152		; 00200000H
  001a6	89 55 d4	 mov	 DWORD PTR _LinkControl$[ebp], edx

; 429  :     LinkControl.RcvPhyPkt = TRUE;

  001a9	8b 45 d4	 mov	 eax, DWORD PTR _LinkControl$[ebp]
  001ac	0d 00 04 00 00	 or	 eax, 1024		; 00000400H
  001b1	89 45 d4	 mov	 DWORD PTR _LinkControl$[ebp], eax

; 430  :     LinkControl.RcvSelfId = TRUE;

  001b4	8b 4d d4	 mov	 ecx, DWORD PTR _LinkControl$[ebp]
  001b7	81 c9 00 02 00
	00		 or	 ecx, 512		; 00000200H
  001bd	89 4d d4	 mov	 DWORD PTR _LinkControl$[ebp], ecx

; 431  :     Registers->LinkControlClear.all = LinkControl.all;

  001c0	8b 55 e4	 mov	 edx, DWORD PTR _Registers$[ebp]
  001c3	8b 45 d4	 mov	 eax, DWORD PTR _LinkControl$[ebp]
  001c6	89 82 e4 00 00
	00		 mov	 DWORD PTR [edx+228], eax

; 432  : 
; 433  :     LinkControl.all = 0;

  001cc	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _LinkControl$[ebp], 0

; 434  :     LinkControl.CycleTimerEnable = TRUE;

  001d3	8b 4d d4	 mov	 ecx, DWORD PTR _LinkControl$[ebp]
  001d6	81 c9 00 00 10
	00		 or	 ecx, 1048576		; 00100000H
  001dc	89 4d d4	 mov	 DWORD PTR _LinkControl$[ebp], ecx

; 435  :     LinkControl.CycleMaster = TRUE;

  001df	8b 55 d4	 mov	 edx, DWORD PTR _LinkControl$[ebp]
  001e2	81 ca 00 00 20
	00		 or	 edx, 2097152		; 00200000H
  001e8	89 55 d4	 mov	 DWORD PTR _LinkControl$[ebp], edx

; 436  :     Registers->LinkControlSet.all = LinkControl.all;

  001eb	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  001ee	8b 4d d4	 mov	 ecx, DWORD PTR _LinkControl$[ebp]
  001f1	89 88 e0 00 00
	00		 mov	 DWORD PTR [eax+224], ecx

; 437  : 
; 438  :     //
; 439  :     // Set the bus number (hardcoded to 0x3FF) - ??? what about node id??
; 440  :     //
; 441  : 
; 442  :     NodeId.all = 0;

  001f7	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _NodeId$[ebp], 0

; 443  :     NodeId.BusId = (UINT16)0x3FF;

  001fe	8b 55 f0	 mov	 edx, DWORD PTR _NodeId$[ebp]
  00201	81 ca c0 ff 00
	00		 or	 edx, 65472		; 0000ffc0H
  00207	89 55 f0	 mov	 DWORD PTR _NodeId$[ebp], edx

; 444  :     Registers->NodeId.all = NodeId.all;

  0020a	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  0020d	8b 4d f0	 mov	 ecx, DWORD PTR _NodeId$[ebp]
  00210	89 88 e8 00 00
	00		 mov	 DWORD PTR [eax+232], ecx

; 445  : 
; 446  :     //
; 447  :     // Do something with the crom...
; 448  :     //
; 449  : 
; 450  :     //
; 451  :     // 0xf0000404 - bus id register
; 452  :     //
; 453  :     Kd1394Data->CromBuffer[1] = 0x31333934;

  00216	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Kd1394Data
  0021c	c7 42 04 34 39
	33 31		 mov	 DWORD PTR [edx+4], 825440564 ; 31333934H

; 454  : 
; 455  :     //
; 456  :     // 0xf0000408 - bus options register
; 457  :     //
; 458  : 
; 459  :     BusOptions.all = BlKd1394ByteSwap(Registers->BusOptions.all);

  00223	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  00226	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00229	e8 00 00 00 00	 call	 ?BlKd1394ByteSwap@@YIKK@Z ; BlKd1394ByteSwap
  0022e	89 45 f8	 mov	 DWORD PTR _BusOptions$[ebp], eax

; 460  :     BusOptions.Pmc = FALSE;

  00231	8b 4d f8	 mov	 ecx, DWORD PTR _BusOptions$[ebp]
  00234	81 e1 ff ff ff
	f7		 and	 ecx, -134217729		; f7ffffffH
  0023a	89 4d f8	 mov	 DWORD PTR _BusOptions$[ebp], ecx

; 461  :     BusOptions.Bmc = FALSE;

  0023d	8b 55 f8	 mov	 edx, DWORD PTR _BusOptions$[ebp]
  00240	81 e2 ff ff ff
	ef		 and	 edx, -268435457		; efffffffH
  00246	89 55 f8	 mov	 DWORD PTR _BusOptions$[ebp], edx

; 462  :     BusOptions.Isc = FALSE;

  00249	8b 45 f8	 mov	 eax, DWORD PTR _BusOptions$[ebp]
  0024c	25 ff ff ff df	 and	 eax, -536870913		; dfffffffH
  00251	89 45 f8	 mov	 DWORD PTR _BusOptions$[ebp], eax

; 463  :     BusOptions.Cmc = FALSE;

  00254	8b 4d f8	 mov	 ecx, DWORD PTR _BusOptions$[ebp]
  00257	81 e1 ff ff ff
	bf		 and	 ecx, -1073741825	; bfffffffH
  0025d	89 4d f8	 mov	 DWORD PTR _BusOptions$[ebp], ecx

; 464  :     BusOptions.Irmc = FALSE;

  00260	8b 55 f8	 mov	 edx, DWORD PTR _BusOptions$[ebp]
  00263	81 e2 ff ff ff
	7f		 and	 edx, 2147483647		; 7fffffffH
  00269	89 55 f8	 mov	 DWORD PTR _BusOptions$[ebp], edx

; 465  :     BusOptions.g = 1;

  0026c	8b 45 f8	 mov	 eax, DWORD PTR _BusOptions$[ebp]
  0026f	25 3f ff ff ff	 and	 eax, -193		; ffffff3fH
  00274	83 c8 40	 or	 eax, 64			; 00000040H
  00277	89 45 f8	 mov	 DWORD PTR _BusOptions$[ebp], eax

; 466  :     Kd1394Data->CromBuffer[2] = BlKd1394ByteSwap(BusOptions.all);

  0027a	8b 4d f8	 mov	 ecx, DWORD PTR _BusOptions$[ebp]
  0027d	e8 00 00 00 00	 call	 ?BlKd1394ByteSwap@@YIKK@Z ; BlKd1394ByteSwap
  00282	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00288	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 467  : 
; 468  :     //
; 469  :     // 0xf000040c - global unique id hi
; 470  :     //
; 471  : 
; 472  :     Kd1394Data->CromBuffer[3] = Registers->GuidHi;

  0028b	8b 55 e4	 mov	 edx, DWORD PTR _Registers$[ebp]
  0028e	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00291	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00297	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 473  : 
; 474  :     //
; 475  :     // 0xf0000410 - global unique id lo
; 476  :     //
; 477  : 
; 478  :     Kd1394Data->CromBuffer[4] = Registers->GuidLo;

  0029a	8b 55 e4	 mov	 edx, DWORD PTR _Registers$[ebp]
  0029d	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  002a0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  002a6	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 479  : 
; 480  :     //
; 481  :     // 0xf0000400 - config ROM header - set last to calculate CRC!
; 482  :     //
; 483  : 
; 484  :     ConfigRomHeader.all = 0;

  002a9	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _ConfigRomHeader$[ebp], 0

; 485  :     ConfigRomHeader.CRI_Info_Length = 4;

  002b0	c6 45 eb 04	 mov	 BYTE PTR _ConfigRomHeader$[ebp+3], 4

; 486  :     ConfigRomHeader.CRI_CRC_Length = 4;

  002b4	c6 45 ea 04	 mov	 BYTE PTR _ConfigRomHeader$[ebp+2], 4

; 487  :     ConfigRomHeader.CRI_CRC_Value = BlKd1394CalculateCrc(&Kd1394Data->CromBuffer[1],
; 488  :                                                          ConfigRomHeader.CRI_CRC_Length);

  002b8	0f b6 55 ea	 movzx	 edx, BYTE PTR _ConfigRomHeader$[ebp+2]
  002bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  002c2	83 c1 04	 add	 ecx, 4
  002c5	e8 00 00 00 00	 call	 ?BlKd1394CalculateCrc@@YIGPAKK@Z ; BlKd1394CalculateCrc
  002ca	66 89 45 c2	 mov	 WORD PTR tv185[ebp], ax
  002ce	66 8b 55 c2	 mov	 dx, WORD PTR tv185[ebp]
  002d2	66 8b 45 e8	 mov	 ax, WORD PTR _ConfigRomHeader$[ebp]
  002d6	66 25 00 00	 and	 ax, 0
  002da	66 0b c2	 or	 ax, dx
  002dd	66 89 45 e8	 mov	 WORD PTR _ConfigRomHeader$[ebp], ax

; 489  :     Kd1394Data->CromBuffer[0] = ConfigRomHeader.all;

  002e1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  002e7	8b 55 e8	 mov	 edx, DWORD PTR _ConfigRomHeader$[ebp]
  002ea	89 11		 mov	 DWORD PTR [ecx], edx

; 490  : 
; 491  :     Kd1394Data->CromBuffer[6] = 0xC083000C; // 0xf0000418 - node capabilities

  002ec	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  002f1	c7 40 18 0c 00
	83 c0		 mov	 DWORD PTR [eax+24], -1065156596 ; c083000cH

; 492  :     Kd1394Data->CromBuffer[7] = 0xF2500003; // 0xf000041C - module vendor id

  002f8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  002fe	c7 41 1c 03 00
	50 f2		 mov	 DWORD PTR [ecx+28], -229638141 ; f2500003H

; 493  : 
; 494  :     //
; 495  :     // KD's state machine looks for 1c w/ 50f2, 1d w/ 02, then 1e w/ address.
; 496  :     //
; 497  : 
; 498  :     Kd1394Data->CromBuffer[8] = 0xF250001C; // 0xf0000420 - extended key (for KD)

  00305	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Kd1394Data
  0030b	c7 42 20 1c 00
	50 f2		 mov	 DWORD PTR [edx+32], -229638116 ; f250001cH

; 499  :     Kd1394Data->CromBuffer[9] = 0x0200001D; // 0xf0000424 - debug key (for KD)

  00312	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  00317	c7 40 24 1d 00
	00 02		 mov	 DWORD PTR [eax+36], 33554461 ; 0200001dH

; 500  : 
; 501  :     //
; 502  :     // 0xf0000428 - debug value (for KD)
; 503  :     //
; 504  : 
; 505  :     CromEntry.all = (UINT32)(ULONG_PTR) &Kd1394Data->Config;

  0031e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00324	81 c1 e0 03 00
	00		 add	 ecx, 992		; 000003e0H
  0032a	89 4d fc	 mov	 DWORD PTR _CromEntry$[ebp], ecx

; 506  :     CromEntry.IE_Key = 0x1E;

  0032d	8b 55 fc	 mov	 edx, DWORD PTR _CromEntry$[ebp]
  00330	81 e2 ff ff ff
	00		 and	 edx, 16777215		; 00ffffffH
  00336	81 ca 00 00 00
	1e		 or	 edx, 503316480		; 1e000000H
  0033c	89 55 fc	 mov	 DWORD PTR _CromEntry$[ebp], edx

; 507  :     Kd1394Data->CromBuffer[10] = BlKd1394ByteSwap(CromEntry.all);

  0033f	8b 4d fc	 mov	 ecx, DWORD PTR _CromEntry$[ebp]
  00342	e8 00 00 00 00	 call	 ?BlKd1394ByteSwap@@YIKK@Z ; BlKd1394ByteSwap
  00347	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  0034d	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 508  : 
; 509  :     //
; 510  :     // 0xf0000414 - root directory header - set last to calculate CRC!
; 511  :     //
; 512  : 
; 513  :     DirInfo.all = 0;

  00350	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _DirInfo$[ebp], 0

; 514  :     DirInfo.DI_Length = 5;

  00357	66 c7 45 da 05
	00		 mov	 WORD PTR _DirInfo$[ebp+2], 5

; 515  :     DirInfo.DI_CRC = BlKd1394CalculateCrc(&Kd1394Data->CromBuffer[6], DirInfo.DI_Length);

  0035d	0f b7 55 da	 movzx	 edx, WORD PTR _DirInfo$[ebp+2]
  00361	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00367	83 c1 18	 add	 ecx, 24			; 00000018H
  0036a	e8 00 00 00 00	 call	 ?BlKd1394CalculateCrc@@YIGPAKK@Z ; BlKd1394CalculateCrc
  0036f	66 89 45 d8	 mov	 WORD PTR _DirInfo$[ebp], ax

; 516  :     Kd1394Data->CromBuffer[5] = BlKd1394ByteSwap(DirInfo.all);

  00373	8b 4d d8	 mov	 ecx, DWORD PTR _DirInfo$[ebp]
  00376	e8 00 00 00 00	 call	 ?BlKd1394ByteSwap@@YIKK@Z ; BlKd1394ByteSwap
  0037b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Kd1394Data
  00381	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 517  : 
; 518  :     //
; 519  :     // Write the first few registers.
; 520  :     //
; 521  : 
; 522  :     Registers->ConfigRomHeader.all = Kd1394Data->CromBuffer[0];

  00384	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  00387	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  0038d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0038f	89 50 18	 mov	 DWORD PTR [eax+24], edx

; 523  :     Registers->BusId = Kd1394Data->CromBuffer[1];

  00392	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  00395	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  0039b	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0039e	89 50 1c	 mov	 DWORD PTR [eax+28], edx

; 524  :     Registers->BusOptions.all = Kd1394Data->CromBuffer[2];

  003a1	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  003a4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  003aa	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  003ad	89 50 20	 mov	 DWORD PTR [eax+32], edx

; 525  :     Registers->GuidHi = Kd1394Data->CromBuffer[3];

  003b0	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  003b3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  003b9	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  003bc	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 526  :     Registers->GuidLo = Kd1394Data->CromBuffer[4];

  003bf	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  003c2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  003c8	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  003cb	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 527  : 
; 528  :     //
; 529  :     // Set our crom.
; 530  :     //
; 531  : 
; 532  :     Registers->ConfigRomMap = (UINT32)(ULONG_PTR) &Kd1394Data->CromBuffer;

  003ce	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  003d1	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  003d7	89 48 34	 mov	 DWORD PTR [eax+52], ecx

; 533  : 
; 534  :     //
; 535  :     // Disable all interrupts, we use polling for the debugger transport.
; 536  :     //
; 537  : 
; 538  :     Registers->IntMaskClear.all = 0xFFFFFFFF;

  003da	8b 55 e4	 mov	 edx, DWORD PTR _Registers$[ebp]
  003dd	c7 82 8c 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+140], -1

; 539  : 
; 540  :     //
; 541  :     // Enable the link.
; 542  :     //
; 543  : 
; 544  :     HCControl.all = 0;

  003e7	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _HCControl$[ebp], 0

; 545  :     HCControl.LinkEnable = TRUE;

  003ee	8b 45 ec	 mov	 eax, DWORD PTR _HCControl$[ebp]
  003f1	0d 00 00 02 00	 or	 eax, 131072		; 00020000H
  003f6	89 45 ec	 mov	 DWORD PTR _HCControl$[ebp], eax

; 546  :     Registers->HCControlSet.all = HCControl.all;

  003f9	8b 4d e4	 mov	 ecx, DWORD PTR _Registers$[ebp]
  003fc	8b 55 ec	 mov	 edx, DWORD PTR _HCControl$[ebp]
  003ff	89 51 50	 mov	 DWORD PTR [ecx+80], edx

; 547  : 
; 548  :     BlKd1394StallExecution(1000);

  00402	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00407	e8 00 00 00 00	 call	 ?BlKd1394StallExecution@@YIKK@Z ; BlKd1394StallExecution

; 549  : 
; 550  :     //
; 551  :     // Enable access filters to all nodes.
; 552  :     //
; 553  : 
; 554  :     Registers->AsynchReqFilterLoSet = 0xFFFFFFFF;

  0040c	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  0040f	c7 80 08 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+264], -1

; 555  :     Registers->AsynchReqFilterHiSet = 0xFFFFFFFF;

  00419	8b 4d e4	 mov	 ecx, DWORD PTR _Registers$[ebp]
  0041c	c7 81 00 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+256], -1

; 556  :     Registers->PhyReqFilterHiSet = 0xFFFFFFFF;

  00426	8b 55 e4	 mov	 edx, DWORD PTR _Registers$[ebp]
  00429	c7 82 10 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+272], -1

; 557  :     Registers->PhyReqFilterLoSet = 0xFFFFFFFF;

  00433	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  00436	c7 80 18 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+280], -1

; 558  : 
; 559  :     //
; 560  :     // Hard reset on the bus (so KD will look for us).
; 561  :     //
; 562  : 
; 563  :     PhyControl.all = 0;

  00440	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _PhyControl$[ebp], 0

; 564  :     PhyControl.RdReg = TRUE;

  00447	8b 4d e0	 mov	 ecx, DWORD PTR _PhyControl$[ebp]
  0044a	81 c9 00 80 00
	00		 or	 ecx, 32768		; 00008000H
  00450	89 4d e0	 mov	 DWORD PTR _PhyControl$[ebp], ecx

; 565  :     PhyControl.RegAddr = 1;

  00453	8b 55 e0	 mov	 edx, DWORD PTR _PhyControl$[ebp]
  00456	81 e2 ff f0 ff
	ff		 and	 edx, -3841		; fffff0ffH
  0045c	81 ca 00 01 00
	00		 or	 edx, 256		; 00000100H
  00462	89 55 e0	 mov	 DWORD PTR _PhyControl$[ebp], edx

; 566  :     Registers->PhyControl.all = PhyControl.all;

  00465	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  00468	8b 4d e0	 mov	 ecx, DWORD PTR _PhyControl$[ebp]
  0046b	89 88 ec 00 00
	00		 mov	 DWORD PTR [eax+236], ecx

; 567  : 
; 568  :     retry = MAX_REGISTER_READS;

  00471	c7 45 d0 80 1a
	06 00		 mov	 DWORD PTR _retry$[ebp], 400000 ; 00061a80H
$LN10@BlKd1394In:

; 569  : 
; 570  :     do {
; 571  : 
; 572  :         PhyControl.all = Registers->PhyControl.all;

  00478	8b 55 e4	 mov	 edx, DWORD PTR _Registers$[ebp]
  0047b	8b 82 ec 00 00
	00		 mov	 eax, DWORD PTR [edx+236]
  00481	89 45 e0	 mov	 DWORD PTR _PhyControl$[ebp], eax

; 573  : 
; 574  :     } while ((!PhyControl.RdDone) && --retry);

  00484	8b 4d e0	 mov	 ecx, DWORD PTR _PhyControl$[ebp]
  00487	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  0048a	83 e1 01	 and	 ecx, 1
  0048d	75 0b		 jne	 SHORT $LN8@BlKd1394In
  0048f	8b 55 d0	 mov	 edx, DWORD PTR _retry$[ebp]
  00492	83 ea 01	 sub	 edx, 1
  00495	89 55 d0	 mov	 DWORD PTR _retry$[ebp], edx
  00498	75 de		 jne	 SHORT $LN10@BlKd1394In
$LN8@BlKd1394In:

; 575  : 
; 576  :     if (retry == 0) {

  0049a	83 7d d0 00	 cmp	 DWORD PTR _retry$[ebp], 0
  0049e	75 07		 jne	 SHORT $LN6@BlKd1394In

; 577  : 
; 578  : #if KD_VERBOSE
; 579  : 
; 580  :         BlVideoPrintf("1394: Bus read failed.\n");
; 581  : 
; 582  : #endif
; 583  : 
; 584  :         return FALSE;

  004a0	32 c0		 xor	 al, al
  004a2	e9 98 00 00 00	 jmp	 $LN17@BlKd1394In
$LN6@BlKd1394In:

; 585  :     }
; 586  : 
; 587  :     Data = ((UINT8)PhyControl.RdData | PHY_INITIATE_BUS_RESET);

  004a7	8b 45 e0	 mov	 eax, DWORD PTR _PhyControl$[ebp]
  004aa	c1 e8 10	 shr	 eax, 16			; 00000010H
  004ad	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004b2	0f b6 c8	 movzx	 ecx, al
  004b5	83 c9 40	 or	 ecx, 64			; 00000040H
  004b8	88 4d cf	 mov	 BYTE PTR _Data$[ebp], cl

; 588  : 
; 589  :     PhyControl.all = 0;

  004bb	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _PhyControl$[ebp], 0

; 590  :     PhyControl.WrReg = TRUE;

  004c2	8b 55 e0	 mov	 edx, DWORD PTR _PhyControl$[ebp]
  004c5	81 ca 00 40 00
	00		 or	 edx, 16384		; 00004000H
  004cb	89 55 e0	 mov	 DWORD PTR _PhyControl$[ebp], edx

; 591  :     PhyControl.RegAddr = 1;

  004ce	8b 45 e0	 mov	 eax, DWORD PTR _PhyControl$[ebp]
  004d1	25 ff f0 ff ff	 and	 eax, -3841		; fffff0ffH
  004d6	0d 00 01 00 00	 or	 eax, 256		; 00000100H
  004db	89 45 e0	 mov	 DWORD PTR _PhyControl$[ebp], eax

; 592  :     PhyControl.WrData = Data;

  004de	0f b6 4d cf	 movzx	 ecx, BYTE PTR _Data$[ebp]
  004e2	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  004e8	8b 55 e0	 mov	 edx, DWORD PTR _PhyControl$[ebp]
  004eb	81 e2 00 ff ff
	ff		 and	 edx, -256		; ffffff00H
  004f1	0b d1		 or	 edx, ecx
  004f3	89 55 e0	 mov	 DWORD PTR _PhyControl$[ebp], edx

; 593  :     Registers->PhyControl.all = PhyControl.all;

  004f6	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  004f9	8b 4d e0	 mov	 ecx, DWORD PTR _PhyControl$[ebp]
  004fc	89 88 ec 00 00
	00		 mov	 DWORD PTR [eax+236], ecx

; 594  : 
; 595  :     retry = MAX_REGISTER_READS;

  00502	c7 45 d0 80 1a
	06 00		 mov	 DWORD PTR _retry$[ebp], 400000 ; 00061a80H
$LN5@BlKd1394In:

; 596  : 
; 597  :     do {
; 598  : 
; 599  :         PhyControl.all = Registers->PhyControl.all;

  00509	8b 55 e4	 mov	 edx, DWORD PTR _Registers$[ebp]
  0050c	8b 82 ec 00 00
	00		 mov	 eax, DWORD PTR [edx+236]
  00512	89 45 e0	 mov	 DWORD PTR _PhyControl$[ebp], eax

; 600  : 
; 601  :     } while (PhyControl.WrReg && --retry);

  00515	8b 4d e0	 mov	 ecx, DWORD PTR _PhyControl$[ebp]
  00518	c1 e9 0e	 shr	 ecx, 14			; 0000000eH
  0051b	83 e1 01	 and	 ecx, 1
  0051e	74 0b		 je	 SHORT $LN3@BlKd1394In
  00520	8b 55 d0	 mov	 edx, DWORD PTR _retry$[ebp]
  00523	83 ea 01	 sub	 edx, 1
  00526	89 55 d0	 mov	 DWORD PTR _retry$[ebp], edx
  00529	75 de		 jne	 SHORT $LN5@BlKd1394In
$LN3@BlKd1394In:

; 602  : 
; 603  :     if (retry == 0) {

  0052b	83 7d d0 00	 cmp	 DWORD PTR _retry$[ebp], 0
  0052f	75 04		 jne	 SHORT $LN1@BlKd1394In

; 604  : 
; 605  : #if KD_VERBOSE
; 606  : 
; 607  :         BlVideoPrintf("1394: Hard reset of bus failed\n");
; 608  : 
; 609  : #endif
; 610  : 
; 611  :         return FALSE;

  00531	32 c0		 xor	 al, al
  00533	eb 0a		 jmp	 SHORT $LN17@BlKd1394In
$LN1@BlKd1394In:

; 612  :     }
; 613  : 
; 614  : #if KD_VERBOSE
; 615  : 
; 616  :     BlVideoPrintf("1394: Hardware init succeeded.\n");
; 617  : 
; 618  : #endif
; 619  : 
; 620  :     KdRegisters = Registers;

  00535	8b 45 e4	 mov	 eax, DWORD PTR _Registers$[ebp]
  00538	a3 00 00 00 00	 mov	 DWORD PTR _KdRegisters, eax

; 621  : 
; 622  :     return TRUE;

  0053d	b0 01		 mov	 al, 1
$LN17@BlKd1394In:

; 623  : }

  0053f	8b e5		 mov	 esp, ebp
  00541	5d		 pop	 ebp
  00542	c3		 ret	 0
?BlKd1394InitHardware@@YIEGPAX@Z ENDP			; BlKd1394InitHardware
_TEXT	ENDS
PUBLIC	??_C@_0CM@ILELODI@1394?3?5EnablePhysicalAccess?5IntEv@ ; `string'
PUBLIC	??_C@_0CM@ODCPEIPD@1394?3?5EnablePhysicalAccess?5HCCon@ ; `string'
PUBLIC	?BlKd1394EnablePhysicalAccess@@YIXXZ		; BlKd1394EnablePhysicalAccess
EXTRN	?BlVideoPrintf@@YAEPBDZZ:PROC			; BlVideoPrintf
;	COMDAT ??_C@_0CM@ILELODI@1394?3?5EnablePhysicalAccess?5IntEv@
CONST	SEGMENT
??_C@_0CM@ILELODI@1394?3?5EnablePhysicalAccess?5IntEv@ DB '1394: EnablePh'
	DB	'ysicalAccess IntEvent =%08x!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@ODCPEIPD@1394?3?5EnablePhysicalAccess?5HCCon@
CONST	SEGMENT
??_C@_0CM@ODCPEIPD@1394?3?5EnablePhysicalAccess?5HCCon@ DB '1394: EnableP'
	DB	'hysicalAccess HCControl=%08x!', 0aH, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlKd1394EnablePhysicalAccess@@YIXXZ
_TEXT	SEGMENT
_IntEvent$ = -8						; size = 4
_HCControl$ = -4					; size = 4
?BlKd1394EnablePhysicalAccess@@YIXXZ PROC		; BlKd1394EnablePhysicalAccess, COMDAT

; 629  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 630  :     HC_CONTROL_REGISTER HCControl;
; 631  :     INT_EVENT_MASK_REGISTER IntEvent;
; 632  : 
; 633  :     //
; 634  :     // See if ohci1394 is being loaded...
; 635  :     //
; 636  : 
; 637  :     HCControl.all = KdRegisters->HCControlSet.all;

  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  0000b	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  0000e	89 4d fc	 mov	 DWORD PTR _HCControl$[ebp], ecx

; 638  :     if (!HCControl.LinkEnable || !HCControl.Lps || HCControl.SoftReset) {

  00011	8b 55 fc	 mov	 edx, DWORD PTR _HCControl$[ebp]
  00014	c1 ea 11	 shr	 edx, 17			; 00000011H
  00017	83 e2 01	 and	 edx, 1
  0001a	74 16		 je	 SHORT $LN4@BlKd1394En
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _HCControl$[ebp]
  0001f	c1 e8 13	 shr	 eax, 19			; 00000013H
  00022	83 e0 01	 and	 eax, 1
  00025	74 0b		 je	 SHORT $LN4@BlKd1394En
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _HCControl$[ebp]
  0002a	c1 e9 10	 shr	 ecx, 16			; 00000010H
  0002d	83 e1 01	 and	 ecx, 1
  00030	74 1a		 je	 SHORT $LN5@BlKd1394En
$LN4@BlKd1394En:

; 639  : 
; 640  :         KDDBG("1394: EnablePhysicalAccess HCControl=%08x!\n", HCControl.all);

  00032	33 d2		 xor	 edx, edx
  00034	74 11		 je	 SHORT $LN3@BlKd1394En
  00036	8b 45 fc	 mov	 eax, DWORD PTR _HCControl$[ebp]
  00039	50		 push	 eax
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@ODCPEIPD@1394?3?5EnablePhysicalAccess?5HCCon@
  0003f	e8 00 00 00 00	 call	 ?BlVideoPrintf@@YAEPBDZZ ; BlVideoPrintf
  00044	83 c4 08	 add	 esp, 8
$LN3@BlKd1394En:

; 641  : 
; 642  :         return;

  00047	e9 8e 00 00 00	 jmp	 $LN6@BlKd1394En
$LN5@BlKd1394En:

; 643  :     }
; 644  : 
; 645  :     //
; 646  :     // If the bus reset interrupt is not cleared, we have to clear it...
; 647  :     //
; 648  : 
; 649  :     IntEvent.all = KdRegisters->IntEventSet.all;

  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KdRegisters
  00052	8b 91 80 00 00
	00		 mov	 edx, DWORD PTR [ecx+128]
  00058	89 55 f8	 mov	 DWORD PTR _IntEvent$[ebp], edx

; 650  :     if (IntEvent.BusReset) {

  0005b	8b 45 f8	 mov	 eax, DWORD PTR _IntEvent$[ebp]
  0005e	c1 e8 11	 shr	 eax, 17			; 00000011H
  00061	83 e0 01	 and	 eax, 1
  00064	74 36		 je	 SHORT $LN2@BlKd1394En

; 651  : 
; 652  :         KDDBG("1394: EnablePhysicalAccess IntEvent =%08x!\n", IntEvent.all);

  00066	33 c9		 xor	 ecx, ecx
  00068	74 11		 je	 SHORT $LN1@BlKd1394En
  0006a	8b 55 f8	 mov	 edx, DWORD PTR _IntEvent$[ebp]
  0006d	52		 push	 edx
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@ILELODI@1394?3?5EnablePhysicalAccess?5IntEv@
  00073	e8 00 00 00 00	 call	 ?BlVideoPrintf@@YAEPBDZZ ; BlVideoPrintf
  00078	83 c4 08	 add	 esp, 8
$LN1@BlKd1394En:

; 653  : 
; 654  :         IntEvent.all = 0;

  0007b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _IntEvent$[ebp], 0

; 655  :         IntEvent.BusReset = 1;

  00082	8b 45 f8	 mov	 eax, DWORD PTR _IntEvent$[ebp]
  00085	0d 00 00 02 00	 or	 eax, 131072		; 00020000H
  0008a	89 45 f8	 mov	 DWORD PTR _IntEvent$[ebp], eax

; 656  :         KdRegisters->IntEventClear.all = IntEvent.all;

  0008d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KdRegisters
  00093	8b 55 f8	 mov	 edx, DWORD PTR _IntEvent$[ebp]
  00096	89 91 84 00 00
	00		 mov	 DWORD PTR [ecx+132], edx
$LN2@BlKd1394En:

; 657  :     }
; 658  : 
; 659  :     //
; 660  :     // Re-enable physical access as it may be necessary.
; 661  :     //
; 662  : 
; 663  :     KdRegisters->AsynchReqFilterHiSet = 0xFFFFFFFF;

  0009c	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  000a1	c7 80 00 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+256], -1

; 664  :     KdRegisters->AsynchReqFilterLoSet = 0xFFFFFFFF;

  000ab	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KdRegisters
  000b1	c7 81 08 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+264], -1

; 665  :     KdRegisters->PhyReqFilterHiSet = 0xFFFFFFFF;

  000bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _KdRegisters
  000c1	c7 82 10 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [edx+272], -1

; 666  :     KdRegisters->PhyReqFilterLoSet = 0xFFFFFFFF;

  000cb	a1 00 00 00 00	 mov	 eax, DWORD PTR _KdRegisters
  000d0	c7 80 18 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [eax+280], -1
$LN6@BlKd1394En:

; 667  : 
; 668  :     return;
; 669  : }

  000da	8b e5		 mov	 esp, ebp
  000dc	5d		 pop	 ebp
  000dd	c3		 ret	 0
?BlKd1394EnablePhysicalAccess@@YIXXZ ENDP		; BlKd1394EnablePhysicalAccess
_TEXT	ENDS
PUBLIC	??_C@_0DM@MFBJDALE@LOOP?5?$CFd?5?$FLSendPacket?$DN?$CFp?5?$CF08x?5?$CF08x@ ; `string'
PUBLIC	??_C@_0BE@JKEJJOAO@BlKd1394SendPacket?6?$AA@	; `string'
PUBLIC	?BlKd1394SendPacket@@YIEGPBXG0G@Z		; BlKd1394SendPacket
EXTRN	?BlRtlCopyMemory@@YIXPAXPBXK@Z:PROC		; BlRtlCopyMemory
EXTRN	?BlKdComputeChecksum@@YIKPBXK@Z:PROC		; BlKdComputeChecksum
EXTRN	?BlKdNextPacketId@@3KA:DWORD			; BlKdNextPacketId
;	COMDAT ??_C@_0DM@MFBJDALE@LOOP?5?$CFd?5?$FLSendPacket?$DN?$CFp?5?$CF08x?5?$CF08x@
CONST	SEGMENT
??_C@_0DM@MFBJDALE@LOOP?5?$CFd?5?$FLSendPacket?$DN?$CFp?5?$CF08x?5?$CF08x@ DB 'L'
	DB	'OOP %d [SendPacket=%p %08x %08x %08x %02x %02x %02x %02x]', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@JKEJJOAO@BlKd1394SendPacket?6?$AA@
CONST	SEGMENT
??_C@_0BE@JKEJJOAO@BlKd1394SendPacket?6?$AA@ DB 'BlKd1394SendPacket', 0aH
	DB	00H						; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlKd1394SendPacket@@YIEGPBXG0G@Z
_TEXT	SEGMENT
_Header$ = -36						; size = 4
_PacketType$ = -32					; size = 2
_pStatus$ = -28						; size = 4
_Retries$ = -24						; size = 4
_PacketHeader$ = -20					; size = 16
_count$ = -4						; size = 4
_HeaderSize$ = 8					; size = 2
_Data$ = 12						; size = 4
_DataSize$ = 16						; size = 2
?BlKd1394SendPacket@@YIEGPBXG0G@Z PROC			; BlKd1394SendPacket, COMDAT
; _PacketType$ = cx
; _Header$ = edx

; 705  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	56		 push	 esi
  00007	89 55 dc	 mov	 DWORD PTR _Header$[ebp], edx
  0000a	66 89 4d e0	 mov	 WORD PTR _PacketType$[ebp], cx

; 706  :     KD_PACKET PacketHeader;
; 707  :     UINT32 Retries;
; 708  :     UINT32 count;
; 709  :     volatile UINT32 *pStatus;
; 710  : 
; 711  :     KDDBG2("BlKd1394SendPacket\n");

  0000e	33 c0		 xor	 eax, eax
  00010	74 0d		 je	 SHORT $LN13@BlKd1394Se
  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@JKEJJOAO@BlKd1394SendPacket?6?$AA@
  00017	e8 00 00 00 00	 call	 ?BlVideoPrintf@@YAEPBDZZ ; BlVideoPrintf
  0001c	83 c4 04	 add	 esp, 4
$LN13@BlKd1394Se:

; 712  : 
; 713  :     //
; 714  :     // Abort if the hardware hasn't been initialized.
; 715  :     //
; 716  : 
; 717  :     if (KdRegisters == NULL) {

  0001f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _KdRegisters, 0
  00026	75 07		 jne	 SHORT $LN12@BlKd1394Se

; 718  : 
; 719  :         return FALSE;

  00028	32 c0		 xor	 al, al
  0002a	e9 1d 02 00 00	 jmp	 $LN14@BlKd1394Se
$LN12@BlKd1394Se:

; 720  :     }
; 721  : 
; 722  :     //
; 723  :     // Initialize the packet header.
; 724  :     //
; 725  : 
; 726  :     PacketHeader.PacketLeader = KD_PACKET_LEADER;

  0002f	c7 45 ec 30 30
	30 30		 mov	 DWORD PTR _PacketHeader$[ebp], 808464432 ; 30303030H

; 727  :     PacketHeader.ByteCount = HeaderSize + DataSize;

  00036	0f b7 4d 08	 movzx	 ecx, WORD PTR _HeaderSize$[ebp]
  0003a	0f b7 55 10	 movzx	 edx, WORD PTR _DataSize$[ebp]
  0003e	03 ca		 add	 ecx, edx
  00040	66 89 4d f2	 mov	 WORD PTR _PacketHeader$[ebp+6], cx

; 728  :     PacketHeader.PacketType = PacketType;

  00044	66 8b 45 e0	 mov	 ax, WORD PTR _PacketType$[ebp]
  00048	66 89 45 f0	 mov	 WORD PTR _PacketHeader$[ebp+4], ax

; 729  :     PacketHeader.PacketId = BlKdNextPacketId++;

  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?BlKdNextPacketId@@3KA ; BlKdNextPacketId
  00052	89 4d f4	 mov	 DWORD PTR _PacketHeader$[ebp+8], ecx
  00055	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?BlKdNextPacketId@@3KA ; BlKdNextPacketId
  0005b	83 c2 01	 add	 edx, 1
  0005e	89 15 00 00 00
	00		 mov	 DWORD PTR ?BlKdNextPacketId@@3KA, edx ; BlKdNextPacketId

; 730  :     PacketHeader.Checksum = (BlKdComputeChecksum(Header, HeaderSize) +
; 731  :                              BlKdComputeChecksum(Data, DataSize));

  00064	0f b7 55 08	 movzx	 edx, WORD PTR _HeaderSize$[ebp]
  00068	8b 4d dc	 mov	 ecx, DWORD PTR _Header$[ebp]
  0006b	e8 00 00 00 00	 call	 ?BlKdComputeChecksum@@YIKPBXK@Z ; BlKdComputeChecksum
  00070	8b f0		 mov	 esi, eax
  00072	0f b7 55 10	 movzx	 edx, WORD PTR _DataSize$[ebp]
  00076	8b 4d 0c	 mov	 ecx, DWORD PTR _Data$[ebp]
  00079	e8 00 00 00 00	 call	 ?BlKdComputeChecksum@@YIKPBXK@Z ; BlKdComputeChecksum
  0007e	03 f0		 add	 esi, eax
  00080	89 75 f8	 mov	 DWORD PTR _PacketHeader$[ebp+12], esi

; 732  : 
; 733  :     //
; 734  :     // Setup our send packet.
; 735  :     //
; 736  : 
; 737  :     BlRtlZeroMemory(&Kd1394Data->SendPacket, sizeof(DEBUG_1394_SEND_PACKET));

  00083	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00089	81 c1 00 04 00
	00		 add	 ecx, 1024		; 00000400H
  0008f	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  00094	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 738  :     Kd1394Data->SendPacket.Length = 0;  // Redundant.

  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  0009e	c7 80 14 04 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+1044], 0

; 739  : 
; 740  :     //
; 741  :     // Copy our packet header into the transmit region.
; 742  :     //
; 743  : 
; 744  :     BlRtlCopyMemory(&Kd1394Data->SendPacket.PacketHeader[0], &PacketHeader, sizeof(KD_PACKET));

  000a8	6a 10		 push	 16			; 00000010H
  000aa	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  000b0	81 c1 04 04 00
	00		 add	 ecx, 1028		; 00000404H
  000b6	8d 55 ec	 lea	 edx, DWORD PTR _PacketHeader$[ebp]
  000b9	e8 00 00 00 00	 call	 ?BlRtlCopyMemory@@YIXPAXPBXK@Z ; BlRtlCopyMemory

; 745  : 
; 746  :     //
; 747  :     // Setup our message header.
; 748  :     //
; 749  : 
; 750  :     if (HeaderSize > 0) {

  000be	0f b7 4d 08	 movzx	 ecx, WORD PTR _HeaderSize$[ebp]
  000c2	85 c9		 test	 ecx, ecx
  000c4	7e 29		 jle	 SHORT $LN11@BlKd1394Se

; 751  : 
; 752  :         BlRtlCopyMemory(&Kd1394Data->SendPacket.Packet[0], Header, HeaderSize);

  000c6	0f b7 55 08	 movzx	 edx, WORD PTR _HeaderSize$[ebp]
  000ca	52		 push	 edx
  000cb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  000d1	81 c1 18 04 00
	00		 add	 ecx, 1048		; 00000418H
  000d7	8b 55 dc	 mov	 edx, DWORD PTR _Header$[ebp]
  000da	e8 00 00 00 00	 call	 ?BlRtlCopyMemory@@YIXPAXPBXK@Z ; BlRtlCopyMemory

; 753  :         Kd1394Data->SendPacket.Length = HeaderSize;

  000df	0f b7 45 08	 movzx	 eax, WORD PTR _HeaderSize$[ebp]
  000e3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  000e9	89 81 14 04 00
	00		 mov	 DWORD PTR [ecx+1044], eax
$LN11@BlKd1394Se:

; 754  :     }
; 755  : 
; 756  :     //
; 757  :     // Setup our message data.
; 758  :     //
; 759  : 
; 760  :     if (DataSize > 0) {

  000ef	0f b7 55 10	 movzx	 edx, WORD PTR _DataSize$[ebp]
  000f3	85 d2		 test	 edx, edx
  000f5	7e 40		 jle	 SHORT $LN10@BlKd1394Se

; 761  : 
; 762  :         BlRtlCopyMemory(&Kd1394Data->SendPacket.Packet[Kd1394Data->SendPacket.Length], Data, DataSize);

  000f7	0f b7 45 10	 movzx	 eax, WORD PTR _DataSize$[ebp]
  000fb	50		 push	 eax
  000fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00102	8b 91 14 04 00
	00		 mov	 edx, DWORD PTR [ecx+1044]
  00108	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  0010d	8d 8c 10 18 04
	00 00		 lea	 ecx, DWORD PTR [eax+edx+1048]
  00114	8b 55 0c	 mov	 edx, DWORD PTR _Data$[ebp]
  00117	e8 00 00 00 00	 call	 ?BlRtlCopyMemory@@YIXPAXPBXK@Z ; BlRtlCopyMemory

; 763  :         Kd1394Data->SendPacket.Length += DataSize;

  0011c	0f b7 4d 10	 movzx	 ecx, WORD PTR _DataSize$[ebp]
  00120	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Kd1394Data
  00126	03 8a 14 04 00
	00		 add	 ecx, DWORD PTR [edx+1044]
  0012c	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  00131	89 88 14 04 00
	00		 mov	 DWORD PTR [eax+1044], ecx
$LN10@BlKd1394Se:

; 764  :     }
; 765  : 
; 766  :     //
; 767  :     // Mark the packet as ready for processing by host.
; 768  :     //
; 769  : 
; 770  :     Kd1394Data->SendPacket.TransferStatus = PACKET_PENDING;

  00137	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  0013d	c7 81 00 04 00
	00 03 01 00 00	 mov	 DWORD PTR [ecx+1024], 259 ; 00000103H

; 771  : 
; 772  :     //
; 773  :     // Wait for our packet to be acknowledged by the host.
; 774  :     //
; 775  : 
; 776  :     for (Retries = KD_RETRY_COUNT; Retries > 0; Retries--) {

  00147	c7 45 e8 10 00
	00 00		 mov	 DWORD PTR _Retries$[ebp], 16 ; 00000010H
  0014e	eb 09		 jmp	 SHORT $LN9@BlKd1394Se
$LN8@BlKd1394Se:
  00150	8b 55 e8	 mov	 edx, DWORD PTR _Retries$[ebp]
  00153	83 ea 01	 sub	 edx, 1
  00156	89 55 e8	 mov	 DWORD PTR _Retries$[ebp], edx
$LN9@BlKd1394Se:
  00159	83 7d e8 00	 cmp	 DWORD PTR _Retries$[ebp], 0
  0015d	0f 86 e7 00 00
	00		 jbe	 $LN7@BlKd1394Se

; 777  : 
; 778  :         KDDBG2("LOOP %d [SendPacket=%p %08x %08x %08x %02x %02x %02x %02x]\n",

  00163	33 c0		 xor	 eax, eax
  00165	74 79		 je	 SHORT $LN6@BlKd1394Se

; 779  :                Retries,
; 780  :                &Kd1394Data->SendPacket,
; 781  :                Kd1394Data->SendPacket.TransferStatus,
; 782  :                * (UINT32*) &Kd1394Data->SendPacket.PacketHeader,
; 783  :                Kd1394Data->SendPacket.Length,
; 784  :                Kd1394Data->SendPacket.Packet[0],
; 785  :                Kd1394Data->SendPacket.Packet[1],
; 786  :                Kd1394Data->SendPacket.Packet[2],
; 787  :                Kd1394Data->SendPacket.Packet[3]);

  00167	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  0016d	0f b6 91 1b 04
	00 00		 movzx	 edx, BYTE PTR [ecx+1051]
  00174	52		 push	 edx
  00175	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  0017a	0f b6 88 1a 04
	00 00		 movzx	 ecx, BYTE PTR [eax+1050]
  00181	51		 push	 ecx
  00182	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Kd1394Data
  00188	0f b6 82 19 04
	00 00		 movzx	 eax, BYTE PTR [edx+1049]
  0018f	50		 push	 eax
  00190	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  00196	0f b6 91 18 04
	00 00		 movzx	 edx, BYTE PTR [ecx+1048]
  0019d	52		 push	 edx
  0019e	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  001a3	8b 88 14 04 00
	00		 mov	 ecx, DWORD PTR [eax+1044]
  001a9	51		 push	 ecx
  001aa	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Kd1394Data
  001b0	8b 82 04 04 00
	00		 mov	 eax, DWORD PTR [edx+1028]
  001b6	50		 push	 eax
  001b7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  001bd	8b 91 00 04 00
	00		 mov	 edx, DWORD PTR [ecx+1024]
  001c3	52		 push	 edx
  001c4	a1 00 00 00 00	 mov	 eax, DWORD PTR _Kd1394Data
  001c9	05 00 04 00 00	 add	 eax, 1024		; 00000400H
  001ce	50		 push	 eax
  001cf	8b 4d e8	 mov	 ecx, DWORD PTR _Retries$[ebp]
  001d2	51		 push	 ecx
  001d3	68 00 00 00 00	 push	 OFFSET ??_C@_0DM@MFBJDALE@LOOP?5?$CFd?5?$FLSendPacket?$DN?$CFp?5?$CF08x?5?$CF08x@
  001d8	e8 00 00 00 00	 call	 ?BlVideoPrintf@@YAEPBDZZ ; BlVideoPrintf
  001dd	83 c4 28	 add	 esp, 40			; 00000028H
$LN6@BlKd1394Se:

; 788  : 
; 789  :         //
; 790  :         // make sure our link is enabled..
; 791  :         //
; 792  : 
; 793  :         BlKd1394EnablePhysicalAccess();

  001e0	e8 00 00 00 00	 call	 ?BlKd1394EnablePhysicalAccess@@YIXXZ ; BlKd1394EnablePhysicalAccess

; 794  : 
; 795  :         pStatus = &Kd1394Data->ReceivePacket.TransferStatus;

  001e5	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _Kd1394Data
  001eb	81 c2 00 14 00
	00		 add	 edx, 5120		; 00001400H
  001f1	89 55 e4	 mov	 DWORD PTR _pStatus$[ebp], edx

; 796  : 
; 797  :         //
; 798  :         // now sit here and poll for a response from the host machine
; 799  :         //
; 800  : 
; 801  :         for (count = 0; count < TIMEOUT_COUNT; count++) {

  001f4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _count$[ebp], 0
  001fb	eb 09		 jmp	 SHORT $LN5@BlKd1394Se
$LN4@BlKd1394Se:
  001fd	8b 45 fc	 mov	 eax, DWORD PTR _count$[ebp]
  00200	83 c0 01	 add	 eax, 1
  00203	89 45 fc	 mov	 DWORD PTR _count$[ebp], eax
$LN5@BlKd1394Se:
  00206	81 7d fc a0 86
	01 00		 cmp	 DWORD PTR _count$[ebp], 100000 ; 000186a0H
  0020d	73 36		 jae	 SHORT $LN3@BlKd1394Se

; 802  : 
; 803  :             //
; 804  :             // make sure our link is enabled..
; 805  :             //
; 806  : 
; 807  :             BlKd1394EnablePhysicalAccess();

  0020f	e8 00 00 00 00	 call	 ?BlKd1394EnablePhysicalAccess@@YIXXZ ; BlKd1394EnablePhysicalAccess

; 808  :             BlKdSpin();

  00214	e8 00 00 00 00	 call	 ?BlKdSpin@@YIXXZ	; BlKdSpin

; 809  : 
; 810  :             //
; 811  :             // Check to see if the host has ACK'd our packet.
; 812  :             //
; 813  : 
; 814  :             if (Kd1394Data->SendPacket.TransferStatus != PACKET_PENDING) {

  00219	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _Kd1394Data
  0021f	81 b9 00 04 00
	00 03 01 00 00	 cmp	 DWORD PTR [ecx+1024], 259 ; 00000103H
  00229	74 04		 je	 SHORT $LN2@BlKd1394Se

; 815  :                 return TRUE;

  0022b	b0 01		 mov	 al, 1
  0022d	eb 1d		 jmp	 SHORT $LN14@BlKd1394Se
$LN2@BlKd1394Se:

; 816  :             }
; 817  : 
; 818  :             //
; 819  :             // While in this loop check if the host has submitted a new request.
; 820  :             // If they did, ACK it, and retry.
; 821  :             //
; 822  : 
; 823  :             if (*pStatus == PACKET_PENDING) {

  0022f	8b 55 e4	 mov	 edx, DWORD PTR _pStatus$[ebp]
  00232	81 3a 03 01 00
	00		 cmp	 DWORD PTR [edx], 259	; 00000103H
  00238	75 09		 jne	 SHORT $LN1@BlKd1394Se

; 824  : 
; 825  :                 //
; 826  :                 // ACK the packet from the debugger so it will accept our packet.
; 827  :                 //
; 828  : 
; 829  :                 *pStatus = PACKET_READY;

  0023a	8b 45 e4	 mov	 eax, DWORD PTR _pStatus$[ebp]
  0023d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN1@BlKd1394Se:

; 830  :             }
; 831  :         }

  00243	eb b8		 jmp	 SHORT $LN4@BlKd1394Se
$LN3@BlKd1394Se:

; 832  :     }

  00245	e9 06 ff ff ff	 jmp	 $LN8@BlKd1394Se
$LN7@BlKd1394Se:

; 833  : 
; 834  :     return FALSE;

  0024a	32 c0		 xor	 al, al
$LN14@BlKd1394Se:

; 835  : }

  0024c	5e		 pop	 esi
  0024d	8b e5		 mov	 esp, ebp
  0024f	5d		 pop	 ebp
  00250	c2 0c 00	 ret	 12			; 0000000cH
?BlKd1394SendPacket@@YIEGPBXG0G@Z ENDP			; BlKd1394SendPacket
_TEXT	ENDS
PUBLIC	??_C@_1O@ENAGAFIM@?$AA1?$AA3?$AA9?$AA4?$AA?$CB?$AA?6?$AA?$AA@ ; `string'
PUBLIC	?BlKd1394Connect@@YIEXZ				; BlKd1394Connect
EXTRN	?BlPciOhci1394BaseAddress@@3KA:DWORD		; BlPciOhci1394BaseAddress
;	COMDAT ??_C@_1O@ENAGAFIM@?$AA1?$AA3?$AA9?$AA4?$AA?$CB?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_1O@ENAGAFIM@?$AA1?$AA3?$AA9?$AA4?$AA?$CB?$AA?6?$AA?$AA@ DB '1', 00H
	DB	'3', 00H, '9', 00H, '4', 00H, '!', 00H, 0aH, 00H, 00H, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlKd1394Connect@@YIEXZ
_TEXT	SEGMENT
_Packet$4160 = -16					; size = 16
?BlKd1394Connect@@YIEXZ PROC				; BlKd1394Connect, COMDAT

; 855  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 856  :     //
; 857  :     // Abort if there is no 1394 hardware.
; 858  :     //
; 859  : 
; 860  :     if (BlPciOhci1394BaseAddress == 0) {

  00006	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?BlPciOhci1394BaseAddress@@3KA, 0 ; BlPciOhci1394BaseAddress
  0000d	75 04		 jne	 SHORT $LN3@BlKd1394Co

; 861  : 
; 862  :         return FALSE;

  0000f	32 c0		 xor	 al, al
  00011	eb 5c		 jmp	 SHORT $LN4@BlKd1394Co
$LN3@BlKd1394Co:

; 863  :     }
; 864  : 
; 865  :     //
; 866  :     // Initialize the underlying hardware.
; 867  :     //
; 868  : 
; 869  :     if (BlKd1394InitHardware(0, (PVOID)(ULONG_PTR) BlPciOhci1394BaseAddress)) {

  00013	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?BlPciOhci1394BaseAddress@@3KA ; BlPciOhci1394BaseAddress
  00019	33 c9		 xor	 ecx, ecx
  0001b	e8 00 00 00 00	 call	 ?BlKd1394InitHardware@@YIEGPAX@Z ; BlKd1394InitHardware
  00020	0f b6 c0	 movzx	 eax, al
  00023	85 c0		 test	 eax, eax
  00025	74 3c		 je	 SHORT $LN2@BlKd1394Co

; 870  : 
; 871  :         KD_DEBUG_IO Packet;
; 872  : 
; 873  :         //
; 874  :         // Send a test packet to verify the debugger is attached.
; 875  :         //
; 876  : 
; 877  :         BlRtlZeroMemory(&Packet, sizeof(Packet));

  00027	ba 10 00 00 00	 mov	 edx, 16			; 00000010H
  0002c	8d 4d f0	 lea	 ecx, DWORD PTR _Packet$4160[ebp]
  0002f	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 878  : 
; 879  :         Packet.ApiNumber = KD_API_PRINT_STRING;

  00034	c7 45 f0 30 32
	00 00		 mov	 DWORD PTR _Packet$4160[ebp], 12848 ; 00003230H

; 880  :         Packet.u1.PrintString.LengthOfString = 0;

  0003b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Packet$4160[ebp+8], 0

; 881  : 
; 882  :         if (BlKd1394SendPacket(KD_PACKET_TYPE_KD_DEBUG_IO, &Packet, sizeof(Packet), L"1394!\n", 7)) {

  00042	6a 07		 push	 7
  00044	68 00 00 00 00	 push	 OFFSET ??_C@_1O@ENAGAFIM@?$AA1?$AA3?$AA9?$AA4?$AA?$CB?$AA?6?$AA?$AA@
  00049	6a 10		 push	 16			; 00000010H
  0004b	8d 55 f0	 lea	 edx, DWORD PTR _Packet$4160[ebp]
  0004e	b9 03 00 00 00	 mov	 ecx, 3
  00053	e8 00 00 00 00	 call	 ?BlKd1394SendPacket@@YIEGPBXG0G@Z ; BlKd1394SendPacket
  00058	0f b6 c8	 movzx	 ecx, al
  0005b	85 c9		 test	 ecx, ecx
  0005d	74 04		 je	 SHORT $LN2@BlKd1394Co

; 883  : 
; 884  :             return TRUE;

  0005f	b0 01		 mov	 al, 1
  00061	eb 0c		 jmp	 SHORT $LN4@BlKd1394Co
$LN2@BlKd1394Co:

; 885  :         }
; 886  :     }
; 887  : 
; 888  :     BlPciOhci1394BaseAddress = 0;

  00063	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BlPciOhci1394BaseAddress@@3KA, 0 ; BlPciOhci1394BaseAddress

; 889  : 
; 890  :     return FALSE;

  0006d	32 c0		 xor	 al, al
$LN4@BlKd1394Co:

; 891  : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
?BlKd1394Connect@@YIEXZ ENDP				; BlKd1394Connect
_TEXT	ENDS
END
