; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\OSes\VERVE\verify\src\Trusted\BootLoader\SingLdrPc\blpci.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BlPciInstallationCheck@@3U_PCI_INSTALLATION_CHECK@@A ; BlPciInstallationCheck
PUBLIC	?BlPciOhci1394BaseAddress@@3KA			; BlPciOhci1394BaseAddress
_BSS	SEGMENT
?BlPciInstallationCheck@@3U_PCI_INSTALLATION_CHECK@@A DB 018H DUP (?) ; BlPciInstallationCheck
?BlPciOhci1394BaseAddress@@3KA DD 01H DUP (?)		; BlPciOhci1394BaseAddress
_BSS	ENDS
PUBLIC	?BlPciCheckBios@@YIEPAU_PCI_INSTALLATION_CHECK@@@Z ; BlPciCheckBios
EXTRN	?BlRtlCallLegacyInterruptService@@YIXEPAU_BL_LEGACY_CALL_CONTEXT@@0@Z:PROC ; BlRtlCallLegacyInterruptService
EXTRN	?BlRtlZeroMemory@@YIXPAXK@Z:PROC		; BlRtlZeroMemory
; Function compile flags: /Odtp
; File d:\oses\verve\verify\src\trusted\bootloader\singldrpc\blpci.cpp
;	COMDAT ?BlPciCheckBios@@YIEPAU_PCI_INSTALLATION_CHECK@@@Z
_TEXT	SEGMENT
_PciInstallationCheck$ = -40				; size = 4
_Context$ = -36						; size = 36
?BlPciCheckBios@@YIEPAU_PCI_INSTALLATION_CHECK@@@Z PROC	; BlPciCheckBios, COMDAT
; _PciInstallationCheck$ = ecx

; 165  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d d8	 mov	 DWORD PTR _PciInstallationCheck$[ebp], ecx

; 166  :     BL_LEGACY_CALL_CONTEXT Context;
; 167  : 
; 168  :     //
; 169  :     // Call PCI detection service.
; 170  :     //
; 171  : 
; 172  :     BlRtlZeroMemory(&Context, sizeof(Context));

  00009	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
  0000e	8d 4d dc	 lea	 ecx, DWORD PTR _Context$[ebp]
  00011	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 173  : 
; 174  :     Context.eax = 0xB101;

  00016	c7 45 dc 01 b1
	00 00		 mov	 DWORD PTR _Context$[ebp], 45313 ; 0000b101H

; 175  : 
; 176  :     BlRtlCallLegacyInterruptService(0x1A,
; 177  :                                     &Context,
; 178  :                                     &Context);

  0001d	8d 45 dc	 lea	 eax, DWORD PTR _Context$[ebp]
  00020	50		 push	 eax
  00021	8d 55 dc	 lea	 edx, DWORD PTR _Context$[ebp]
  00024	b1 1a		 mov	 cl, 26			; 0000001aH
  00026	e8 00 00 00 00	 call	 ?BlRtlCallLegacyInterruptService@@YIXEPAU_BL_LEGACY_CALL_CONTEXT@@0@Z ; BlRtlCallLegacyInterruptService

; 179  : 
; 180  :     //
; 181  :     // If CF is set, AH is not zero, or if the signature is not ' ICP', then
; 182  :     // there is no PCI BIOS.
; 183  :     //
; 184  : 
; 185  :     if (((Context.eflags & RFLAGS_CF) != 0) ||
; 186  :         (((Context.eax >> 8) & 0xFF) != 0) ||
; 187  :         (Context.edx != 0x20494350)) {

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _Context$[ebp+32]
  0002e	83 e1 01	 and	 ecx, 1
  00031	75 17		 jne	 SHORT $LN1@BlPciCheck
  00033	8b 55 dc	 mov	 edx, DWORD PTR _Context$[ebp]
  00036	c1 ea 08	 shr	 edx, 8
  00039	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0003f	75 09		 jne	 SHORT $LN1@BlPciCheck
  00041	81 7d e8 50 43
	49 20		 cmp	 DWORD PTR _Context$[ebp+12], 541672272 ; 20494350H
  00048	74 04		 je	 SHORT $LN2@BlPciCheck
$LN1@BlPciCheck:

; 188  : 
; 189  :         return FALSE;

  0004a	32 c0		 xor	 al, al
  0004c	eb 6c		 jmp	 SHORT $LN3@BlPciCheck
$LN2@BlPciCheck:

; 190  :     }
; 191  : 
; 192  :     //
; 193  :     // Populate the provided installation check structure and return success.
; 194  :     //
; 195  : 
; 196  :     PciInstallationCheck->Eax = Context.eax;

  0004e	8b 45 d8	 mov	 eax, DWORD PTR _PciInstallationCheck$[ebp]
  00051	8b 4d dc	 mov	 ecx, DWORD PTR _Context$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx

; 197  :     PciInstallationCheck->Ebx = Context.ebx;

  00056	8b 55 d8	 mov	 edx, DWORD PTR _PciInstallationCheck$[ebp]
  00059	8b 45 e0	 mov	 eax, DWORD PTR _Context$[ebp+4]
  0005c	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 198  :     PciInstallationCheck->Ecx = Context.ecx;

  0005f	8b 4d d8	 mov	 ecx, DWORD PTR _PciInstallationCheck$[ebp]
  00062	8b 55 e4	 mov	 edx, DWORD PTR _Context$[ebp+8]
  00065	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 199  :     PciInstallationCheck->Edx = Context.edx;

  00068	8b 45 d8	 mov	 eax, DWORD PTR _PciInstallationCheck$[ebp]
  0006b	8b 4d e8	 mov	 ecx, DWORD PTR _Context$[ebp+12]
  0006e	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 200  :     PciInstallationCheck->HardwareCharacteristics = (UINT8) (Context.eax & 0xFF);

  00071	8b 55 dc	 mov	 edx, DWORD PTR _Context$[ebp]
  00074	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0007a	8b 45 d8	 mov	 eax, DWORD PTR _PciInstallationCheck$[ebp]
  0007d	88 50 10	 mov	 BYTE PTR [eax+16], dl

; 201  :     PciInstallationCheck->LastBusNumber = (UINT8) (Context.ecx & 0xFF);

  00080	8b 4d e4	 mov	 ecx, DWORD PTR _Context$[ebp+8]
  00083	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00089	8b 55 d8	 mov	 edx, DWORD PTR _PciInstallationCheck$[ebp]
  0008c	88 4a 13	 mov	 BYTE PTR [edx+19], cl

; 202  :     PciInstallationCheck->MajorVersion = (UINT8) ((Context.ebx >> 8) & 0xFF);

  0008f	8b 45 e0	 mov	 eax, DWORD PTR _Context$[ebp+4]
  00092	c1 e8 08	 shr	 eax, 8
  00095	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0009a	8b 4d d8	 mov	 ecx, DWORD PTR _PciInstallationCheck$[ebp]
  0009d	88 41 11	 mov	 BYTE PTR [ecx+17], al

; 203  :     PciInstallationCheck->MinorVersion = (UINT8) (Context.ebx & 0xFF);

  000a0	8b 55 e0	 mov	 edx, DWORD PTR _Context$[ebp+4]
  000a3	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000a9	8b 45 d8	 mov	 eax, DWORD PTR _PciInstallationCheck$[ebp]
  000ac	88 50 12	 mov	 BYTE PTR [eax+18], dl

; 204  :     PciInstallationCheck->ProtectedModeEntryPoint = Context.edi;

  000af	8b 4d d8	 mov	 ecx, DWORD PTR _PciInstallationCheck$[ebp]
  000b2	8b 55 f0	 mov	 edx, DWORD PTR _Context$[ebp+20]
  000b5	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 205  : 
; 206  :     return TRUE;

  000b8	b0 01		 mov	 al, 1
$LN3@BlPciCheck:

; 207  : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
?BlPciCheckBios@@YIEPAU_PCI_INSTALLATION_CHECK@@@Z ENDP	; BlPciCheckBios
_TEXT	ENDS
PUBLIC	??_C@_09GGGJHACA@blpci?4cpp?$AA@		; `string'
PUBLIC	?BlPciReadConfigurationRegister@@YIKEEEE@Z	; BlPciReadConfigurationRegister
EXTRN	?BlRtlReadPort32@@YIKG@Z:PROC			; BlRtlReadPort32
EXTRN	?BlRtlWritePort32@@YIXGK@Z:PROC			; BlRtlWritePort32
EXTRN	?BlRtlAssertFailed@@YIXPBDK@Z:PROC		; BlRtlAssertFailed
;	COMDAT ??_C@_09GGGJHACA@blpci?4cpp?$AA@
CONST	SEGMENT
??_C@_09GGGJHACA@blpci?4cpp?$AA@ DB 'blpci.cpp', 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlPciReadConfigurationRegister@@YIKEEEE@Z
_TEXT	SEGMENT
_DeviceNumber$ = -16					; size = 1
_BusNumber$ = -12					; size = 1
_ConfigAddress$ = -8					; size = 4
_Value$ = -4						; size = 4
_FunctionNumber$ = 8					; size = 1
_RegisterNumber$ = 12					; size = 1
?BlPciReadConfigurationRegister@@YIKEEEE@Z PROC		; BlPciReadConfigurationRegister, COMDAT
; _BusNumber$ = cl
; _DeviceNumber$ = dl

; 239  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	88 55 f0	 mov	 BYTE PTR _DeviceNumber$[ebp], dl
  00009	88 4d f4	 mov	 BYTE PTR _BusNumber$[ebp], cl

; 240  :     PCI_CONFIG_ADDRESS ConfigAddress;
; 241  :     UINT32 Value;
; 242  : 
; 243  :     BLASSERT(DeviceNumber < PCI_MAX_DEVICES);

  0000c	0f b6 45 f0	 movzx	 eax, BYTE PTR _DeviceNumber$[ebp]
  00010	83 f8 20	 cmp	 eax, 32			; 00000020H
  00013	7c 0f		 jl	 SHORT $LN3@BlPciReadC
  00015	ba f3 00 00 00	 mov	 edx, 243		; 000000f3H
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  0001f	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN3@BlPciReadC:

; 244  :     BLASSERT(FunctionNumber < PCI_MAX_FUNCTIONS);

  00024	0f b6 4d 08	 movzx	 ecx, BYTE PTR _FunctionNumber$[ebp]
  00028	83 f9 08	 cmp	 ecx, 8
  0002b	7c 0f		 jl	 SHORT $LN2@BlPciReadC
  0002d	ba f4 00 00 00	 mov	 edx, 244		; 000000f4H
  00032	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  00037	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN2@BlPciReadC:

; 245  :     BLASSERT((RegisterNumber % sizeof(UINT32)) == 0);

  0003c	0f b6 45 0c	 movzx	 eax, BYTE PTR _RegisterNumber$[ebp]
  00040	33 d2		 xor	 edx, edx
  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	f7 f1		 div	 ecx
  00049	85 d2		 test	 edx, edx
  0004b	74 0f		 je	 SHORT $LN1@BlPciReadC
  0004d	ba f5 00 00 00	 mov	 edx, 245		; 000000f5H
  00052	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  00057	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN1@BlPciReadC:

; 246  : 
; 247  :     BlRtlZeroMemory(&ConfigAddress, sizeof(ConfigAddress));

  0005c	ba 04 00 00 00	 mov	 edx, 4
  00061	8d 4d f8	 lea	 ecx, DWORD PTR _ConfigAddress$[ebp]
  00064	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 248  : 
; 249  :     ConfigAddress.u1.s1.BusNumber = BusNumber;

  00069	0f b6 55 f4	 movzx	 edx, BYTE PTR _BusNumber$[ebp]
  0006d	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00073	c1 e2 10	 shl	 edx, 16			; 00000010H
  00076	8b 45 f8	 mov	 eax, DWORD PTR _ConfigAddress$[ebp]
  00079	25 ff ff 00 ff	 and	 eax, -16711681		; ff00ffffH
  0007e	0b c2		 or	 eax, edx
  00080	89 45 f8	 mov	 DWORD PTR _ConfigAddress$[ebp], eax

; 250  :     ConfigAddress.u1.s1.DeviceNumber = DeviceNumber;

  00083	0f b6 4d f0	 movzx	 ecx, BYTE PTR _DeviceNumber$[ebp]
  00087	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0008a	c1 e1 0b	 shl	 ecx, 11			; 0000000bH
  0008d	8b 55 f8	 mov	 edx, DWORD PTR _ConfigAddress$[ebp]
  00090	81 e2 ff 07 ff
	ff		 and	 edx, -63489		; ffff07ffH
  00096	0b d1		 or	 edx, ecx
  00098	89 55 f8	 mov	 DWORD PTR _ConfigAddress$[ebp], edx

; 251  :     ConfigAddress.u1.s1.FunctionNumber = FunctionNumber;

  0009b	0f b6 45 08	 movzx	 eax, BYTE PTR _FunctionNumber$[ebp]
  0009f	83 e0 07	 and	 eax, 7
  000a2	c1 e0 08	 shl	 eax, 8
  000a5	8b 4d f8	 mov	 ecx, DWORD PTR _ConfigAddress$[ebp]
  000a8	81 e1 ff f8 ff
	ff		 and	 ecx, -1793		; fffff8ffH
  000ae	0b c8		 or	 ecx, eax
  000b0	89 4d f8	 mov	 DWORD PTR _ConfigAddress$[ebp], ecx

; 252  :     ConfigAddress.u1.s1.RegisterNumber = RegisterNumber >> 2;

  000b3	0f b6 55 0c	 movzx	 edx, BYTE PTR _RegisterNumber$[ebp]
  000b7	c1 fa 02	 sar	 edx, 2
  000ba	83 e2 3f	 and	 edx, 63			; 0000003fH
  000bd	c1 e2 02	 shl	 edx, 2
  000c0	8b 45 f8	 mov	 eax, DWORD PTR _ConfigAddress$[ebp]
  000c3	25 03 ff ff ff	 and	 eax, -253		; ffffff03H
  000c8	0b c2		 or	 eax, edx
  000ca	89 45 f8	 mov	 DWORD PTR _ConfigAddress$[ebp], eax

; 253  :     ConfigAddress.u1.s1.Enable = 1;

  000cd	8b 4d f8	 mov	 ecx, DWORD PTR _ConfigAddress$[ebp]
  000d0	81 c9 00 00 00
	80		 or	 ecx, -2147483648	; 80000000H
  000d6	89 4d f8	 mov	 DWORD PTR _ConfigAddress$[ebp], ecx

; 254  : 
; 255  :     BlRtlWritePort32(PCI_ADDRESS_PORT, ConfigAddress.u1.Value);

  000d9	8b 55 f8	 mov	 edx, DWORD PTR _ConfigAddress$[ebp]
  000dc	b9 f8 0c 00 00	 mov	 ecx, 3320		; 00000cf8H
  000e1	e8 00 00 00 00	 call	 ?BlRtlWritePort32@@YIXGK@Z ; BlRtlWritePort32

; 256  : 
; 257  :     Value = BlRtlReadPort32(PCI_DATA_PORT);

  000e6	b9 fc 0c 00 00	 mov	 ecx, 3324		; 00000cfcH
  000eb	e8 00 00 00 00	 call	 ?BlRtlReadPort32@@YIKG@Z ; BlRtlReadPort32
  000f0	89 45 fc	 mov	 DWORD PTR _Value$[ebp], eax

; 258  : 
; 259  :     return Value;

  000f3	8b 45 fc	 mov	 eax, DWORD PTR _Value$[ebp]

; 260  : }

  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c2 08 00	 ret	 8
?BlPciReadConfigurationRegister@@YIKEEEE@Z ENDP		; BlPciReadConfigurationRegister
_TEXT	ENDS
PUBLIC	?BlPciWriteConfigurationRegister@@YIXEEEEK@Z	; BlPciWriteConfigurationRegister
; Function compile flags: /Odtp
;	COMDAT ?BlPciWriteConfigurationRegister@@YIXEEEEK@Z
_TEXT	SEGMENT
_DeviceNumber$ = -12					; size = 1
_BusNumber$ = -8					; size = 1
_ConfigAddress$ = -4					; size = 4
_FunctionNumber$ = 8					; size = 1
_RegisterNumber$ = 12					; size = 1
_Value$ = 16						; size = 4
?BlPciWriteConfigurationRegister@@YIXEEEEK@Z PROC	; BlPciWriteConfigurationRegister, COMDAT
; _BusNumber$ = cl
; _DeviceNumber$ = dl

; 291  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	88 55 f4	 mov	 BYTE PTR _DeviceNumber$[ebp], dl
  00009	88 4d f8	 mov	 BYTE PTR _BusNumber$[ebp], cl

; 292  :     PCI_CONFIG_ADDRESS ConfigAddress;
; 293  : 
; 294  :     BLASSERT(DeviceNumber < PCI_MAX_DEVICES);

  0000c	0f b6 45 f4	 movzx	 eax, BYTE PTR _DeviceNumber$[ebp]
  00010	83 f8 20	 cmp	 eax, 32			; 00000020H
  00013	7c 0f		 jl	 SHORT $LN3@BlPciWrite
  00015	ba 26 01 00 00	 mov	 edx, 294		; 00000126H
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  0001f	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN3@BlPciWrite:

; 295  :     BLASSERT(FunctionNumber < PCI_MAX_FUNCTIONS);

  00024	0f b6 4d 08	 movzx	 ecx, BYTE PTR _FunctionNumber$[ebp]
  00028	83 f9 08	 cmp	 ecx, 8
  0002b	7c 0f		 jl	 SHORT $LN2@BlPciWrite
  0002d	ba 27 01 00 00	 mov	 edx, 295		; 00000127H
  00032	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  00037	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN2@BlPciWrite:

; 296  :     BLASSERT((RegisterNumber % sizeof(UINT32)) == 0);

  0003c	0f b6 45 0c	 movzx	 eax, BYTE PTR _RegisterNumber$[ebp]
  00040	33 d2		 xor	 edx, edx
  00042	b9 04 00 00 00	 mov	 ecx, 4
  00047	f7 f1		 div	 ecx
  00049	85 d2		 test	 edx, edx
  0004b	74 0f		 je	 SHORT $LN1@BlPciWrite
  0004d	ba 28 01 00 00	 mov	 edx, 296		; 00000128H
  00052	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  00057	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN1@BlPciWrite:

; 297  : 
; 298  :     BlRtlZeroMemory(&ConfigAddress, sizeof(ConfigAddress));

  0005c	ba 04 00 00 00	 mov	 edx, 4
  00061	8d 4d fc	 lea	 ecx, DWORD PTR _ConfigAddress$[ebp]
  00064	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 299  : 
; 300  :     ConfigAddress.u1.s1.BusNumber = BusNumber;

  00069	0f b6 55 f8	 movzx	 edx, BYTE PTR _BusNumber$[ebp]
  0006d	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00073	c1 e2 10	 shl	 edx, 16			; 00000010H
  00076	8b 45 fc	 mov	 eax, DWORD PTR _ConfigAddress$[ebp]
  00079	25 ff ff 00 ff	 and	 eax, -16711681		; ff00ffffH
  0007e	0b c2		 or	 eax, edx
  00080	89 45 fc	 mov	 DWORD PTR _ConfigAddress$[ebp], eax

; 301  :     ConfigAddress.u1.s1.DeviceNumber = DeviceNumber;

  00083	0f b6 4d f4	 movzx	 ecx, BYTE PTR _DeviceNumber$[ebp]
  00087	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0008a	c1 e1 0b	 shl	 ecx, 11			; 0000000bH
  0008d	8b 55 fc	 mov	 edx, DWORD PTR _ConfigAddress$[ebp]
  00090	81 e2 ff 07 ff
	ff		 and	 edx, -63489		; ffff07ffH
  00096	0b d1		 or	 edx, ecx
  00098	89 55 fc	 mov	 DWORD PTR _ConfigAddress$[ebp], edx

; 302  :     ConfigAddress.u1.s1.FunctionNumber = FunctionNumber;

  0009b	0f b6 45 08	 movzx	 eax, BYTE PTR _FunctionNumber$[ebp]
  0009f	83 e0 07	 and	 eax, 7
  000a2	c1 e0 08	 shl	 eax, 8
  000a5	8b 4d fc	 mov	 ecx, DWORD PTR _ConfigAddress$[ebp]
  000a8	81 e1 ff f8 ff
	ff		 and	 ecx, -1793		; fffff8ffH
  000ae	0b c8		 or	 ecx, eax
  000b0	89 4d fc	 mov	 DWORD PTR _ConfigAddress$[ebp], ecx

; 303  :     ConfigAddress.u1.s1.RegisterNumber = RegisterNumber >> 2;

  000b3	0f b6 55 0c	 movzx	 edx, BYTE PTR _RegisterNumber$[ebp]
  000b7	c1 fa 02	 sar	 edx, 2
  000ba	83 e2 3f	 and	 edx, 63			; 0000003fH
  000bd	c1 e2 02	 shl	 edx, 2
  000c0	8b 45 fc	 mov	 eax, DWORD PTR _ConfigAddress$[ebp]
  000c3	25 03 ff ff ff	 and	 eax, -253		; ffffff03H
  000c8	0b c2		 or	 eax, edx
  000ca	89 45 fc	 mov	 DWORD PTR _ConfigAddress$[ebp], eax

; 304  :     ConfigAddress.u1.s1.Enable = 1;

  000cd	8b 4d fc	 mov	 ecx, DWORD PTR _ConfigAddress$[ebp]
  000d0	81 c9 00 00 00
	80		 or	 ecx, -2147483648	; 80000000H
  000d6	89 4d fc	 mov	 DWORD PTR _ConfigAddress$[ebp], ecx

; 305  : 
; 306  :     BlRtlWritePort32(PCI_ADDRESS_PORT, ConfigAddress.u1.Value);

  000d9	8b 55 fc	 mov	 edx, DWORD PTR _ConfigAddress$[ebp]
  000dc	b9 f8 0c 00 00	 mov	 ecx, 3320		; 00000cf8H
  000e1	e8 00 00 00 00	 call	 ?BlRtlWritePort32@@YIXGK@Z ; BlRtlWritePort32

; 307  : 
; 308  :     BlRtlWritePort32(PCI_DATA_PORT, Value);

  000e6	8b 55 10	 mov	 edx, DWORD PTR _Value$[ebp]
  000e9	b9 fc 0c 00 00	 mov	 ecx, 3324		; 00000cfcH
  000ee	e8 00 00 00 00	 call	 ?BlRtlWritePort32@@YIXGK@Z ; BlRtlWritePort32

; 309  : 
; 310  :     return;
; 311  : }

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c2 0c 00	 ret	 12			; 0000000cH
?BlPciWriteConfigurationRegister@@YIXEEEEK@Z ENDP	; BlPciWriteConfigurationRegister
_TEXT	ENDS
PUBLIC	?BlPciReadConfigurationSpace@@YIXEEEEPAXG@Z	; BlPciReadConfigurationSpace
; Function compile flags: /Odtp
;	COMDAT ?BlPciReadConfigurationSpace@@YIXEEEEPAXG@Z
_TEXT	SEGMENT
_DeviceNumber$ = -16					; size = 1
_BusNumber$ = -12					; size = 1
_Count$ = -8						; size = 2
_Index$ = -4						; size = 2
_FunctionNumber$ = 8					; size = 1
_RegisterNumber$ = 12					; size = 1
_Buffer$ = 16						; size = 4
_BufferSize$ = 20					; size = 2
?BlPciReadConfigurationSpace@@YIXEEEEPAXG@Z PROC	; BlPciReadConfigurationSpace, COMDAT
; _BusNumber$ = cl
; _DeviceNumber$ = dl

; 345  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	88 55 f0	 mov	 BYTE PTR _DeviceNumber$[ebp], dl
  00009	88 4d f4	 mov	 BYTE PTR _BusNumber$[ebp], cl

; 346  :     UINT16 Count;
; 347  :     UINT16 Index;
; 348  : 
; 349  :     BLASSERT((RegisterNumber % sizeof(UINT32)) == 0);

  0000c	0f b6 45 0c	 movzx	 eax, BYTE PTR _RegisterNumber$[ebp]
  00010	33 d2		 xor	 edx, edx
  00012	b9 04 00 00 00	 mov	 ecx, 4
  00017	f7 f1		 div	 ecx
  00019	85 d2		 test	 edx, edx
  0001b	74 0f		 je	 SHORT $LN5@BlPciReadC@2
  0001d	ba 5d 01 00 00	 mov	 edx, 349		; 0000015dH
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  00027	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN5@BlPciReadC@2:

; 350  :     BLASSERT((BufferSize % sizeof(UINT32)) == 0);

  0002c	0f b7 45 14	 movzx	 eax, WORD PTR _BufferSize$[ebp]
  00030	33 d2		 xor	 edx, edx
  00032	b9 04 00 00 00	 mov	 ecx, 4
  00037	f7 f1		 div	 ecx
  00039	85 d2		 test	 edx, edx
  0003b	74 0f		 je	 SHORT $LN4@BlPciReadC@2
  0003d	ba 5e 01 00 00	 mov	 edx, 350		; 0000015eH
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  00047	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN4@BlPciReadC@2:

; 351  : 
; 352  :     Count = BufferSize / sizeof(UINT32);

  0004c	0f b7 55 14	 movzx	 edx, WORD PTR _BufferSize$[ebp]
  00050	c1 ea 02	 shr	 edx, 2
  00053	66 89 55 f8	 mov	 WORD PTR _Count$[ebp], dx

; 353  : 
; 354  :     for (Index = 0; Index < Count; Index += 1) {

  00057	66 c7 45 fc 00
	00		 mov	 WORD PTR _Index$[ebp], 0
  0005d	eb 0b		 jmp	 SHORT $LN3@BlPciReadC@2
$LN2@BlPciReadC@2:
  0005f	0f b7 45 fc	 movzx	 eax, WORD PTR _Index$[ebp]
  00063	83 c0 01	 add	 eax, 1
  00066	66 89 45 fc	 mov	 WORD PTR _Index$[ebp], ax
$LN3@BlPciReadC@2:
  0006a	0f b7 4d fc	 movzx	 ecx, WORD PTR _Index$[ebp]
  0006e	0f b7 55 f8	 movzx	 edx, WORD PTR _Count$[ebp]
  00072	3b ca		 cmp	 ecx, edx
  00074	7d 27		 jge	 SHORT $LN6@BlPciReadC@2

; 355  : 
; 356  :         ((PUINT32) Buffer)[Index] = BlPciReadConfigurationRegister(BusNumber,
; 357  :                                                                   DeviceNumber,
; 358  :                                                                   FunctionNumber,
; 359  :                                                                   (UINT8) (RegisterNumber + (Index * sizeof(UINT32))));

  00076	0f b6 45 0c	 movzx	 eax, BYTE PTR _RegisterNumber$[ebp]
  0007a	0f b7 4d fc	 movzx	 ecx, WORD PTR _Index$[ebp]
  0007e	8d 14 88	 lea	 edx, DWORD PTR [eax+ecx*4]
  00081	52		 push	 edx
  00082	8a 45 08	 mov	 al, BYTE PTR _FunctionNumber$[ebp]
  00085	50		 push	 eax
  00086	8a 55 f0	 mov	 dl, BYTE PTR _DeviceNumber$[ebp]
  00089	8a 4d f4	 mov	 cl, BYTE PTR _BusNumber$[ebp]
  0008c	e8 00 00 00 00	 call	 ?BlPciReadConfigurationRegister@@YIKEEEE@Z ; BlPciReadConfigurationRegister
  00091	0f b7 4d fc	 movzx	 ecx, WORD PTR _Index$[ebp]
  00095	8b 55 10	 mov	 edx, DWORD PTR _Buffer$[ebp]
  00098	89 04 8a	 mov	 DWORD PTR [edx+ecx*4], eax

; 360  :     }

  0009b	eb c2		 jmp	 SHORT $LN2@BlPciReadC@2
$LN6@BlPciReadC@2:

; 361  : 
; 362  :     return;
; 363  : }

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 10 00	 ret	 16			; 00000010H
?BlPciReadConfigurationSpace@@YIXEEEEPAXG@Z ENDP	; BlPciReadConfigurationSpace
_TEXT	ENDS
PUBLIC	?BlPciScanDevices@@YIXXZ			; BlPciScanDevices
EXTRN	?BlMmMapVirtualRange@@YIXPAX0KEEE@Z:PROC	; BlMmMapVirtualRange
EXTRN	__allshl:PROC
EXTRN	__aullshr:PROC
; Function compile flags: /Odtp
;	COMDAT ?BlPciScanDevices@@YIXXZ
_TEXT	SEGMENT
tv339 = -132						; size = 8
tv326 = -124						; size = 8
tv152 = -116						; size = 4
tv149 = -112						; size = 4
tv128 = -108						; size = 4
_Config$ = -104						; size = 65
_NodeType$ = -30					; size = 1
_FunctionNumber$ = -29					; size = 1
_BaseAddress$ = -28					; size = 4
_DeviceNumber$ = -21					; size = 1
_OldValue$ = -20					; size = 4
_Address$ = -16						; size = 8
_Size$ = -8						; size = 4
_BaseAddressRegister$ = -3				; size = 1
_BusNumber$ = -2					; size = 1
_Index$ = -1						; size = 1
?BlPciScanDevices@@YIXXZ PROC				; BlPciScanDevices, COMDAT

; 378  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 00 00
	00		 sub	 esp, 132		; 00000084H

; 379  :     UINT64 Address;
; 380  :     PPCI_BASE_ADDRESS BaseAddress;
; 381  :     UINT8 BaseAddressRegister;
; 382  :     UINT8 BusNumber;
; 383  :     PCI_CONFIGURATION_SPACE_HEADER Config;
; 384  :     UINT8 DeviceNumber;
; 385  :     UINT8 FunctionNumber;
; 386  :     UINT8 Index;
; 387  :     UINT8 NodeType;
; 388  :     UINT32 OldValue;
; 389  :     UINT32 Size;
; 390  : 
; 391  :     for (BusNumber = 0; BusNumber <= BlPciInstallationCheck.LastBusNumber; BusNumber += 1) {

  00009	c6 45 fe 00	 mov	 BYTE PTR _BusNumber$[ebp], 0
  0000d	eb 0a		 jmp	 SHORT $LN30@BlPciScanD
$LN29@BlPciScanD:
  0000f	0f b6 45 fe	 movzx	 eax, BYTE PTR _BusNumber$[ebp]
  00013	83 c0 01	 add	 eax, 1
  00016	88 45 fe	 mov	 BYTE PTR _BusNumber$[ebp], al
$LN30@BlPciScanD:
  00019	0f b6 4d fe	 movzx	 ecx, BYTE PTR _BusNumber$[ebp]
  0001d	0f b6 15 13 00
	00 00		 movzx	 edx, BYTE PTR ?BlPciInstallationCheck@@3U_PCI_INSTALLATION_CHECK@@A+19
  00024	3b ca		 cmp	 ecx, edx
  00026	0f 8f 24 03 00
	00		 jg	 $LN31@BlPciScanD

; 392  : 
; 393  :         for (DeviceNumber = 0; DeviceNumber < PCI_MAX_DEVICES; DeviceNumber += 1) {

  0002c	c6 45 eb 00	 mov	 BYTE PTR _DeviceNumber$[ebp], 0
  00030	eb 0a		 jmp	 SHORT $LN27@BlPciScanD
$LN26@BlPciScanD:
  00032	0f b6 45 eb	 movzx	 eax, BYTE PTR _DeviceNumber$[ebp]
  00036	83 c0 01	 add	 eax, 1
  00039	88 45 eb	 mov	 BYTE PTR _DeviceNumber$[ebp], al
$LN27@BlPciScanD:
  0003c	0f b6 4d eb	 movzx	 ecx, BYTE PTR _DeviceNumber$[ebp]
  00040	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00043	0f 8d 02 03 00
	00		 jge	 $LN25@BlPciScanD

; 394  : 
; 395  :             for (FunctionNumber = 0; FunctionNumber < PCI_MAX_FUNCTIONS; FunctionNumber += 1) {

  00049	c6 45 e3 00	 mov	 BYTE PTR _FunctionNumber$[ebp], 0
  0004d	eb 0a		 jmp	 SHORT $LN24@BlPciScanD
$LN23@BlPciScanD:
  0004f	0f b6 55 e3	 movzx	 edx, BYTE PTR _FunctionNumber$[ebp]
  00053	83 c2 01	 add	 edx, 1
  00056	88 55 e3	 mov	 BYTE PTR _FunctionNumber$[ebp], dl
$LN24@BlPciScanD:
  00059	0f b6 45 e3	 movzx	 eax, BYTE PTR _FunctionNumber$[ebp]
  0005d	83 f8 08	 cmp	 eax, 8
  00060	0f 8d e0 02 00
	00		 jge	 $LN22@BlPciScanD

; 396  : 
; 397  :                 BlRtlZeroMemory(&Config, sizeof(Config));

  00066	ba 41 00 00 00	 mov	 edx, 65			; 00000041H
  0006b	8d 4d 98	 lea	 ecx, DWORD PTR _Config$[ebp]
  0006e	e8 00 00 00 00	 call	 ?BlRtlZeroMemory@@YIXPAXK@Z ; BlRtlZeroMemory

; 398  : 
; 399  :                 Config.VendorId = PCI_INVALID_VENDORID;

  00073	66 c7 45 98 ff
	ff		 mov	 WORD PTR _Config$[ebp], 65535 ; 0000ffffH

; 400  : 
; 401  :                 BlPciReadConfigurationSpace(BusNumber,
; 402  :                                             DeviceNumber,
; 403  :                                             FunctionNumber,
; 404  :                                             0,
; 405  :                                             &Config,
; 406  :                                             FIELD_OFFSET(PCI_CONFIGURATION_SPACE_HEADER, u1.DynamicStart));

  00079	6a 10		 push	 16			; 00000010H
  0007b	8d 4d 98	 lea	 ecx, DWORD PTR _Config$[ebp]
  0007e	51		 push	 ecx
  0007f	6a 00		 push	 0
  00081	8a 55 e3	 mov	 dl, BYTE PTR _FunctionNumber$[ebp]
  00084	52		 push	 edx
  00085	8a 55 eb	 mov	 dl, BYTE PTR _DeviceNumber$[ebp]
  00088	8a 4d fe	 mov	 cl, BYTE PTR _BusNumber$[ebp]
  0008b	e8 00 00 00 00	 call	 ?BlPciReadConfigurationSpace@@YIXEEEEPAXG@Z ; BlPciReadConfigurationSpace

; 407  : 
; 408  :                 if ((Config.VendorId == PCI_INVALID_VENDORID) || (Config.VendorId == 0)) {

  00090	0f b7 45 98	 movzx	 eax, WORD PTR _Config$[ebp]
  00094	3d ff ff 00 00	 cmp	 eax, 65535		; 0000ffffH
  00099	74 08		 je	 SHORT $LN20@BlPciScanD
  0009b	0f b7 4d 98	 movzx	 ecx, WORD PTR _Config$[ebp]
  0009f	85 c9		 test	 ecx, ecx
  000a1	75 02		 jne	 SHORT $LN21@BlPciScanD
$LN20@BlPciScanD:

; 409  : 
; 410  :                     continue;

  000a3	eb aa		 jmp	 SHORT $LN23@BlPciScanD
$LN21@BlPciScanD:

; 411  :                 }
; 412  : 
; 413  :                 NodeType = Config.HeaderType & PCI_TYPE_MASK;

  000a5	0f b6 55 a6	 movzx	 edx, BYTE PTR _Config$[ebp+14]
  000a9	83 e2 7f	 and	 edx, 127		; 0000007fH
  000ac	88 55 e2	 mov	 BYTE PTR _NodeType$[ebp], dl

; 414  : 
; 415  :                 switch (NodeType) {

  000af	8a 45 e2	 mov	 al, BYTE PTR _NodeType$[ebp]
  000b2	88 45 94	 mov	 BYTE PTR tv128[ebp], al
  000b5	80 7d 94 00	 cmp	 BYTE PTR tv128[ebp], 0
  000b9	74 05		 je	 SHORT $LN17@BlPciScanD
  000bb	e9 74 02 00 00	 jmp	 $LN18@BlPciScanD
$LN17@BlPciScanD:

; 416  : 
; 417  :                     case PCI_DEVICE: {
; 418  : 
; 419  : #if PCI_VERBOSE
; 420  : 
; 421  :                         BlRtlPrintf("PCI: %02x:%02x:%02x: Device %04x:%04x [BC=%02x SC=%02x PI=%02x]\n",
; 422  :                                     BusNumber,
; 423  :                                     DeviceNumber,
; 424  :                                     FunctionNumber,
; 425  :                                     Config.VendorId,
; 426  :                                     Config.DeviceId,
; 427  :                                     Config.BaseClass,
; 428  :                                     Config.SubClass,
; 429  :                                     Config.ProgrammingInterface
; 430  :                                     );
; 431  : 
; 432  : #endif
; 433  : 
; 434  :                         BlPciReadConfigurationSpace(BusNumber,
; 435  :                                                     DeviceNumber,
; 436  :                                                     FunctionNumber,
; 437  :                                                     FIELD_OFFSET(PCI_CONFIGURATION_SPACE_HEADER, u1.DynamicStart),
; 438  :                                                     &Config.u1.DynamicStart,
; 439  :                                                     FIELD_OFFSET(PCI_CONFIGURATION_SPACE_HEADER, u1.Device.__End) - FIELD_OFFSET(PCI_CONFIGURATION_SPACE_HEADER, u1.DynamicStart));

  000c0	6a 30		 push	 48			; 00000030H
  000c2	8d 4d a8	 lea	 ecx, DWORD PTR _Config$[ebp+16]
  000c5	51		 push	 ecx
  000c6	6a 10		 push	 16			; 00000010H
  000c8	8a 55 e3	 mov	 dl, BYTE PTR _FunctionNumber$[ebp]
  000cb	52		 push	 edx
  000cc	8a 55 eb	 mov	 dl, BYTE PTR _DeviceNumber$[ebp]
  000cf	8a 4d fe	 mov	 cl, BYTE PTR _BusNumber$[ebp]
  000d2	e8 00 00 00 00	 call	 ?BlPciReadConfigurationSpace@@YIXEEEEPAXG@Z ; BlPciReadConfigurationSpace

; 440  : 
; 441  :                         for (Index = 0; Index < PCI_DEVICE_BASE_ADDRESS_COUNT; Index += 1) {

  000d7	c6 45 ff 00	 mov	 BYTE PTR _Index$[ebp], 0
  000db	eb 0a		 jmp	 SHORT $LN16@BlPciScanD
$LN15@BlPciScanD:
  000dd	0f b6 45 ff	 movzx	 eax, BYTE PTR _Index$[ebp]
  000e1	83 c0 01	 add	 eax, 1
  000e4	88 45 ff	 mov	 BYTE PTR _Index$[ebp], al
$LN16@BlPciScanD:
  000e7	0f b6 4d ff	 movzx	 ecx, BYTE PTR _Index$[ebp]
  000eb	83 f9 06	 cmp	 ecx, 6
  000ee	0f 8d 40 02 00
	00		 jge	 $LN18@BlPciScanD

; 442  : 
; 443  :                             BaseAddress = (PPCI_BASE_ADDRESS) &Config.u1.Device.BaseAddressRegister[Index];

  000f4	0f b6 55 ff	 movzx	 edx, BYTE PTR _Index$[ebp]
  000f8	8d 44 95 a8	 lea	 eax, DWORD PTR _Config$[ebp+edx*4+16]
  000fc	89 45 e4	 mov	 DWORD PTR _BaseAddress$[ebp], eax

; 444  :                             BaseAddressRegister = (UINT8) FIELD_OFFSET(PCI_CONFIGURATION_SPACE_HEADER, u1.Device.BaseAddressRegister[Index]);

  000ff	33 c9		 xor	 ecx, ecx
  00101	83 c1 10	 add	 ecx, 16			; 00000010H
  00104	0f b6 55 ff	 movzx	 edx, BYTE PTR _Index$[ebp]
  00108	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  0010b	88 45 fd	 mov	 BYTE PTR _BaseAddressRegister$[ebp], al

; 445  :                             Address = 0;

  0010e	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _Address$[ebp], 0
  00115	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _Address$[ebp+4], 0

; 446  : 
; 447  :                             switch (BaseAddress->u1.Common.Type) {

  0011c	8b 4d e4	 mov	 ecx, DWORD PTR _BaseAddress$[ebp]
  0011f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00121	83 e2 01	 and	 edx, 1
  00124	89 55 90	 mov	 DWORD PTR tv149[ebp], edx
  00127	74 05		 je	 SHORT $LN11@BlPciScanD
  00129	e9 01 02 00 00	 jmp	 $LN12@BlPciScanD
$LN11@BlPciScanD:

; 448  : 
; 449  :                                 case PCI_BASE_ADDRESS_MEMORY: {
; 450  : 
; 451  :                                     SATISFY_OVERZEALOUS_COMPILER(Size = 0);

  0012e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Size$[ebp], 0

; 452  : 
; 453  :                                     switch (BaseAddress->u1.Memory.Type) {

  00135	8b 45 e4	 mov	 eax, DWORD PTR _BaseAddress$[ebp]
  00138	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013a	d1 e9		 shr	 ecx, 1
  0013c	83 e1 03	 and	 ecx, 3
  0013f	89 4d 8c	 mov	 DWORD PTR tv152[ebp], ecx
  00142	0f 82 20 01 00
	00		 jb	 $LN9@BlPciScanD
  00148	83 7d 8c 01	 cmp	 DWORD PTR tv152[ebp], 1
  0014c	76 0f		 jbe	 SHORT $LN8@BlPciScanD
  0014e	83 7d 8c 02	 cmp	 DWORD PTR tv152[ebp], 2
  00152	0f 84 83 00 00
	00		 je	 $LN7@BlPciScanD
  00158	e9 0b 01 00 00	 jmp	 $LN9@BlPciScanD
$LN8@BlPciScanD:

; 454  : 
; 455  :                                         case PCI_BASE_ADDRESS_MEMORY_32:
; 456  :                                         case PCI_BASE_ADDRESS_MEMORY_32_1MB: {
; 457  : 
; 458  :                                             Address = BaseAddress->u1.Memory.Base << PCI_BASE_ADDRESS_SHIFT;

  0015d	8b 55 e4	 mov	 edx, DWORD PTR _BaseAddress$[ebp]
  00160	8b 02		 mov	 eax, DWORD PTR [edx]
  00162	c1 e8 04	 shr	 eax, 4
  00165	25 ff ff ff 0f	 and	 eax, 268435455		; 0fffffffH
  0016a	c1 e0 04	 shl	 eax, 4
  0016d	33 c9		 xor	 ecx, ecx
  0016f	89 45 f0	 mov	 DWORD PTR _Address$[ebp], eax
  00172	89 4d f4	 mov	 DWORD PTR _Address$[ebp+4], ecx

; 459  : 
; 460  :                                             OldValue = Config.u1.Device.BaseAddressRegister[Index];

  00175	0f b6 55 ff	 movzx	 edx, BYTE PTR _Index$[ebp]
  00179	8b 44 95 a8	 mov	 eax, DWORD PTR _Config$[ebp+edx*4+16]
  0017d	89 45 ec	 mov	 DWORD PTR _OldValue$[ebp], eax

; 461  : 
; 462  :                                             BlPciWriteConfigurationRegister(BusNumber,
; 463  :                                                                             DeviceNumber,
; 464  :                                                                             FunctionNumber,
; 465  :                                                                             BaseAddressRegister,
; 466  :                                                                             (UINT32) -1);

  00180	6a ff		 push	 -1
  00182	8a 4d fd	 mov	 cl, BYTE PTR _BaseAddressRegister$[ebp]
  00185	51		 push	 ecx
  00186	8a 55 e3	 mov	 dl, BYTE PTR _FunctionNumber$[ebp]
  00189	52		 push	 edx
  0018a	8a 55 eb	 mov	 dl, BYTE PTR _DeviceNumber$[ebp]
  0018d	8a 4d fe	 mov	 cl, BYTE PTR _BusNumber$[ebp]
  00190	e8 00 00 00 00	 call	 ?BlPciWriteConfigurationRegister@@YIXEEEEK@Z ; BlPciWriteConfigurationRegister

; 467  : 
; 468  :                                             Size = BlPciReadConfigurationRegister(BusNumber,
; 469  :                                                                                   DeviceNumber,
; 470  :                                                                                   FunctionNumber,
; 471  :                                                                                   BaseAddressRegister);

  00195	8a 45 fd	 mov	 al, BYTE PTR _BaseAddressRegister$[ebp]
  00198	50		 push	 eax
  00199	8a 4d e3	 mov	 cl, BYTE PTR _FunctionNumber$[ebp]
  0019c	51		 push	 ecx
  0019d	8a 55 eb	 mov	 dl, BYTE PTR _DeviceNumber$[ebp]
  001a0	8a 4d fe	 mov	 cl, BYTE PTR _BusNumber$[ebp]
  001a3	e8 00 00 00 00	 call	 ?BlPciReadConfigurationRegister@@YIKEEEE@Z ; BlPciReadConfigurationRegister
  001a8	89 45 f8	 mov	 DWORD PTR _Size$[ebp], eax

; 472  : 
; 473  :                                             BlPciWriteConfigurationRegister(BusNumber,
; 474  :                                                                             DeviceNumber,
; 475  :                                                                             FunctionNumber,
; 476  :                                                                             BaseAddressRegister,
; 477  :                                                                             OldValue);

  001ab	8b 55 ec	 mov	 edx, DWORD PTR _OldValue$[ebp]
  001ae	52		 push	 edx
  001af	8a 45 fd	 mov	 al, BYTE PTR _BaseAddressRegister$[ebp]
  001b2	50		 push	 eax
  001b3	8a 4d e3	 mov	 cl, BYTE PTR _FunctionNumber$[ebp]
  001b6	51		 push	 ecx
  001b7	8a 55 eb	 mov	 dl, BYTE PTR _DeviceNumber$[ebp]
  001ba	8a 4d fe	 mov	 cl, BYTE PTR _BusNumber$[ebp]
  001bd	e8 00 00 00 00	 call	 ?BlPciWriteConfigurationRegister@@YIXEEEEK@Z ; BlPciWriteConfigurationRegister

; 478  : 
; 479  :                                             Size &= ~(PCI_BASE_ADDRESS_FLAGS_MASK);

  001c2	8b 55 f8	 mov	 edx, DWORD PTR _Size$[ebp]
  001c5	83 e2 f0	 and	 edx, -16		; fffffff0H
  001c8	89 55 f8	 mov	 DWORD PTR _Size$[ebp], edx

; 480  : 
; 481  :                                             Size = (~Size) + 1;

  001cb	8b 45 f8	 mov	 eax, DWORD PTR _Size$[ebp]
  001ce	f7 d0		 not	 eax
  001d0	83 c0 01	 add	 eax, 1
  001d3	89 45 f8	 mov	 DWORD PTR _Size$[ebp], eax

; 482  : 
; 483  :                                             break;

  001d6	e9 8d 00 00 00	 jmp	 $LN9@BlPciScanD
$LN7@BlPciScanD:

; 484  :                                         }
; 485  : 
; 486  :                                         case PCI_BASE_ADDRESS_MEMORY_64: {
; 487  : 
; 488  :                                             Address = BaseAddress->u1.Memory64.Base << PCI_BASE_ADDRESS_SHIFT;

  001db	8b 4d e4	 mov	 ecx, DWORD PTR _BaseAddress$[ebp]
  001de	8b 01		 mov	 eax, DWORD PTR [ecx]
  001e0	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  001e3	b1 04		 mov	 cl, 4
  001e5	e8 00 00 00 00	 call	 __aullshr
  001ea	81 e2 ff ff ff
	0f		 and	 edx, 268435455		; 0fffffffH
  001f0	b1 04		 mov	 cl, 4
  001f2	e8 00 00 00 00	 call	 __allshl
  001f7	89 45 f0	 mov	 DWORD PTR _Address$[ebp], eax
  001fa	89 55 f4	 mov	 DWORD PTR _Address$[ebp+4], edx

; 489  : 
; 490  :                                             OldValue = Config.u1.Device.BaseAddressRegister[Index];

  001fd	0f b6 55 ff	 movzx	 edx, BYTE PTR _Index$[ebp]
  00201	8b 44 95 a8	 mov	 eax, DWORD PTR _Config$[ebp+edx*4+16]
  00205	89 45 ec	 mov	 DWORD PTR _OldValue$[ebp], eax

; 491  : 
; 492  :                                             BlPciWriteConfigurationRegister(BusNumber,
; 493  :                                                                             DeviceNumber,
; 494  :                                                                             FunctionNumber,
; 495  :                                                                             BaseAddressRegister,
; 496  :                                                                             (UINT32) -1);

  00208	6a ff		 push	 -1
  0020a	8a 4d fd	 mov	 cl, BYTE PTR _BaseAddressRegister$[ebp]
  0020d	51		 push	 ecx
  0020e	8a 55 e3	 mov	 dl, BYTE PTR _FunctionNumber$[ebp]
  00211	52		 push	 edx
  00212	8a 55 eb	 mov	 dl, BYTE PTR _DeviceNumber$[ebp]
  00215	8a 4d fe	 mov	 cl, BYTE PTR _BusNumber$[ebp]
  00218	e8 00 00 00 00	 call	 ?BlPciWriteConfigurationRegister@@YIXEEEEK@Z ; BlPciWriteConfigurationRegister

; 497  : 
; 498  :                                             Size = BlPciReadConfigurationRegister(BusNumber,
; 499  :                                                                                   DeviceNumber,
; 500  :                                                                                   FunctionNumber,
; 501  :                                                                                   BaseAddressRegister);

  0021d	8a 45 fd	 mov	 al, BYTE PTR _BaseAddressRegister$[ebp]
  00220	50		 push	 eax
  00221	8a 4d e3	 mov	 cl, BYTE PTR _FunctionNumber$[ebp]
  00224	51		 push	 ecx
  00225	8a 55 eb	 mov	 dl, BYTE PTR _DeviceNumber$[ebp]
  00228	8a 4d fe	 mov	 cl, BYTE PTR _BusNumber$[ebp]
  0022b	e8 00 00 00 00	 call	 ?BlPciReadConfigurationRegister@@YIKEEEE@Z ; BlPciReadConfigurationRegister
  00230	89 45 f8	 mov	 DWORD PTR _Size$[ebp], eax

; 502  : 
; 503  :                                             BlPciWriteConfigurationRegister(BusNumber,
; 504  :                                                                             DeviceNumber,
; 505  :                                                                             FunctionNumber,
; 506  :                                                                             BaseAddressRegister,
; 507  :                                                                             OldValue);

  00233	8b 55 ec	 mov	 edx, DWORD PTR _OldValue$[ebp]
  00236	52		 push	 edx
  00237	8a 45 fd	 mov	 al, BYTE PTR _BaseAddressRegister$[ebp]
  0023a	50		 push	 eax
  0023b	8a 4d e3	 mov	 cl, BYTE PTR _FunctionNumber$[ebp]
  0023e	51		 push	 ecx
  0023f	8a 55 eb	 mov	 dl, BYTE PTR _DeviceNumber$[ebp]
  00242	8a 4d fe	 mov	 cl, BYTE PTR _BusNumber$[ebp]
  00245	e8 00 00 00 00	 call	 ?BlPciWriteConfigurationRegister@@YIXEEEEK@Z ; BlPciWriteConfigurationRegister

; 508  : 
; 509  :                                             Size &= ~(PCI_BASE_ADDRESS_FLAGS_MASK);

  0024a	8b 55 f8	 mov	 edx, DWORD PTR _Size$[ebp]
  0024d	83 e2 f0	 and	 edx, -16		; fffffff0H
  00250	89 55 f8	 mov	 DWORD PTR _Size$[ebp], edx

; 510  : 
; 511  :                                             Size = (~Size) + 1;

  00253	8b 45 f8	 mov	 eax, DWORD PTR _Size$[ebp]
  00256	f7 d0		 not	 eax
  00258	83 c0 01	 add	 eax, 1
  0025b	89 45 f8	 mov	 DWORD PTR _Size$[ebp], eax

; 512  : 
; 513  :                                             Index += 1;

  0025e	0f b6 4d ff	 movzx	 ecx, BYTE PTR _Index$[ebp]
  00262	83 c1 01	 add	 ecx, 1
  00265	88 4d ff	 mov	 BYTE PTR _Index$[ebp], cl
$LN9@BlPciScanD:

; 514  : 
; 515  :                                             break;
; 516  :                                         }
; 517  :                                     }
; 518  : 
; 519  :                                     if (Address != 0) {

  00268	8b 55 f0	 mov	 edx, DWORD PTR _Address$[ebp]
  0026b	0b 55 f4	 or	 edx, DWORD PTR _Address$[ebp+4]
  0026e	0f 84 bb 00 00
	00		 je	 $LN12@BlPciScanD

; 520  : 
; 521  :                                         BLASSERT(Size > 0);

  00274	83 7d f8 00	 cmp	 DWORD PTR _Size$[ebp], 0
  00278	77 0f		 ja	 SHORT $LN5@BlPciScanD
  0027a	ba 09 02 00 00	 mov	 edx, 521		; 00000209H
  0027f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  00284	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN5@BlPciScanD:

; 522  : 
; 523  : #if PCI_VERBOSE
; 524  : 
; 525  :                                         BlRtlPrintf("PCI: %02x:%02x:%02x: IO Memory [%016I64x ... %016I64x]\n",
; 526  :                                                     BusNumber,
; 527  :                                                     DeviceNumber,
; 528  :                                                     FunctionNumber,
; 529  :                                                     Address,
; 530  :                                                     Address + Size - 1);
; 531  : 
; 532  : #endif
; 533  : 
; 534  :                                         if ((Address >= LEGACY_MEMORY_LIMIT) &&
; 535  :                                             ((Address + Size) > Address) &&
; 536  :                                             ((Address + Size) <= 0x100000000UI64)
; 537  :                                             ) {

  00289	83 7d f4 00	 cmp	 DWORD PTR _Address$[ebp+4], 0
  0028d	77 09		 ja	 SHORT $LN33@BlPciScanD
  0028f	81 7d f0 00 00
	10 00		 cmp	 DWORD PTR _Address$[ebp], 1048576 ; 00100000H
  00296	72 6b		 jb	 SHORT $LN4@BlPciScanD
$LN33@BlPciScanD:
  00298	8b 45 f8	 mov	 eax, DWORD PTR _Size$[ebp]
  0029b	33 c9		 xor	 ecx, ecx
  0029d	03 45 f0	 add	 eax, DWORD PTR _Address$[ebp]
  002a0	8b 55 f4	 mov	 edx, DWORD PTR _Address$[ebp+4]
  002a3	13 d1		 adc	 edx, ecx
  002a5	89 45 84	 mov	 DWORD PTR tv326[ebp], eax
  002a8	89 55 88	 mov	 DWORD PTR tv326[ebp+4], edx
  002ab	8b 45 88	 mov	 eax, DWORD PTR tv326[ebp+4]
  002ae	3b 45 f4	 cmp	 eax, DWORD PTR _Address$[ebp+4]
  002b1	72 50		 jb	 SHORT $LN4@BlPciScanD
  002b3	77 08		 ja	 SHORT $LN34@BlPciScanD
  002b5	8b 4d 84	 mov	 ecx, DWORD PTR tv326[ebp]
  002b8	3b 4d f0	 cmp	 ecx, DWORD PTR _Address$[ebp]
  002bb	76 46		 jbe	 SHORT $LN4@BlPciScanD
$LN34@BlPciScanD:
  002bd	8b 55 f8	 mov	 edx, DWORD PTR _Size$[ebp]
  002c0	33 c0		 xor	 eax, eax
  002c2	03 55 f0	 add	 edx, DWORD PTR _Address$[ebp]
  002c5	8b 4d f4	 mov	 ecx, DWORD PTR _Address$[ebp+4]
  002c8	13 c8		 adc	 ecx, eax
  002ca	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv339[ebp], edx
  002d0	89 4d 80	 mov	 DWORD PTR tv339[ebp+4], ecx
  002d3	83 7d 80 01	 cmp	 DWORD PTR tv339[ebp+4], 1
  002d7	77 2a		 ja	 SHORT $LN4@BlPciScanD
  002d9	72 09		 jb	 SHORT $LN35@BlPciScanD
  002db	83 bd 7c ff ff
	ff 00		 cmp	 DWORD PTR tv339[ebp], 0
  002e2	77 1f		 ja	 SHORT $LN4@BlPciScanD
$LN35@BlPciScanD:

; 538  : 
; 539  :                                             BlMmMapVirtualRange((PVOID) (ULONG_PTR) Address,
; 540  :                                                                 (PVOID) (ULONG_PTR) Address,
; 541  :                                                                 Size,
; 542  :                                                                 TRUE,
; 543  :                                                                 (BOOLEAN) BaseAddress->u1.Memory.Prefetch,
; 544  :                                                                 FALSE);

  002e4	6a 00		 push	 0
  002e6	8b 55 e4	 mov	 edx, DWORD PTR _BaseAddress$[ebp]
  002e9	8b 02		 mov	 eax, DWORD PTR [edx]
  002eb	c1 e8 03	 shr	 eax, 3
  002ee	83 e0 01	 and	 eax, 1
  002f1	50		 push	 eax
  002f2	6a 01		 push	 1
  002f4	8b 4d f8	 mov	 ecx, DWORD PTR _Size$[ebp]
  002f7	51		 push	 ecx
  002f8	8b 55 f0	 mov	 edx, DWORD PTR _Address$[ebp]
  002fb	8b 4d f0	 mov	 ecx, DWORD PTR _Address$[ebp]
  002fe	e8 00 00 00 00	 call	 ?BlMmMapVirtualRange@@YIXPAX0KEEE@Z ; BlMmMapVirtualRange
$LN4@BlPciScanD:

; 545  :                                         }
; 546  : 
; 547  :                                         //
; 548  :                                         // Check if this memory range maps OHCI 1394 registers.
; 549  :                                         //
; 550  : 
; 551  :                                         if ((Config.BaseClass == 0x0C) &&
; 552  :                                             (Config.SubClass == 0x00) &&
; 553  :                                             (Config.ProgrammingInterface == 0x10) &&
; 554  :                                             (BlPciOhci1394BaseAddress == 0)) {

  00303	0f b6 55 a3	 movzx	 edx, BYTE PTR _Config$[ebp+11]
  00307	83 fa 0c	 cmp	 edx, 12			; 0000000cH
  0030a	75 23		 jne	 SHORT $LN12@BlPciScanD
  0030c	0f b6 45 a2	 movzx	 eax, BYTE PTR _Config$[ebp+10]
  00310	85 c0		 test	 eax, eax
  00312	75 1b		 jne	 SHORT $LN12@BlPciScanD
  00314	0f b6 4d a1	 movzx	 ecx, BYTE PTR _Config$[ebp+9]
  00318	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0031b	75 12		 jne	 SHORT $LN12@BlPciScanD
  0031d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?BlPciOhci1394BaseAddress@@3KA, 0 ; BlPciOhci1394BaseAddress
  00324	75 09		 jne	 SHORT $LN12@BlPciScanD

; 555  : 
; 556  :                                             BlPciOhci1394BaseAddress = (UINT32) Address;

  00326	8b 55 f0	 mov	 edx, DWORD PTR _Address$[ebp]
  00329	89 15 00 00 00
	00		 mov	 DWORD PTR ?BlPciOhci1394BaseAddress@@3KA, edx ; BlPciOhci1394BaseAddress
$LN12@BlPciScanD:

; 557  :                                         }
; 558  :                                     }
; 559  : 
; 560  :                                     break;
; 561  :                                 }
; 562  :                             }
; 563  :                         }

  0032f	e9 a9 fd ff ff	 jmp	 $LN15@BlPciScanD
$LN18@BlPciScanD:

; 564  : 
; 565  :                         break;
; 566  :                     }
; 567  : 
; 568  :                     case PCI_BRIDGE: {
; 569  : 
; 570  : #if PCI_VERBOSE
; 571  : 
; 572  :                         BlRtlPrintf("PCI: %02x:%02x:%02x: Bridge %04x:%04x\n",
; 573  :                                     BusNumber,
; 574  :                                     DeviceNumber,
; 575  :                                     FunctionNumber,
; 576  :                                     Config.VendorId,
; 577  :                                     Config.DeviceId);
; 578  : 
; 579  : #endif
; 580  : 
; 581  :                         break;
; 582  :                     }
; 583  :                 }
; 584  : 
; 585  :                 if ((Config.HeaderType & PCI_MULTI_FUNCTION) == 0) {

  00334	0f b6 45 a6	 movzx	 eax, BYTE PTR _Config$[ebp+14]
  00338	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0033d	75 02		 jne	 SHORT $LN1@BlPciScanD

; 586  : 
; 587  :                     break;

  0033f	eb 05		 jmp	 SHORT $LN22@BlPciScanD
$LN1@BlPciScanD:

; 588  :                 }
; 589  :             }

  00341	e9 09 fd ff ff	 jmp	 $LN23@BlPciScanD
$LN22@BlPciScanD:

; 590  :         }

  00346	e9 e7 fc ff ff	 jmp	 $LN26@BlPciScanD
$LN25@BlPciScanD:

; 591  :     }

  0034b	e9 bf fc ff ff	 jmp	 $LN29@BlPciScanD
$LN31@BlPciScanD:

; 592  : }

  00350	8b e5		 mov	 esp, ebp
  00352	5d		 pop	 ebp
  00353	c3		 ret	 0
?BlPciScanDevices@@YIXXZ ENDP				; BlPciScanDevices
_TEXT	ENDS
PUBLIC	??_C@_0BN@OCAODDMI@pci?3?5PCI?5BIOS?5not?5detected?$CB?6?$AA@ ; `string'
PUBLIC	?BlPciInitialize@@YIXXZ				; BlPciInitialize
EXTRN	?BlRtlHaltInternal@@YIXPBDK@Z:PROC		; BlRtlHaltInternal
EXTRN	?BlRtlPrintf@@YAEPBDZZ:PROC			; BlRtlPrintf
;	COMDAT ??_C@_0BN@OCAODDMI@pci?3?5PCI?5BIOS?5not?5detected?$CB?6?$AA@
CONST	SEGMENT
??_C@_0BN@OCAODDMI@pci?3?5PCI?5BIOS?5not?5detected?$CB?6?$AA@ DB 'pci: PC'
	DB	'I BIOS not detected!', 0aH, 00H		; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlPciInitialize@@YIXXZ
_TEXT	SEGMENT
?BlPciInitialize@@YIXXZ PROC				; BlPciInitialize, COMDAT

; 606  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 607  :     if (BlPciCheckBios(&BlPciInstallationCheck) == FALSE) {

  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?BlPciInstallationCheck@@3U_PCI_INSTALLATION_CHECK@@A ; BlPciInstallationCheck
  00008	e8 00 00 00 00	 call	 ?BlPciCheckBios@@YIEPAU_PCI_INSTALLATION_CHECK@@@Z ; BlPciCheckBios
  0000d	0f b6 c0	 movzx	 eax, al
  00010	85 c0		 test	 eax, eax
  00012	75 1c		 jne	 SHORT $LN1@BlPciIniti

; 608  : 
; 609  :         BlRtlPrintf("pci: PCI BIOS not detected!\n");

  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@OCAODDMI@pci?3?5PCI?5BIOS?5not?5detected?$CB?6?$AA@
  00019	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  0001e	83 c4 04	 add	 esp, 4

; 610  :         BlRtlHalt();

  00021	ba 62 02 00 00	 mov	 edx, 610		; 00000262H
  00026	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_09GGGJHACA@blpci?4cpp?$AA@
  0002b	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN1@BlPciIniti:

; 611  :     }
; 612  : 
; 613  : #if PCI_VERBOSE
; 614  : 
; 615  :     BlRtlPrintf("PCI: PCI BIOS detected.\n"
; 616  :                 "PCI:   Version         : %u.%u\n"
; 617  :                 "PCI:   Last Bus Number : %u\n",
; 618  :                 BlPciInstallationCheck.MajorVersion,
; 619  :                 BlPciInstallationCheck.MinorVersion,
; 620  :                 BlPciInstallationCheck.LastBusNumber);
; 621  : 
; 622  : #endif
; 623  : 
; 624  :     BlPciScanDevices();

  00030	e8 00 00 00 00	 call	 ?BlPciScanDevices@@YIXXZ ; BlPciScanDevices

; 625  : 
; 626  :     return;
; 627  : }

  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?BlPciInitialize@@YIXXZ ENDP				; BlPciInitialize
_TEXT	ENDS
END
