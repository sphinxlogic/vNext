; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\OSes\VERVE\verify\src\Trusted\BootLoader\SingLdrPc\blstring.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BlRtlConvertCharacterToUpperCase@@YIDD@Z	; BlRtlConvertCharacterToUpperCase
; Function compile flags: /Odtp
; File d:\oses\verve\verify\src\trusted\bootloader\singldrpc\blstring.cpp
;	COMDAT ?BlRtlConvertCharacterToUpperCase@@YIDD@Z
_TEXT	SEGMENT
_C$ = -4						; size = 1
?BlRtlConvertCharacterToUpperCase@@YIDD@Z PROC		; BlRtlConvertCharacterToUpperCase, COMDAT
; _C$ = cl

; 50   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	88 4d fc	 mov	 BYTE PTR _C$[ebp], cl

; 51   :     if ((C >= 'a') && (C <= 'z')) {

  00007	0f be 45 fc	 movsx	 eax, BYTE PTR _C$[ebp]
  0000b	83 f8 61	 cmp	 eax, 97			; 00000061H
  0000e	7c 12		 jl	 SHORT $LN1@BlRtlConve
  00010	0f be 4d fc	 movsx	 ecx, BYTE PTR _C$[ebp]
  00014	83 f9 7a	 cmp	 ecx, 122		; 0000007aH
  00017	7f 09		 jg	 SHORT $LN1@BlRtlConve

; 52   : 
; 53   :         return C + 'A' - 'a';

  00019	0f be 45 fc	 movsx	 eax, BYTE PTR _C$[ebp]
  0001d	83 e8 20	 sub	 eax, 32			; 00000020H
  00020	eb 03		 jmp	 SHORT $LN2@BlRtlConve
$LN1@BlRtlConve:

; 54   :     }
; 55   : 
; 56   :     return C;

  00022	8a 45 fc	 mov	 al, BYTE PTR _C$[ebp]
$LN2@BlRtlConve:

; 57   : }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?BlRtlConvertCharacterToUpperCase@@YIDD@Z ENDP		; BlRtlConvertCharacterToUpperCase
_TEXT	ENDS
PUBLIC	?BlRtlParsePositiveDecimal@@YIEPBDPAK1@Z	; BlRtlParsePositiveDecimal
; Function compile flags: /Odtp
;	COMDAT ?BlRtlParsePositiveDecimal@@YIEPBDPAK1@Z
_TEXT	SEGMENT
_Number$ = -20						; size = 4
_String$ = -16						; size = 4
_Digit$ = -12						; size = 4
_Temp$ = -8						; size = 4
_Index$ = -4						; size = 4
_CharactersConsumed$ = 8				; size = 4
?BlRtlParsePositiveDecimal@@YIEPBDPAK1@Z PROC		; BlRtlParsePositiveDecimal, COMDAT
; _String$ = ecx
; _Number$ = edx

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 55 ec	 mov	 DWORD PTR _Number$[ebp], edx
  00009	89 4d f0	 mov	 DWORD PTR _String$[ebp], ecx

; 89   :     UINT32 Digit;
; 90   :     UINT32 Index;
; 91   :     UINT32 Temp;
; 92   : 
; 93   :     if ((String[0] < '0') || (String[0] > '9')) {

  0000c	8b 45 f0	 mov	 eax, DWORD PTR _String$[ebp]
  0000f	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00012	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00015	7c 0b		 jl	 SHORT $LN6@BlRtlParse
  00017	8b 55 f0	 mov	 edx, DWORD PTR _String$[ebp]
  0001a	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0001d	83 f8 39	 cmp	 eax, 57			; 00000039H
  00020	7e 04		 jle	 SHORT $LN7@BlRtlParse
$LN6@BlRtlParse:

; 94   : 
; 95   :         return FALSE;

  00022	32 c0		 xor	 al, al
  00024	eb 76		 jmp	 SHORT $LN8@BlRtlParse
$LN7@BlRtlParse:

; 96   :     }
; 97   : 
; 98   :     Index = 0;

  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0

; 99   :     Temp = 0;

  0002d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Temp$[ebp], 0
$LN5@BlRtlParse:

; 100  : 
; 101  :     for (;;) {
; 102  : 
; 103  :         if ((String[Index] < '0') || (String[Index] > '9')) {

  00034	8b 4d f0	 mov	 ecx, DWORD PTR _String$[ebp]
  00037	03 4d fc	 add	 ecx, DWORD PTR _Index$[ebp]
  0003a	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0003d	83 fa 30	 cmp	 edx, 48			; 00000030H
  00040	7c 0e		 jl	 SHORT $LN2@BlRtlParse
  00042	8b 45 f0	 mov	 eax, DWORD PTR _String$[ebp]
  00045	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  00048	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0004b	83 f9 39	 cmp	 ecx, 57			; 00000039H
  0004e	7e 14		 jle	 SHORT $LN3@BlRtlParse
$LN2@BlRtlParse:

; 104  : 
; 105  :             *Number = Temp;

  00050	8b 55 ec	 mov	 edx, DWORD PTR _Number$[ebp]
  00053	8b 45 f8	 mov	 eax, DWORD PTR _Temp$[ebp]
  00056	89 02		 mov	 DWORD PTR [edx], eax

; 106  :             *CharactersConsumed = Index;

  00058	8b 4d 08	 mov	 ecx, DWORD PTR _CharactersConsumed$[ebp]
  0005b	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  0005e	89 11		 mov	 DWORD PTR [ecx], edx

; 107  :             return TRUE;

  00060	b0 01		 mov	 al, 1
  00062	eb 38		 jmp	 SHORT $LN8@BlRtlParse
$LN3@BlRtlParse:

; 108  :         }
; 109  : 
; 110  :         Digit = String[Index] - '0';

  00064	8b 45 f0	 mov	 eax, DWORD PTR _String$[ebp]
  00067	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  0006a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0006d	83 e9 30	 sub	 ecx, 48			; 00000030H
  00070	89 4d f4	 mov	 DWORD PTR _Digit$[ebp], ecx

; 111  : 
; 112  :         if (((Temp * 10) + Digit) < Temp) {

  00073	8b 55 f8	 mov	 edx, DWORD PTR _Temp$[ebp]
  00076	6b d2 0a	 imul	 edx, 10			; 0000000aH
  00079	03 55 f4	 add	 edx, DWORD PTR _Digit$[ebp]
  0007c	3b 55 f8	 cmp	 edx, DWORD PTR _Temp$[ebp]
  0007f	73 04		 jae	 SHORT $LN1@BlRtlParse

; 113  : 
; 114  :             return FALSE;

  00081	32 c0		 xor	 al, al
  00083	eb 17		 jmp	 SHORT $LN8@BlRtlParse
$LN1@BlRtlParse:

; 115  :         }
; 116  : 
; 117  :         Temp = (Temp * 10) + Digit;

  00085	8b 45 f8	 mov	 eax, DWORD PTR _Temp$[ebp]
  00088	6b c0 0a	 imul	 eax, 10			; 0000000aH
  0008b	03 45 f4	 add	 eax, DWORD PTR _Digit$[ebp]
  0008e	89 45 f8	 mov	 DWORD PTR _Temp$[ebp], eax

; 118  :         Index += 1;

  00091	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  00094	83 c1 01	 add	 ecx, 1
  00097	89 4d fc	 mov	 DWORD PTR _Index$[ebp], ecx

; 119  :     }

  0009a	eb 98		 jmp	 SHORT $LN5@BlRtlParse
$LN8@BlRtlParse:

; 120  : }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 04 00	 ret	 4
?BlRtlParsePositiveDecimal@@YIEPBDPAK1@Z ENDP		; BlRtlParsePositiveDecimal
_TEXT	ENDS
PUBLIC	??_C@_01PAPGNFGE@c?$AA@				; `string'
PUBLIC	??_C@_01LKDEMHDF@s?$AA@				; `string'
PUBLIC	??_C@_01JBBJJEPG@p?$AA@				; `string'
PUBLIC	??_C@_04HNPKCLBF@I64x?$AA@			; `string'
PUBLIC	??_C@_04MIFEFFFI@I64u?$AA@			; `string'
PUBLIC	??_C@_04JLINHGEI@I64d?$AA@			; `string'
PUBLIC	??_C@_01FJMABOPO@x?$AA@				; `string'
PUBLIC	??_C@_01OMGOGALD@u?$AA@				; `string'
PUBLIC	?BlRtlEqualStringN@@YIEPBD0K@Z			; BlRtlEqualStringN
PUBLIC	??_C@_01LPLHEDKD@d?$AA@				; `string'
PUBLIC	?BlRtlParseTypeSpecifier@@YIEPBDPAJPADPAEPAK@Z	; BlRtlParseTypeSpecifier
;	COMDAT ??_C@_01PAPGNFGE@c?$AA@
CONST	SEGMENT
??_C@_01PAPGNFGE@c?$AA@ DB 'c', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s?$AA@
CONST	SEGMENT
??_C@_01LKDEMHDF@s?$AA@ DB 's', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JBBJJEPG@p?$AA@
CONST	SEGMENT
??_C@_01JBBJJEPG@p?$AA@ DB 'p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04HNPKCLBF@I64x?$AA@
CONST	SEGMENT
??_C@_04HNPKCLBF@I64x?$AA@ DB 'I64x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MIFEFFFI@I64u?$AA@
CONST	SEGMENT
??_C@_04MIFEFFFI@I64u?$AA@ DB 'I64u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04JLINHGEI@I64d?$AA@
CONST	SEGMENT
??_C@_04JLINHGEI@I64d?$AA@ DB 'I64d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01FJMABOPO@x?$AA@
CONST	SEGMENT
??_C@_01FJMABOPO@x?$AA@ DB 'x', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OMGOGALD@u?$AA@
CONST	SEGMENT
??_C@_01OMGOGALD@u?$AA@ DB 'u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LPLHEDKD@d?$AA@
CONST	SEGMENT
??_C@_01LPLHEDKD@d?$AA@ DB 'd', 00H			; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlRtlParseTypeSpecifier@@YIEPBDPAJPADPAEPAK@Z
_TEXT	SEGMENT
tv88 = -29						; size = 1
_Width$ = -28						; size = 4
_String$ = -24						; size = 4
_Advance$ = -20						; size = 4
_Zero$ = -14						; size = 1
_WidthPresent$ = -13					; size = 1
_WidthPositiveValue$ = -12				; size = 4
_Index$ = -8						; size = 4
_Minus$ = -1						; size = 1
_PadCharacter$ = 8					; size = 4
_TokenType$ = 12					; size = 4
_CharactersConsumed$ = 16				; size = 4
?BlRtlParseTypeSpecifier@@YIEPBDPAJPADPAEPAK@Z PROC	; BlRtlParseTypeSpecifier, COMDAT
; _String$ = ecx
; _Width$ = edx

; 157  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 55 e4	 mov	 DWORD PTR _Width$[ebp], edx
  00009	89 4d e8	 mov	 DWORD PTR _String$[ebp], ecx

; 158  :     UINT32 Advance;
; 159  :     BOOLEAN WidthPresent;
; 160  :     UINT32 Index;
; 161  :     BOOLEAN Minus;
; 162  :     UINT32 WidthPositiveValue;
; 163  :     BOOLEAN Zero;
; 164  : 
; 165  :     SATISFY_OVERZEALOUS_COMPILER(WidthPositiveValue = 0);

  0000c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _WidthPositiveValue$[ebp], 0

; 166  : 
; 167  :     //
; 168  :     // Check if type specifier character is present.
; 169  :     //
; 170  : 
; 171  :     if (String[0] != '%') {

  00013	8b 45 e8	 mov	 eax, DWORD PTR _String$[ebp]
  00016	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00019	83 f9 25	 cmp	 ecx, 37			; 00000025H
  0001c	74 07		 je	 SHORT $LN38@BlRtlParse@2

; 172  : 
; 173  :         return FALSE;

  0001e	32 c0		 xor	 al, al
  00020	e9 dd 02 00 00	 jmp	 $LN39@BlRtlParse@2
$LN38@BlRtlParse@2:

; 174  :     }
; 175  : 
; 176  :     Index = 1;

  00025	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 1

; 177  : 
; 178  :     //
; 179  :     // Check for pad modifiers.
; 180  :     //
; 181  : 
; 182  :     Minus = FALSE;

  0002c	c6 45 ff 00	 mov	 BYTE PTR _Minus$[ebp], 0

; 183  :     Zero = FALSE;

  00030	c6 45 f2 00	 mov	 BYTE PTR _Zero$[ebp], 0
$LN37@BlRtlParse@2:

; 184  : 
; 185  :     for (;;) {
; 186  : 
; 187  :         if (String[Index] == '-') {

  00034	8b 55 e8	 mov	 edx, DWORD PTR _String$[ebp]
  00037	03 55 f8	 add	 edx, DWORD PTR _Index$[ebp]
  0003a	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0003d	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00040	75 1e		 jne	 SHORT $LN35@BlRtlParse@2

; 188  : 
; 189  :             if (Minus != FALSE) {

  00042	0f b6 4d ff	 movzx	 ecx, BYTE PTR _Minus$[ebp]
  00046	85 c9		 test	 ecx, ecx
  00048	74 07		 je	 SHORT $LN34@BlRtlParse@2

; 190  : 
; 191  :                 return FALSE;

  0004a	32 c0		 xor	 al, al
  0004c	e9 b1 02 00 00	 jmp	 $LN39@BlRtlParse@2
$LN34@BlRtlParse@2:

; 192  :             }
; 193  : 
; 194  :             Minus = TRUE;

  00051	c6 45 ff 01	 mov	 BYTE PTR _Minus$[ebp], 1

; 195  :             Index += 1;

  00055	8b 55 f8	 mov	 edx, DWORD PTR _Index$[ebp]
  00058	83 c2 01	 add	 edx, 1
  0005b	89 55 f8	 mov	 DWORD PTR _Index$[ebp], edx
  0005e	eb 2e		 jmp	 SHORT $LN33@BlRtlParse@2
$LN35@BlRtlParse@2:

; 196  : 
; 197  :         } else if (String[Index] == '0') {

  00060	8b 45 e8	 mov	 eax, DWORD PTR _String$[ebp]
  00063	03 45 f8	 add	 eax, DWORD PTR _Index$[ebp]
  00066	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00069	83 f9 30	 cmp	 ecx, 48			; 00000030H
  0006c	75 1e		 jne	 SHORT $LN32@BlRtlParse@2

; 198  : 
; 199  :             if (Zero != FALSE) {

  0006e	0f b6 55 f2	 movzx	 edx, BYTE PTR _Zero$[ebp]
  00072	85 d2		 test	 edx, edx
  00074	74 07		 je	 SHORT $LN31@BlRtlParse@2

; 200  : 
; 201  :                 return FALSE;

  00076	32 c0		 xor	 al, al
  00078	e9 85 02 00 00	 jmp	 $LN39@BlRtlParse@2
$LN31@BlRtlParse@2:

; 202  :             }
; 203  : 
; 204  :             Zero = TRUE;

  0007d	c6 45 f2 01	 mov	 BYTE PTR _Zero$[ebp], 1

; 205  :             Index += 1;

  00081	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  00084	83 c0 01	 add	 eax, 1
  00087	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax

; 206  : 
; 207  :         } else {

  0008a	eb 02		 jmp	 SHORT $LN33@BlRtlParse@2
$LN32@BlRtlParse@2:

; 208  : 
; 209  :             break;

  0008c	eb 02		 jmp	 SHORT $LN36@BlRtlParse@2
$LN33@BlRtlParse@2:

; 210  :         }
; 211  :     }

  0008e	eb a4		 jmp	 SHORT $LN37@BlRtlParse@2
$LN36@BlRtlParse@2:

; 212  : 
; 213  :     //
; 214  :     // - and 0 pad modifiers are mutually exclusive.
; 215  :     //
; 216  : 
; 217  :     if ((Minus != FALSE) && (Zero != FALSE)) {

  00090	0f b6 4d ff	 movzx	 ecx, BYTE PTR _Minus$[ebp]
  00094	85 c9		 test	 ecx, ecx
  00096	74 0f		 je	 SHORT $LN29@BlRtlParse@2
  00098	0f b6 55 f2	 movzx	 edx, BYTE PTR _Zero$[ebp]
  0009c	85 d2		 test	 edx, edx
  0009e	74 07		 je	 SHORT $LN29@BlRtlParse@2

; 218  : 
; 219  :         return FALSE;

  000a0	32 c0		 xor	 al, al
  000a2	e9 5b 02 00 00	 jmp	 $LN39@BlRtlParse@2
$LN29@BlRtlParse@2:

; 220  :     }
; 221  : 
; 222  :     //
; 223  :     // If there is a width value, then parse it.
; 224  :     //
; 225  : 
; 226  :     WidthPresent = ((String[Index] >= '1') && (String[Index] <= '9'));

  000a7	8b 45 e8	 mov	 eax, DWORD PTR _String$[ebp]
  000aa	03 45 f8	 add	 eax, DWORD PTR _Index$[ebp]
  000ad	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  000b0	83 f9 31	 cmp	 ecx, 49			; 00000031H
  000b3	7c 14		 jl	 SHORT $LN41@BlRtlParse@2
  000b5	8b 55 e8	 mov	 edx, DWORD PTR _String$[ebp]
  000b8	03 55 f8	 add	 edx, DWORD PTR _Index$[ebp]
  000bb	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000be	83 f8 39	 cmp	 eax, 57			; 00000039H
  000c1	7f 06		 jg	 SHORT $LN41@BlRtlParse@2
  000c3	c6 45 e3 01	 mov	 BYTE PTR tv88[ebp], 1
  000c7	eb 04		 jmp	 SHORT $LN42@BlRtlParse@2
$LN41@BlRtlParse@2:
  000c9	c6 45 e3 00	 mov	 BYTE PTR tv88[ebp], 0
$LN42@BlRtlParse@2:
  000cd	8a 4d e3	 mov	 cl, BYTE PTR tv88[ebp]
  000d0	88 4d f3	 mov	 BYTE PTR _WidthPresent$[ebp], cl

; 227  : 
; 228  :     if (WidthPresent != FALSE) {

  000d3	0f b6 55 f3	 movzx	 edx, BYTE PTR _WidthPresent$[ebp]
  000d7	85 d2		 test	 edx, edx
  000d9	74 29		 je	 SHORT $LN28@BlRtlParse@2

; 229  : 
; 230  :         if (BlRtlParsePositiveDecimal(&String[Index],
; 231  :                                       &WidthPositiveValue,
; 232  :                                       &Advance) == FALSE) {

  000db	8d 45 ec	 lea	 eax, DWORD PTR _Advance$[ebp]
  000de	50		 push	 eax
  000df	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  000e2	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  000e5	8d 55 f4	 lea	 edx, DWORD PTR _WidthPositiveValue$[ebp]
  000e8	e8 00 00 00 00	 call	 ?BlRtlParsePositiveDecimal@@YIEPBDPAK1@Z ; BlRtlParsePositiveDecimal
  000ed	0f b6 c8	 movzx	 ecx, al
  000f0	85 c9		 test	 ecx, ecx
  000f2	75 07		 jne	 SHORT $LN27@BlRtlParse@2

; 233  : 
; 234  :             return FALSE;

  000f4	32 c0		 xor	 al, al
  000f6	e9 07 02 00 00	 jmp	 $LN39@BlRtlParse@2
$LN27@BlRtlParse@2:

; 235  :         }
; 236  : 
; 237  :         Index += Advance;

  000fb	8b 55 f8	 mov	 edx, DWORD PTR _Index$[ebp]
  000fe	03 55 ec	 add	 edx, DWORD PTR _Advance$[ebp]
  00101	89 55 f8	 mov	 DWORD PTR _Index$[ebp], edx
$LN28@BlRtlParse@2:

; 238  :     }
; 239  : 
; 240  :     //
; 241  :     // Pad modifiers require width value.
; 242  :     //
; 243  : 
; 244  :     if (((Minus != FALSE) || (Zero != FALSE)) && (WidthPresent == FALSE)) {

  00104	0f b6 45 ff	 movzx	 eax, BYTE PTR _Minus$[ebp]
  00108	85 c0		 test	 eax, eax
  0010a	75 08		 jne	 SHORT $LN25@BlRtlParse@2
  0010c	0f b6 4d f2	 movzx	 ecx, BYTE PTR _Zero$[ebp]
  00110	85 c9		 test	 ecx, ecx
  00112	74 0f		 je	 SHORT $LN26@BlRtlParse@2
$LN25@BlRtlParse@2:
  00114	0f b6 55 f3	 movzx	 edx, BYTE PTR _WidthPresent$[ebp]
  00118	85 d2		 test	 edx, edx
  0011a	75 07		 jne	 SHORT $LN26@BlRtlParse@2

; 245  : 
; 246  :         return FALSE;

  0011c	32 c0		 xor	 al, al
  0011e	e9 df 01 00 00	 jmp	 $LN39@BlRtlParse@2
$LN26@BlRtlParse@2:

; 247  :     }
; 248  : 
; 249  :     //
; 250  :     // Set pad character.
; 251  :     //
; 252  : 
; 253  :     if (Zero != FALSE) {

  00123	0f b6 45 f2	 movzx	 eax, BYTE PTR _Zero$[ebp]
  00127	85 c0		 test	 eax, eax
  00129	74 08		 je	 SHORT $LN24@BlRtlParse@2

; 254  : 
; 255  :         *PadCharacter = '0';

  0012b	8b 4d 08	 mov	 ecx, DWORD PTR _PadCharacter$[ebp]
  0012e	c6 01 30	 mov	 BYTE PTR [ecx], 48	; 00000030H

; 256  : 
; 257  :     } else {

  00131	eb 06		 jmp	 SHORT $LN23@BlRtlParse@2
$LN24@BlRtlParse@2:

; 258  : 
; 259  :         *PadCharacter = ' ';

  00133	8b 55 08	 mov	 edx, DWORD PTR _PadCharacter$[ebp]
  00136	c6 02 20	 mov	 BYTE PTR [edx], 32	; 00000020H
$LN23@BlRtlParse@2:

; 260  :     }
; 261  : 
; 262  :     //
; 263  :     // Compute signed width value.
; 264  :     //
; 265  : 
; 266  :     if (WidthPresent == FALSE) {

  00139	0f b6 45 f3	 movzx	 eax, BYTE PTR _WidthPresent$[ebp]
  0013d	85 c0		 test	 eax, eax
  0013f	75 0b		 jne	 SHORT $LN22@BlRtlParse@2

; 267  : 
; 268  :         *Width = 0;

  00141	8b 4d e4	 mov	 ecx, DWORD PTR _Width$[ebp]
  00144	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  0014a	eb 1c		 jmp	 SHORT $LN21@BlRtlParse@2
$LN22@BlRtlParse@2:

; 269  : 
; 270  :     } else if (Minus == FALSE) {

  0014c	0f b6 55 ff	 movzx	 edx, BYTE PTR _Minus$[ebp]
  00150	85 d2		 test	 edx, edx
  00152	75 0a		 jne	 SHORT $LN20@BlRtlParse@2

; 271  : 
; 272  :         *Width = (INT32) WidthPositiveValue;

  00154	8b 45 e4	 mov	 eax, DWORD PTR _Width$[ebp]
  00157	8b 4d f4	 mov	 ecx, DWORD PTR _WidthPositiveValue$[ebp]
  0015a	89 08		 mov	 DWORD PTR [eax], ecx

; 273  : 
; 274  :     } else {

  0015c	eb 0a		 jmp	 SHORT $LN21@BlRtlParse@2
$LN20@BlRtlParse@2:

; 275  : 
; 276  :         *Width = -((INT32) WidthPositiveValue);

  0015e	8b 55 f4	 mov	 edx, DWORD PTR _WidthPositiveValue$[ebp]
  00161	f7 da		 neg	 edx
  00163	8b 45 e4	 mov	 eax, DWORD PTR _Width$[ebp]
  00166	89 10		 mov	 DWORD PTR [eax], edx
$LN21@BlRtlParse@2:

; 277  :     }
; 278  : 
; 279  :     //
; 280  :     // Set type character.
; 281  :     //
; 282  : 
; 283  :     if (BlRtlEqualStringN(&String[Index], "d", 1) != FALSE) {

  00168	6a 01		 push	 1
  0016a	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  0016d	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  00170	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LPLHEDKD@d?$AA@
  00175	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  0017a	0f b6 c8	 movzx	 ecx, al
  0017d	85 c9		 test	 ecx, ecx
  0017f	74 14		 je	 SHORT $LN18@BlRtlParse@2

; 284  : 
; 285  :         *TokenType = STRING_TOKEN_LONG;

  00181	8b 55 0c	 mov	 edx, DWORD PTR _TokenType$[ebp]
  00184	c6 02 01	 mov	 BYTE PTR [edx], 1

; 286  :         Index += 1;

  00187	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  0018a	83 c0 01	 add	 eax, 1
  0018d	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
  00190	e9 63 01 00 00	 jmp	 $LN17@BlRtlParse@2
$LN18@BlRtlParse@2:

; 287  : 
; 288  :     } else if (BlRtlEqualStringN(&String[Index], "u", 1) != FALSE) {

  00195	6a 01		 push	 1
  00197	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  0019a	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  0019d	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01OMGOGALD@u?$AA@
  001a2	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  001a7	0f b6 c8	 movzx	 ecx, al
  001aa	85 c9		 test	 ecx, ecx
  001ac	74 14		 je	 SHORT $LN16@BlRtlParse@2

; 289  : 
; 290  :         *TokenType = STRING_TOKEN_ULONG;

  001ae	8b 55 0c	 mov	 edx, DWORD PTR _TokenType$[ebp]
  001b1	c6 02 02	 mov	 BYTE PTR [edx], 2

; 291  :         Index += 1;

  001b4	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  001b7	83 c0 01	 add	 eax, 1
  001ba	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
  001bd	e9 36 01 00 00	 jmp	 $LN17@BlRtlParse@2
$LN16@BlRtlParse@2:

; 292  : 
; 293  :     } else if (BlRtlEqualStringN(&String[Index], "x", 1) != FALSE) {

  001c2	6a 01		 push	 1
  001c4	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  001c7	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  001ca	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01FJMABOPO@x?$AA@
  001cf	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  001d4	0f b6 c8	 movzx	 ecx, al
  001d7	85 c9		 test	 ecx, ecx
  001d9	74 14		 je	 SHORT $LN14@BlRtlParse@2

; 294  : 
; 295  :         *TokenType = STRING_TOKEN_ULONG_HEX;

  001db	8b 55 0c	 mov	 edx, DWORD PTR _TokenType$[ebp]
  001de	c6 02 03	 mov	 BYTE PTR [edx], 3

; 296  :         Index += 1;

  001e1	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  001e4	83 c0 01	 add	 eax, 1
  001e7	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
  001ea	e9 09 01 00 00	 jmp	 $LN17@BlRtlParse@2
$LN14@BlRtlParse@2:

; 297  : 
; 298  :     } else if (BlRtlEqualStringN(&String[Index], "I64d", 4) != FALSE) {

  001ef	6a 04		 push	 4
  001f1	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  001f4	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  001f7	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_04JLINHGEI@I64d?$AA@
  001fc	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  00201	0f b6 c8	 movzx	 ecx, al
  00204	85 c9		 test	 ecx, ecx
  00206	74 14		 je	 SHORT $LN12@BlRtlParse@2

; 299  : 
; 300  :         *TokenType = STRING_TOKEN_LONGLONG;

  00208	8b 55 0c	 mov	 edx, DWORD PTR _TokenType$[ebp]
  0020b	c6 02 04	 mov	 BYTE PTR [edx], 4

; 301  :         Index += 4;

  0020e	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  00211	83 c0 04	 add	 eax, 4
  00214	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
  00217	e9 dc 00 00 00	 jmp	 $LN17@BlRtlParse@2
$LN12@BlRtlParse@2:

; 302  : 
; 303  :     } else if (BlRtlEqualStringN(&String[Index], "I64u", 4) != FALSE) {

  0021c	6a 04		 push	 4
  0021e	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  00221	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  00224	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_04MIFEFFFI@I64u?$AA@
  00229	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  0022e	0f b6 c8	 movzx	 ecx, al
  00231	85 c9		 test	 ecx, ecx
  00233	74 14		 je	 SHORT $LN10@BlRtlParse@2

; 304  : 
; 305  :         *TokenType = STRING_TOKEN_ULONGLONG;

  00235	8b 55 0c	 mov	 edx, DWORD PTR _TokenType$[ebp]
  00238	c6 02 05	 mov	 BYTE PTR [edx], 5

; 306  :         Index += 4;

  0023b	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  0023e	83 c0 04	 add	 eax, 4
  00241	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
  00244	e9 af 00 00 00	 jmp	 $LN17@BlRtlParse@2
$LN10@BlRtlParse@2:

; 307  : 
; 308  :     } else if (BlRtlEqualStringN(&String[Index], "I64x", 4) != FALSE) {

  00249	6a 04		 push	 4
  0024b	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  0024e	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  00251	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_04HNPKCLBF@I64x?$AA@
  00256	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  0025b	0f b6 c8	 movzx	 ecx, al
  0025e	85 c9		 test	 ecx, ecx
  00260	74 14		 je	 SHORT $LN8@BlRtlParse@2

; 309  : 
; 310  :         *TokenType = STRING_TOKEN_ULONGLONG_HEX;

  00262	8b 55 0c	 mov	 edx, DWORD PTR _TokenType$[ebp]
  00265	c6 02 06	 mov	 BYTE PTR [edx], 6

; 311  :         Index += 4;

  00268	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  0026b	83 c0 04	 add	 eax, 4
  0026e	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
  00271	e9 82 00 00 00	 jmp	 $LN17@BlRtlParse@2
$LN8@BlRtlParse@2:

; 312  : 
; 313  :     } else if (BlRtlEqualStringN(&String[Index], "p", 1) != FALSE) {

  00276	6a 01		 push	 1
  00278	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  0027b	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  0027e	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01JBBJJEPG@p?$AA@
  00283	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  00288	0f b6 c8	 movzx	 ecx, al
  0028b	85 c9		 test	 ecx, ecx
  0028d	74 11		 je	 SHORT $LN6@BlRtlParse@2

; 314  : 
; 315  :         *TokenType = STRING_TOKEN_PVOID;

  0028f	8b 55 0c	 mov	 edx, DWORD PTR _TokenType$[ebp]
  00292	c6 02 07	 mov	 BYTE PTR [edx], 7

; 316  :         Index += 1;

  00295	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  00298	83 c0 01	 add	 eax, 1
  0029b	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
  0029e	eb 58		 jmp	 SHORT $LN17@BlRtlParse@2
$LN6@BlRtlParse@2:

; 317  : 
; 318  :     } else if (BlRtlEqualStringN(&String[Index], "s", 1) != FALSE) {

  002a0	6a 01		 push	 1
  002a2	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  002a5	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  002a8	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01LKDEMHDF@s?$AA@
  002ad	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  002b2	0f b6 c8	 movzx	 ecx, al
  002b5	85 c9		 test	 ecx, ecx
  002b7	74 11		 je	 SHORT $LN4@BlRtlParse@2

; 319  : 
; 320  :         *TokenType = STRING_TOKEN_PCHAR;

  002b9	8b 55 0c	 mov	 edx, DWORD PTR _TokenType$[ebp]
  002bc	c6 02 08	 mov	 BYTE PTR [edx], 8

; 321  :         Index += 1;

  002bf	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  002c2	83 c0 01	 add	 eax, 1
  002c5	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax
  002c8	eb 2e		 jmp	 SHORT $LN17@BlRtlParse@2
$LN4@BlRtlParse@2:

; 322  : 
; 323  :     } else if (BlRtlEqualStringN(&String[Index], "c", 1) != FALSE) {

  002ca	6a 01		 push	 1
  002cc	8b 4d e8	 mov	 ecx, DWORD PTR _String$[ebp]
  002cf	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  002d2	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_01PAPGNFGE@c?$AA@
  002d7	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  002dc	0f b6 c8	 movzx	 ecx, al
  002df	85 c9		 test	 ecx, ecx
  002e1	74 11		 je	 SHORT $LN2@BlRtlParse@2

; 324  : 
; 325  :         *TokenType = STRING_TOKEN_CHAR;

  002e3	8b 55 0c	 mov	 edx, DWORD PTR _TokenType$[ebp]
  002e6	c6 02 09	 mov	 BYTE PTR [edx], 9

; 326  :         Index += 1;

  002e9	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  002ec	83 c0 01	 add	 eax, 1
  002ef	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax

; 327  : 
; 328  :     } else {

  002f2	eb 04		 jmp	 SHORT $LN17@BlRtlParse@2
$LN2@BlRtlParse@2:

; 329  : 
; 330  :         return FALSE;

  002f4	32 c0		 xor	 al, al
  002f6	eb 0a		 jmp	 SHORT $LN39@BlRtlParse@2
$LN17@BlRtlParse@2:

; 331  :     }
; 332  : 
; 333  :     //
; 334  :     // Set number of characters consumed.
; 335  :     //
; 336  : 
; 337  :     *CharactersConsumed = Index;

  002f8	8b 4d 10	 mov	 ecx, DWORD PTR _CharactersConsumed$[ebp]
  002fb	8b 55 f8	 mov	 edx, DWORD PTR _Index$[ebp]
  002fe	89 11		 mov	 DWORD PTR [ecx], edx

; 338  : 
; 339  :     return TRUE;

  00300	b0 01		 mov	 al, 1
$LN39@BlRtlParse@2:

; 340  : }

  00302	8b e5		 mov	 esp, ebp
  00304	5d		 pop	 ebp
  00305	c2 0c 00	 ret	 12			; 0000000cH
?BlRtlParseTypeSpecifier@@YIEPBDPAJPADPAEPAK@Z ENDP	; BlRtlParseTypeSpecifier
_TEXT	ENDS
PUBLIC	?BlRtlFormatSignedDecimalLong@@YIEPADKJJPAK@Z	; BlRtlFormatSignedDecimalLong
; Function compile flags: /Odtp
;	COMDAT ?BlRtlFormatSignedDecimalLong@@YIEPADKJJPAK@Z
_TEXT	SEGMENT
tv89 = -44						; size = 4
tv77 = -40						; size = 4
tv68 = -36						; size = 4
_OutputSize$ = -32					; size = 4
_Output$ = -28						; size = 4
_Temp$ = -24						; size = 4
_MinimumWidth$ = -20					; size = 4
_PadWidth$ = -16					; size = 4
_NumberWidth$ = -12					; size = 4
_Index$ = -8						; size = 4
_Minus$ = -1						; size = 1
_Value$ = 8						; size = 4
_Width$ = 12						; size = 4
_CharactersConsumed$ = 16				; size = 4
?BlRtlFormatSignedDecimalLong@@YIEPADKJJPAK@Z PROC	; BlRtlFormatSignedDecimalLong, COMDAT
; _Output$ = ecx
; _OutputSize$ = edx

; 377  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 55 e0	 mov	 DWORD PTR _OutputSize$[ebp], edx
  00009	89 4d e4	 mov	 DWORD PTR _Output$[ebp], ecx

; 378  :     UINT32 Index;
; 379  :     UINT32 MinimumWidth;
; 380  :     BOOLEAN Minus;
; 381  :     UINT32 NumberWidth;
; 382  :     UINT32 PadWidth;
; 383  :     UINT32 Temp;
; 384  : 
; 385  :     //
; 386  :     // Check if this is a negative value.
; 387  :     //
; 388  : 
; 389  :     Minus = (BOOLEAN) (Value < 0);

  0000c	83 7d 08 00	 cmp	 DWORD PTR _Value$[ebp], 0
  00010	0f 9c c0	 setl	 al
  00013	88 45 ff	 mov	 BYTE PTR _Minus$[ebp], al

; 390  : 
; 391  :     //
; 392  :     // Compute the number of characters necessary.
; 393  :     //
; 394  : 
; 395  :     Temp = ABS(Value);

  00016	83 7d 08 00	 cmp	 DWORD PTR _Value$[ebp], 0
  0001a	7d 0a		 jge	 SHORT $LN18@BlRtlForma
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _Value$[ebp]
  0001f	f7 d9		 neg	 ecx
  00021	89 4d dc	 mov	 DWORD PTR tv68[ebp], ecx
  00024	eb 06		 jmp	 SHORT $LN19@BlRtlForma
$LN18@BlRtlForma:
  00026	8b 55 08	 mov	 edx, DWORD PTR _Value$[ebp]
  00029	89 55 dc	 mov	 DWORD PTR tv68[ebp], edx
$LN19@BlRtlForma:
  0002c	8b 45 dc	 mov	 eax, DWORD PTR tv68[ebp]
  0002f	89 45 e8	 mov	 DWORD PTR _Temp$[ebp], eax

; 396  :     NumberWidth = 0;

  00032	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _NumberWidth$[ebp], 0
$LN15@BlRtlForma:

; 397  : 
; 398  :     do {
; 399  : 
; 400  :         NumberWidth += 1;

  00039	8b 4d f4	 mov	 ecx, DWORD PTR _NumberWidth$[ebp]
  0003c	83 c1 01	 add	 ecx, 1
  0003f	89 4d f4	 mov	 DWORD PTR _NumberWidth$[ebp], ecx

; 401  :         Temp = Temp / 10;

  00042	8b 45 e8	 mov	 eax, DWORD PTR _Temp$[ebp]
  00045	33 d2		 xor	 edx, edx
  00047	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0004c	f7 f1		 div	 ecx
  0004e	89 45 e8	 mov	 DWORD PTR _Temp$[ebp], eax

; 402  : 
; 403  :     } while (Temp > 0);

  00051	83 7d e8 00	 cmp	 DWORD PTR _Temp$[ebp], 0
  00055	77 e2		 ja	 SHORT $LN15@BlRtlForma

; 404  : 
; 405  :     if (Minus != FALSE) {

  00057	0f b6 55 ff	 movzx	 edx, BYTE PTR _Minus$[ebp]
  0005b	85 d2		 test	 edx, edx
  0005d	74 09		 je	 SHORT $LN12@BlRtlForma

; 406  : 
; 407  :         NumberWidth += 1;

  0005f	8b 45 f4	 mov	 eax, DWORD PTR _NumberWidth$[ebp]
  00062	83 c0 01	 add	 eax, 1
  00065	89 45 f4	 mov	 DWORD PTR _NumberWidth$[ebp], eax
$LN12@BlRtlForma:

; 408  :     }
; 409  : 
; 410  :     PadWidth = 0;

  00068	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _PadWidth$[ebp], 0

; 411  :     MinimumWidth = ABS(Width);

  0006f	83 7d 0c 00	 cmp	 DWORD PTR _Width$[ebp], 0
  00073	7d 0a		 jge	 SHORT $LN20@BlRtlForma
  00075	8b 4d 0c	 mov	 ecx, DWORD PTR _Width$[ebp]
  00078	f7 d9		 neg	 ecx
  0007a	89 4d d8	 mov	 DWORD PTR tv77[ebp], ecx
  0007d	eb 06		 jmp	 SHORT $LN21@BlRtlForma
$LN20@BlRtlForma:
  0007f	8b 55 0c	 mov	 edx, DWORD PTR _Width$[ebp]
  00082	89 55 d8	 mov	 DWORD PTR tv77[ebp], edx
$LN21@BlRtlForma:
  00085	8b 45 d8	 mov	 eax, DWORD PTR tv77[ebp]
  00088	89 45 ec	 mov	 DWORD PTR _MinimumWidth$[ebp], eax

; 412  : 
; 413  :     if (MinimumWidth > NumberWidth) {

  0008b	8b 4d ec	 mov	 ecx, DWORD PTR _MinimumWidth$[ebp]
  0008e	3b 4d f4	 cmp	 ecx, DWORD PTR _NumberWidth$[ebp]
  00091	76 09		 jbe	 SHORT $LN11@BlRtlForma

; 414  : 
; 415  :         PadWidth = MinimumWidth - NumberWidth;

  00093	8b 55 ec	 mov	 edx, DWORD PTR _MinimumWidth$[ebp]
  00096	2b 55 f4	 sub	 edx, DWORD PTR _NumberWidth$[ebp]
  00099	89 55 f0	 mov	 DWORD PTR _PadWidth$[ebp], edx
$LN11@BlRtlForma:

; 416  :     }
; 417  : 
; 418  :     //
; 419  :     // Check if there is sufficient space in the output buffer.
; 420  :     //
; 421  : 
; 422  :     if ((NumberWidth + PadWidth) > OutputSize) {

  0009c	8b 45 f4	 mov	 eax, DWORD PTR _NumberWidth$[ebp]
  0009f	03 45 f0	 add	 eax, DWORD PTR _PadWidth$[ebp]
  000a2	3b 45 e0	 cmp	 eax, DWORD PTR _OutputSize$[ebp]
  000a5	76 07		 jbe	 SHORT $LN10@BlRtlForma

; 423  : 
; 424  :         return FALSE;

  000a7	32 c0		 xor	 al, al
  000a9	e9 da 00 00 00	 jmp	 $LN16@BlRtlForma
$LN10@BlRtlForma:

; 425  :     }
; 426  : 
; 427  :     Index = 0;

  000ae	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0

; 428  : 
; 429  :     //
; 430  :     // If right alignment is specified, then insert any necessary pads before the number.
; 431  :     //
; 432  : 
; 433  :     if (Width > 0) {

  000b5	83 7d 0c 00	 cmp	 DWORD PTR _Width$[ebp], 0
  000b9	7e 23		 jle	 SHORT $LN9@BlRtlForma
$LN8@BlRtlForma:

; 434  : 
; 435  :         while (PadWidth > 0) {

  000bb	83 7d f0 00	 cmp	 DWORD PTR _PadWidth$[ebp], 0
  000bf	76 1d		 jbe	 SHORT $LN9@BlRtlForma

; 436  : 
; 437  :             Output[Index] = ' ';

  000c1	8b 4d e4	 mov	 ecx, DWORD PTR _Output$[ebp]
  000c4	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  000c7	c6 01 20	 mov	 BYTE PTR [ecx], 32	; 00000020H

; 438  :             Index += 1;

  000ca	8b 55 f8	 mov	 edx, DWORD PTR _Index$[ebp]
  000cd	83 c2 01	 add	 edx, 1
  000d0	89 55 f8	 mov	 DWORD PTR _Index$[ebp], edx

; 439  :             PadWidth -= 1;

  000d3	8b 45 f0	 mov	 eax, DWORD PTR _PadWidth$[ebp]
  000d6	83 e8 01	 sub	 eax, 1
  000d9	89 45 f0	 mov	 DWORD PTR _PadWidth$[ebp], eax

; 440  :         }

  000dc	eb dd		 jmp	 SHORT $LN8@BlRtlForma
$LN9@BlRtlForma:

; 441  :     }
; 442  : 
; 443  :     //
; 444  :     // Insert absolute number starting with the least significant digit, going right to left.
; 445  :     //
; 446  : 
; 447  :     Temp = ABS(Value);

  000de	83 7d 08 00	 cmp	 DWORD PTR _Value$[ebp], 0
  000e2	7d 0a		 jge	 SHORT $LN22@BlRtlForma
  000e4	8b 4d 08	 mov	 ecx, DWORD PTR _Value$[ebp]
  000e7	f7 d9		 neg	 ecx
  000e9	89 4d d4	 mov	 DWORD PTR tv89[ebp], ecx
  000ec	eb 06		 jmp	 SHORT $LN23@BlRtlForma
$LN22@BlRtlForma:
  000ee	8b 55 08	 mov	 edx, DWORD PTR _Value$[ebp]
  000f1	89 55 d4	 mov	 DWORD PTR tv89[ebp], edx
$LN23@BlRtlForma:
  000f4	8b 45 d4	 mov	 eax, DWORD PTR tv89[ebp]
  000f7	89 45 e8	 mov	 DWORD PTR _Temp$[ebp], eax

; 448  :     Index += NumberWidth;

  000fa	8b 4d f8	 mov	 ecx, DWORD PTR _Index$[ebp]
  000fd	03 4d f4	 add	 ecx, DWORD PTR _NumberWidth$[ebp]
  00100	89 4d f8	 mov	 DWORD PTR _Index$[ebp], ecx
$LN6@BlRtlForma:

; 449  : 
; 450  :     do {
; 451  : 
; 452  :         Index -= 1;

  00103	8b 55 f8	 mov	 edx, DWORD PTR _Index$[ebp]
  00106	83 ea 01	 sub	 edx, 1
  00109	89 55 f8	 mov	 DWORD PTR _Index$[ebp], edx

; 453  :         Output[Index] = (CHAR) ('0' + (Temp % 10));

  0010c	8b 45 e8	 mov	 eax, DWORD PTR _Temp$[ebp]
  0010f	33 d2		 xor	 edx, edx
  00111	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00116	f7 f1		 div	 ecx
  00118	83 c2 30	 add	 edx, 48			; 00000030H
  0011b	8b 45 e4	 mov	 eax, DWORD PTR _Output$[ebp]
  0011e	03 45 f8	 add	 eax, DWORD PTR _Index$[ebp]
  00121	88 10		 mov	 BYTE PTR [eax], dl

; 454  :         Temp = Temp / 10;

  00123	8b 45 e8	 mov	 eax, DWORD PTR _Temp$[ebp]
  00126	33 d2		 xor	 edx, edx
  00128	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  0012d	f7 f1		 div	 ecx
  0012f	89 45 e8	 mov	 DWORD PTR _Temp$[ebp], eax

; 455  : 
; 456  :     } while (Temp > 0);

  00132	83 7d e8 00	 cmp	 DWORD PTR _Temp$[ebp], 0
  00136	77 cb		 ja	 SHORT $LN6@BlRtlForma

; 457  : 
; 458  :     //
; 459  :     // If the number is negative, then insert the negative sign.
; 460  :     //
; 461  : 
; 462  :     if (Minus != FALSE) {

  00138	0f b6 55 ff	 movzx	 edx, BYTE PTR _Minus$[ebp]
  0013c	85 d2		 test	 edx, edx
  0013e	74 12		 je	 SHORT $LN3@BlRtlForma

; 463  : 
; 464  :         Index -= 1;

  00140	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  00143	83 e8 01	 sub	 eax, 1
  00146	89 45 f8	 mov	 DWORD PTR _Index$[ebp], eax

; 465  :         Output[Index] = '-';

  00149	8b 4d e4	 mov	 ecx, DWORD PTR _Output$[ebp]
  0014c	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  0014f	c6 01 2d	 mov	 BYTE PTR [ecx], 45	; 0000002dH
$LN3@BlRtlForma:

; 466  :     }
; 467  : 
; 468  :     //
; 469  :     // If left alignment was specified, then insert any necessary pads after the number.
; 470  :     //
; 471  : 
; 472  :     Index += NumberWidth;

  00152	8b 55 f8	 mov	 edx, DWORD PTR _Index$[ebp]
  00155	03 55 f4	 add	 edx, DWORD PTR _NumberWidth$[ebp]
  00158	89 55 f8	 mov	 DWORD PTR _Index$[ebp], edx
$LN2@BlRtlForma:

; 473  : 
; 474  :     while (PadWidth > 0) {

  0015b	83 7d f0 00	 cmp	 DWORD PTR _PadWidth$[ebp], 0
  0015f	76 1d		 jbe	 SHORT $LN1@BlRtlForma

; 475  : 
; 476  :         Output[Index] = ' ';

  00161	8b 45 e4	 mov	 eax, DWORD PTR _Output$[ebp]
  00164	03 45 f8	 add	 eax, DWORD PTR _Index$[ebp]
  00167	c6 00 20	 mov	 BYTE PTR [eax], 32	; 00000020H

; 477  :         Index += 1;

  0016a	8b 4d f8	 mov	 ecx, DWORD PTR _Index$[ebp]
  0016d	83 c1 01	 add	 ecx, 1
  00170	89 4d f8	 mov	 DWORD PTR _Index$[ebp], ecx

; 478  :         PadWidth -= 1;

  00173	8b 55 f0	 mov	 edx, DWORD PTR _PadWidth$[ebp]
  00176	83 ea 01	 sub	 edx, 1
  00179	89 55 f0	 mov	 DWORD PTR _PadWidth$[ebp], edx

; 479  :     }

  0017c	eb dd		 jmp	 SHORT $LN2@BlRtlForma
$LN1@BlRtlForma:

; 480  : 
; 481  :     //
; 482  :     // Set number of characters consumed in the buffer.
; 483  :     //
; 484  : 
; 485  :     *CharactersConsumed = Index;

  0017e	8b 45 10	 mov	 eax, DWORD PTR _CharactersConsumed$[ebp]
  00181	8b 4d f8	 mov	 ecx, DWORD PTR _Index$[ebp]
  00184	89 08		 mov	 DWORD PTR [eax], ecx

; 486  : 
; 487  :     return TRUE;

  00186	b0 01		 mov	 al, 1
$LN16@BlRtlForma:

; 488  : }

  00188	8b e5		 mov	 esp, ebp
  0018a	5d		 pop	 ebp
  0018b	c2 0c 00	 ret	 12			; 0000000cH
?BlRtlFormatSignedDecimalLong@@YIEPADKJJPAK@Z ENDP	; BlRtlFormatSignedDecimalLong
_TEXT	ENDS
PUBLIC	?BlRtlFormatUnsignedLong@@YIEPADKKEJKPAK@Z	; BlRtlFormatUnsignedLong
; Function compile flags: /Odtp
;	COMDAT ?BlRtlFormatUnsignedLong@@YIEPADKKEJKPAK@Z
_TEXT	SEGMENT
tv82 = -36						; size = 4
tv70 = -32						; size = 4
_OutputSize$ = -28					; size = 4
_Output$ = -24						; size = 4
_Temp$ = -20						; size = 4
_MinimumWidth$ = -16					; size = 4
_PadWidth$ = -12					; size = 4
_NumberWidth$ = -8					; size = 4
_Index$ = -4						; size = 4
_Value$ = 8						; size = 4
_PadCharacter$ = 12					; size = 1
_Width$ = 16						; size = 4
_Base$ = 20						; size = 4
_CharactersConsumed$ = 24				; size = 4
?BlRtlFormatUnsignedLong@@YIEPADKKEJKPAK@Z PROC		; BlRtlFormatUnsignedLong, COMDAT
; _Output$ = ecx
; _OutputSize$ = edx

; 531  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 55 e4	 mov	 DWORD PTR _OutputSize$[ebp], edx
  00009	89 4d e8	 mov	 DWORD PTR _Output$[ebp], ecx

; 532  :     UINT32 Index;
; 533  :     UINT32 MinimumWidth;
; 534  :     UINT32 NumberWidth;
; 535  :     UINT32 PadWidth;
; 536  :     UINT32 Temp;
; 537  : 
; 538  :     if (Base == 0) {

  0000c	83 7d 14 00	 cmp	 DWORD PTR _Base$[ebp], 0
  00010	75 07		 jne	 SHORT $LN21@BlRtlForma@2

; 539  : 
; 540  :         return FALSE;

  00012	32 c0		 xor	 al, al
  00014	e9 64 01 00 00	 jmp	 $LN22@BlRtlForma@2
$LN21@BlRtlForma@2:

; 541  :     }
; 542  : 
; 543  :     //
; 544  :     // Compute the number of characters necessary.
; 545  :     //
; 546  : 
; 547  :     Temp = Value;

  00019	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  0001c	89 45 ec	 mov	 DWORD PTR _Temp$[ebp], eax

; 548  :     NumberWidth = 0;

  0001f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _NumberWidth$[ebp], 0
$LN20@BlRtlForma@2:

; 549  : 
; 550  :     do {
; 551  : 
; 552  :         NumberWidth += 1;

  00026	8b 4d f8	 mov	 ecx, DWORD PTR _NumberWidth$[ebp]
  00029	83 c1 01	 add	 ecx, 1
  0002c	89 4d f8	 mov	 DWORD PTR _NumberWidth$[ebp], ecx

; 553  :         Temp = Temp / Base;

  0002f	8b 45 ec	 mov	 eax, DWORD PTR _Temp$[ebp]
  00032	33 d2		 xor	 edx, edx
  00034	f7 75 14	 div	 DWORD PTR _Base$[ebp]
  00037	89 45 ec	 mov	 DWORD PTR _Temp$[ebp], eax

; 554  : 
; 555  :     } while (Temp > 0);

  0003a	83 7d ec 00	 cmp	 DWORD PTR _Temp$[ebp], 0
  0003e	77 e6		 ja	 SHORT $LN20@BlRtlForma@2

; 556  : 
; 557  :     PadWidth = 0;

  00040	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _PadWidth$[ebp], 0

; 558  :     MinimumWidth = ABS(Width);

  00047	83 7d 10 00	 cmp	 DWORD PTR _Width$[ebp], 0
  0004b	7d 0a		 jge	 SHORT $LN24@BlRtlForma@2
  0004d	8b 55 10	 mov	 edx, DWORD PTR _Width$[ebp]
  00050	f7 da		 neg	 edx
  00052	89 55 e0	 mov	 DWORD PTR tv70[ebp], edx
  00055	eb 06		 jmp	 SHORT $LN25@BlRtlForma@2
$LN24@BlRtlForma@2:
  00057	8b 45 10	 mov	 eax, DWORD PTR _Width$[ebp]
  0005a	89 45 e0	 mov	 DWORD PTR tv70[ebp], eax
$LN25@BlRtlForma@2:
  0005d	8b 4d e0	 mov	 ecx, DWORD PTR tv70[ebp]
  00060	89 4d f0	 mov	 DWORD PTR _MinimumWidth$[ebp], ecx

; 559  : 
; 560  :     if (MinimumWidth > NumberWidth) {

  00063	8b 55 f0	 mov	 edx, DWORD PTR _MinimumWidth$[ebp]
  00066	3b 55 f8	 cmp	 edx, DWORD PTR _NumberWidth$[ebp]
  00069	76 09		 jbe	 SHORT $LN17@BlRtlForma@2

; 561  : 
; 562  :         PadWidth = MinimumWidth - NumberWidth;

  0006b	8b 45 f0	 mov	 eax, DWORD PTR _MinimumWidth$[ebp]
  0006e	2b 45 f8	 sub	 eax, DWORD PTR _NumberWidth$[ebp]
  00071	89 45 f4	 mov	 DWORD PTR _PadWidth$[ebp], eax
$LN17@BlRtlForma@2:

; 563  :     }
; 564  : 
; 565  :     //
; 566  :     // Check if there is sufficient space in the output buffer.
; 567  :     //
; 568  : 
; 569  :     if ((NumberWidth + PadWidth) > OutputSize) {

  00074	8b 4d f8	 mov	 ecx, DWORD PTR _NumberWidth$[ebp]
  00077	03 4d f4	 add	 ecx, DWORD PTR _PadWidth$[ebp]
  0007a	3b 4d e4	 cmp	 ecx, DWORD PTR _OutputSize$[ebp]
  0007d	76 07		 jbe	 SHORT $LN16@BlRtlForma@2

; 570  : 
; 571  :         return FALSE;

  0007f	32 c0		 xor	 al, al
  00081	e9 f7 00 00 00	 jmp	 $LN22@BlRtlForma@2
$LN16@BlRtlForma@2:

; 572  :     }
; 573  : 
; 574  :     Index = 0;

  00086	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0

; 575  : 
; 576  :     //
; 577  :     // If right alignment is specified, then insert any necessary pads before the number.
; 578  :     //
; 579  : 
; 580  :     if (Width > 0) {

  0008d	83 7d 10 00	 cmp	 DWORD PTR _Width$[ebp], 0
  00091	7e 25		 jle	 SHORT $LN15@BlRtlForma@2
$LN14@BlRtlForma@2:

; 581  : 
; 582  :         while (PadWidth > 0) {

  00093	83 7d f4 00	 cmp	 DWORD PTR _PadWidth$[ebp], 0
  00097	76 1f		 jbe	 SHORT $LN15@BlRtlForma@2

; 583  : 
; 584  :             Output[Index] = PadCharacter;

  00099	8b 55 e8	 mov	 edx, DWORD PTR _Output$[ebp]
  0009c	03 55 fc	 add	 edx, DWORD PTR _Index$[ebp]
  0009f	8a 45 0c	 mov	 al, BYTE PTR _PadCharacter$[ebp]
  000a2	88 02		 mov	 BYTE PTR [edx], al

; 585  :             Index += 1;

  000a4	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  000a7	83 c1 01	 add	 ecx, 1
  000aa	89 4d fc	 mov	 DWORD PTR _Index$[ebp], ecx

; 586  :             PadWidth -= 1;

  000ad	8b 55 f4	 mov	 edx, DWORD PTR _PadWidth$[ebp]
  000b0	83 ea 01	 sub	 edx, 1
  000b3	89 55 f4	 mov	 DWORD PTR _PadWidth$[ebp], edx

; 587  :         }

  000b6	eb db		 jmp	 SHORT $LN14@BlRtlForma@2
$LN15@BlRtlForma@2:

; 588  :     }
; 589  : 
; 590  :     //
; 591  :     // Insert absolute number starting with the least significant digit, going right to left.
; 592  :     //
; 593  : 
; 594  :     Temp = Value;

  000b8	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  000bb	89 45 ec	 mov	 DWORD PTR _Temp$[ebp], eax

; 595  :     Index += NumberWidth;

  000be	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  000c1	03 4d f8	 add	 ecx, DWORD PTR _NumberWidth$[ebp]
  000c4	89 4d fc	 mov	 DWORD PTR _Index$[ebp], ecx
$LN12@BlRtlForma@2:

; 596  : 
; 597  :     do {
; 598  : 
; 599  :         Index -= 1;

  000c7	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  000ca	83 ea 01	 sub	 edx, 1
  000cd	89 55 fc	 mov	 DWORD PTR _Index$[ebp], edx

; 600  : 
; 601  :         switch (Base) {

  000d0	8b 45 14	 mov	 eax, DWORD PTR _Base$[ebp]
  000d3	89 45 dc	 mov	 DWORD PTR tv82[ebp], eax
  000d6	83 7d dc 0a	 cmp	 DWORD PTR tv82[ebp], 10	; 0000000aH
  000da	74 08		 je	 SHORT $LN7@BlRtlForma@2
  000dc	83 7d dc 10	 cmp	 DWORD PTR tv82[ebp], 16	; 00000010H
  000e0	74 17		 je	 SHORT $LN6@BlRtlForma@2
  000e2	eb 4c		 jmp	 SHORT $LN3@BlRtlForma@2
$LN7@BlRtlForma@2:

; 602  : 
; 603  :             case 10: {
; 604  : 
; 605  :                 Output[Index] = (CHAR) ('0' + (Temp % Base));

  000e4	8b 45 ec	 mov	 eax, DWORD PTR _Temp$[ebp]
  000e7	33 d2		 xor	 edx, edx
  000e9	f7 75 14	 div	 DWORD PTR _Base$[ebp]
  000ec	83 c2 30	 add	 edx, 48			; 00000030H
  000ef	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  000f2	03 4d fc	 add	 ecx, DWORD PTR _Index$[ebp]
  000f5	88 11		 mov	 BYTE PTR [ecx], dl

; 606  :                 break;

  000f7	eb 3b		 jmp	 SHORT $LN8@BlRtlForma@2
$LN6@BlRtlForma@2:

; 607  :             }
; 608  : 
; 609  :             case 16: {
; 610  : 
; 611  :                 if ((Temp % Base) < 10) {

  000f9	8b 45 ec	 mov	 eax, DWORD PTR _Temp$[ebp]
  000fc	33 d2		 xor	 edx, edx
  000fe	f7 75 14	 div	 DWORD PTR _Base$[ebp]
  00101	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00104	73 15		 jae	 SHORT $LN5@BlRtlForma@2

; 612  : 
; 613  :                     Output[Index] = (CHAR) ('0' + (Temp % Base));

  00106	8b 45 ec	 mov	 eax, DWORD PTR _Temp$[ebp]
  00109	33 d2		 xor	 edx, edx
  0010b	f7 75 14	 div	 DWORD PTR _Base$[ebp]
  0010e	83 c2 30	 add	 edx, 48			; 00000030H
  00111	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  00114	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  00117	88 10		 mov	 BYTE PTR [eax], dl

; 614  : 
; 615  :                 } else {

  00119	eb 13		 jmp	 SHORT $LN4@BlRtlForma@2
$LN5@BlRtlForma@2:

; 616  : 
; 617  :                     Output[Index] = (CHAR) ('A' + (Temp % Base) - 10);

  0011b	8b 45 ec	 mov	 eax, DWORD PTR _Temp$[ebp]
  0011e	33 d2		 xor	 edx, edx
  00120	f7 75 14	 div	 DWORD PTR _Base$[ebp]
  00123	83 c2 37	 add	 edx, 55			; 00000037H
  00126	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  00129	03 4d fc	 add	 ecx, DWORD PTR _Index$[ebp]
  0012c	88 11		 mov	 BYTE PTR [ecx], dl
$LN4@BlRtlForma@2:

; 618  :                 }
; 619  : 
; 620  :                 break;

  0012e	eb 04		 jmp	 SHORT $LN8@BlRtlForma@2
$LN3@BlRtlForma@2:

; 621  :             }
; 622  : 
; 623  :             default: {
; 624  : 
; 625  :                 return FALSE;

  00130	32 c0		 xor	 al, al
  00132	eb 49		 jmp	 SHORT $LN22@BlRtlForma@2
$LN8@BlRtlForma@2:

; 626  :             }
; 627  :         }
; 628  : 
; 629  :         Temp = Temp / Base;

  00134	8b 45 ec	 mov	 eax, DWORD PTR _Temp$[ebp]
  00137	33 d2		 xor	 edx, edx
  00139	f7 75 14	 div	 DWORD PTR _Base$[ebp]
  0013c	89 45 ec	 mov	 DWORD PTR _Temp$[ebp], eax

; 630  : 
; 631  :     } while (Temp > 0);

  0013f	83 7d ec 00	 cmp	 DWORD PTR _Temp$[ebp], 0
  00143	77 82		 ja	 SHORT $LN12@BlRtlForma@2

; 632  : 
; 633  :     //
; 634  :     // If left alignment was specified, then insert any necessary pads after the number.
; 635  :     //
; 636  : 
; 637  :     Index += NumberWidth;

  00145	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  00148	03 55 f8	 add	 edx, DWORD PTR _NumberWidth$[ebp]
  0014b	89 55 fc	 mov	 DWORD PTR _Index$[ebp], edx
$LN2@BlRtlForma@2:

; 638  : 
; 639  :     while (PadWidth > 0) {

  0014e	83 7d f4 00	 cmp	 DWORD PTR _PadWidth$[ebp], 0
  00152	76 1f		 jbe	 SHORT $LN1@BlRtlForma@2

; 640  : 
; 641  :         Output[Index] = PadCharacter;

  00154	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  00157	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  0015a	8a 4d 0c	 mov	 cl, BYTE PTR _PadCharacter$[ebp]
  0015d	88 08		 mov	 BYTE PTR [eax], cl

; 642  :         Index += 1;

  0015f	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  00162	83 c2 01	 add	 edx, 1
  00165	89 55 fc	 mov	 DWORD PTR _Index$[ebp], edx

; 643  :         PadWidth -= 1;

  00168	8b 45 f4	 mov	 eax, DWORD PTR _PadWidth$[ebp]
  0016b	83 e8 01	 sub	 eax, 1
  0016e	89 45 f4	 mov	 DWORD PTR _PadWidth$[ebp], eax

; 644  :     }

  00171	eb db		 jmp	 SHORT $LN2@BlRtlForma@2
$LN1@BlRtlForma@2:

; 645  : 
; 646  :     //
; 647  :     // Set number of characters consumed in the buffer.
; 648  :     //
; 649  : 
; 650  :     *CharactersConsumed = Index;

  00173	8b 4d 18	 mov	 ecx, DWORD PTR _CharactersConsumed$[ebp]
  00176	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  00179	89 11		 mov	 DWORD PTR [ecx], edx

; 651  : 
; 652  :     return TRUE;

  0017b	b0 01		 mov	 al, 1
$LN22@BlRtlForma@2:

; 653  : }

  0017d	8b e5		 mov	 esp, ebp
  0017f	5d		 pop	 ebp
  00180	c2 14 00	 ret	 20			; 00000014H
?BlRtlFormatUnsignedLong@@YIEPADKKEJKPAK@Z ENDP		; BlRtlFormatUnsignedLong
_TEXT	ENDS
PUBLIC	?BlRtlFormatUnsignedLongLong@@YIEPADK_KEJKPAK@Z	; BlRtlFormatUnsignedLongLong
EXTRN	__aullrem:PROC
EXTRN	__aulldiv:PROC
; Function compile flags: /Odtp
;	COMDAT ?BlRtlFormatUnsignedLongLong@@YIEPADK_KEJKPAK@Z
_TEXT	SEGMENT
tv217 = -48						; size = 8
tv83 = -40						; size = 4
tv71 = -36						; size = 4
_OutputSize$ = -32					; size = 4
_Output$ = -28						; size = 4
_Temp$ = -24						; size = 8
_MinimumWidth$ = -16					; size = 4
_PadWidth$ = -12					; size = 4
_NumberWidth$ = -8					; size = 4
_Index$ = -4						; size = 4
_Value$ = 8						; size = 8
_PadCharacter$ = 16					; size = 1
_Width$ = 20						; size = 4
_Base$ = 24						; size = 4
_CharactersConsumed$ = 28				; size = 4
?BlRtlFormatUnsignedLongLong@@YIEPADK_KEJKPAK@Z PROC	; BlRtlFormatUnsignedLongLong, COMDAT
; _Output$ = ecx
; _OutputSize$ = edx

; 696  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 55 e0	 mov	 DWORD PTR _OutputSize$[ebp], edx
  00009	89 4d e4	 mov	 DWORD PTR _Output$[ebp], ecx

; 697  :     UINT32 Index;
; 698  :     UINT32 MinimumWidth;
; 699  :     UINT32 NumberWidth;
; 700  :     UINT32 PadWidth;
; 701  :     UINT64 Temp;
; 702  : 
; 703  :     if (Base == 0) {

  0000c	83 7d 18 00	 cmp	 DWORD PTR _Base$[ebp], 0
  00010	75 07		 jne	 SHORT $LN21@BlRtlForma@3

; 704  : 
; 705  :         return FALSE;

  00012	32 c0		 xor	 al, al
  00014	e9 f7 01 00 00	 jmp	 $LN22@BlRtlForma@3
$LN21@BlRtlForma@3:

; 706  :     }
; 707  : 
; 708  :     //
; 709  :     // Compute the number of characters necessary.
; 710  :     //
; 711  : 
; 712  :     Temp = Value;

  00019	8b 45 08	 mov	 eax, DWORD PTR _Value$[ebp]
  0001c	89 45 e8	 mov	 DWORD PTR _Temp$[ebp], eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _Value$[ebp+4]
  00022	89 4d ec	 mov	 DWORD PTR _Temp$[ebp+4], ecx

; 713  :     NumberWidth = 0;

  00025	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _NumberWidth$[ebp], 0
$LN20@BlRtlForma@3:

; 714  : 
; 715  :     do {
; 716  : 
; 717  :         NumberWidth += 1;

  0002c	8b 55 f8	 mov	 edx, DWORD PTR _NumberWidth$[ebp]
  0002f	83 c2 01	 add	 edx, 1
  00032	89 55 f8	 mov	 DWORD PTR _NumberWidth$[ebp], edx

; 718  :         Temp = Temp / Base;

  00035	8b 45 18	 mov	 eax, DWORD PTR _Base$[ebp]
  00038	33 c9		 xor	 ecx, ecx
  0003a	51		 push	 ecx
  0003b	50		 push	 eax
  0003c	8b 55 ec	 mov	 edx, DWORD PTR _Temp$[ebp+4]
  0003f	52		 push	 edx
  00040	8b 45 e8	 mov	 eax, DWORD PTR _Temp$[ebp]
  00043	50		 push	 eax
  00044	e8 00 00 00 00	 call	 __aulldiv
  00049	89 45 e8	 mov	 DWORD PTR _Temp$[ebp], eax
  0004c	89 55 ec	 mov	 DWORD PTR _Temp$[ebp+4], edx

; 719  : 
; 720  :     } while (Temp > 0);

  0004f	83 7d ec 00	 cmp	 DWORD PTR _Temp$[ebp+4], 0
  00053	77 d7		 ja	 SHORT $LN20@BlRtlForma@3
  00055	72 06		 jb	 SHORT $LN18@BlRtlForma@3
  00057	83 7d e8 00	 cmp	 DWORD PTR _Temp$[ebp], 0
  0005b	77 cf		 ja	 SHORT $LN20@BlRtlForma@3
$LN18@BlRtlForma@3:

; 721  : 
; 722  :     PadWidth = 0;

  0005d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _PadWidth$[ebp], 0

; 723  :     MinimumWidth = ABS(Width);

  00064	83 7d 14 00	 cmp	 DWORD PTR _Width$[ebp], 0
  00068	7d 0a		 jge	 SHORT $LN24@BlRtlForma@3
  0006a	8b 4d 14	 mov	 ecx, DWORD PTR _Width$[ebp]
  0006d	f7 d9		 neg	 ecx
  0006f	89 4d dc	 mov	 DWORD PTR tv71[ebp], ecx
  00072	eb 06		 jmp	 SHORT $LN25@BlRtlForma@3
$LN24@BlRtlForma@3:
  00074	8b 55 14	 mov	 edx, DWORD PTR _Width$[ebp]
  00077	89 55 dc	 mov	 DWORD PTR tv71[ebp], edx
$LN25@BlRtlForma@3:
  0007a	8b 45 dc	 mov	 eax, DWORD PTR tv71[ebp]
  0007d	89 45 f0	 mov	 DWORD PTR _MinimumWidth$[ebp], eax

; 724  : 
; 725  :     if (MinimumWidth > NumberWidth) {

  00080	8b 4d f0	 mov	 ecx, DWORD PTR _MinimumWidth$[ebp]
  00083	3b 4d f8	 cmp	 ecx, DWORD PTR _NumberWidth$[ebp]
  00086	76 09		 jbe	 SHORT $LN17@BlRtlForma@3

; 726  : 
; 727  :         PadWidth = MinimumWidth - NumberWidth;

  00088	8b 55 f0	 mov	 edx, DWORD PTR _MinimumWidth$[ebp]
  0008b	2b 55 f8	 sub	 edx, DWORD PTR _NumberWidth$[ebp]
  0008e	89 55 f4	 mov	 DWORD PTR _PadWidth$[ebp], edx
$LN17@BlRtlForma@3:

; 728  :     }
; 729  : 
; 730  :     //
; 731  :     // Check if there is sufficient space in the output buffer.
; 732  :     //
; 733  : 
; 734  :     if ((NumberWidth + PadWidth) > OutputSize) {

  00091	8b 45 f8	 mov	 eax, DWORD PTR _NumberWidth$[ebp]
  00094	03 45 f4	 add	 eax, DWORD PTR _PadWidth$[ebp]
  00097	3b 45 e0	 cmp	 eax, DWORD PTR _OutputSize$[ebp]
  0009a	76 07		 jbe	 SHORT $LN16@BlRtlForma@3

; 735  : 
; 736  :         return FALSE;

  0009c	32 c0		 xor	 al, al
  0009e	e9 6d 01 00 00	 jmp	 $LN22@BlRtlForma@3
$LN16@BlRtlForma@3:

; 737  :     }
; 738  : 
; 739  :     Index = 0;

  000a3	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0

; 740  : 
; 741  :     //
; 742  :     // If right alignment is specified, then insert any necessary pads before the number.
; 743  :     //
; 744  : 
; 745  :     if (Width > 0) {

  000aa	83 7d 14 00	 cmp	 DWORD PTR _Width$[ebp], 0
  000ae	7e 25		 jle	 SHORT $LN15@BlRtlForma@3
$LN14@BlRtlForma@3:

; 746  : 
; 747  :         while (PadWidth > 0) {

  000b0	83 7d f4 00	 cmp	 DWORD PTR _PadWidth$[ebp], 0
  000b4	76 1f		 jbe	 SHORT $LN15@BlRtlForma@3

; 748  : 
; 749  :             Output[Index] = PadCharacter;

  000b6	8b 4d e4	 mov	 ecx, DWORD PTR _Output$[ebp]
  000b9	03 4d fc	 add	 ecx, DWORD PTR _Index$[ebp]
  000bc	8a 55 10	 mov	 dl, BYTE PTR _PadCharacter$[ebp]
  000bf	88 11		 mov	 BYTE PTR [ecx], dl

; 750  :             Index += 1;

  000c1	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  000c4	83 c0 01	 add	 eax, 1
  000c7	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax

; 751  :             PadWidth -= 1;

  000ca	8b 4d f4	 mov	 ecx, DWORD PTR _PadWidth$[ebp]
  000cd	83 e9 01	 sub	 ecx, 1
  000d0	89 4d f4	 mov	 DWORD PTR _PadWidth$[ebp], ecx

; 752  :         }

  000d3	eb db		 jmp	 SHORT $LN14@BlRtlForma@3
$LN15@BlRtlForma@3:

; 753  :     }
; 754  : 
; 755  :     //
; 756  :     // Insert absolute number starting with the least significant digit, going right to left.
; 757  :     //
; 758  : 
; 759  :     Temp = Value;

  000d5	8b 55 08	 mov	 edx, DWORD PTR _Value$[ebp]
  000d8	89 55 e8	 mov	 DWORD PTR _Temp$[ebp], edx
  000db	8b 45 0c	 mov	 eax, DWORD PTR _Value$[ebp+4]
  000de	89 45 ec	 mov	 DWORD PTR _Temp$[ebp+4], eax

; 760  :     Index += NumberWidth;

  000e1	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  000e4	03 4d f8	 add	 ecx, DWORD PTR _NumberWidth$[ebp]
  000e7	89 4d fc	 mov	 DWORD PTR _Index$[ebp], ecx
$LN12@BlRtlForma@3:

; 761  : 
; 762  :     do {
; 763  : 
; 764  :         Index -= 1;

  000ea	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  000ed	83 ea 01	 sub	 edx, 1
  000f0	89 55 fc	 mov	 DWORD PTR _Index$[ebp], edx

; 765  : 
; 766  :         switch (Base) {

  000f3	8b 45 18	 mov	 eax, DWORD PTR _Base$[ebp]
  000f6	89 45 d8	 mov	 DWORD PTR tv83[ebp], eax
  000f9	83 7d d8 0a	 cmp	 DWORD PTR tv83[ebp], 10	; 0000000aH
  000fd	74 0b		 je	 SHORT $LN7@BlRtlForma@3
  000ff	83 7d d8 10	 cmp	 DWORD PTR tv83[ebp], 16	; 00000010H
  00103	74 29		 je	 SHORT $LN6@BlRtlForma@3
  00105	e9 9a 00 00 00	 jmp	 $LN3@BlRtlForma@3
$LN7@BlRtlForma@3:

; 767  : 
; 768  :             case 10: {
; 769  : 
; 770  :                 Output[Index] = (CHAR) ('0' + (Temp % Base));

  0010a	8b 4d 18	 mov	 ecx, DWORD PTR _Base$[ebp]
  0010d	33 d2		 xor	 edx, edx
  0010f	52		 push	 edx
  00110	51		 push	 ecx
  00111	8b 45 ec	 mov	 eax, DWORD PTR _Temp$[ebp+4]
  00114	50		 push	 eax
  00115	8b 4d e8	 mov	 ecx, DWORD PTR _Temp$[ebp]
  00118	51		 push	 ecx
  00119	e8 00 00 00 00	 call	 __aullrem
  0011e	83 c0 30	 add	 eax, 48			; 00000030H
  00121	83 d2 00	 adc	 edx, 0
  00124	8b 55 e4	 mov	 edx, DWORD PTR _Output$[ebp]
  00127	03 55 fc	 add	 edx, DWORD PTR _Index$[ebp]
  0012a	88 02		 mov	 BYTE PTR [edx], al

; 771  :                 break;

  0012c	eb 7a		 jmp	 SHORT $LN8@BlRtlForma@3
$LN6@BlRtlForma@3:

; 772  :             }
; 773  : 
; 774  :             case 16: {
; 775  : 
; 776  :                 if ((Temp % Base) < 10) {

  0012e	8b 45 18	 mov	 eax, DWORD PTR _Base$[ebp]
  00131	33 c9		 xor	 ecx, ecx
  00133	51		 push	 ecx
  00134	50		 push	 eax
  00135	8b 55 ec	 mov	 edx, DWORD PTR _Temp$[ebp+4]
  00138	52		 push	 edx
  00139	8b 45 e8	 mov	 eax, DWORD PTR _Temp$[ebp]
  0013c	50		 push	 eax
  0013d	e8 00 00 00 00	 call	 __aullrem
  00142	89 45 d0	 mov	 DWORD PTR tv217[ebp], eax
  00145	89 55 d4	 mov	 DWORD PTR tv217[ebp+4], edx
  00148	83 7d d4 00	 cmp	 DWORD PTR tv217[ebp+4], 0
  0014c	77 2c		 ja	 SHORT $LN5@BlRtlForma@3
  0014e	72 06		 jb	 SHORT $LN27@BlRtlForma@3
  00150	83 7d d0 0a	 cmp	 DWORD PTR tv217[ebp], 10 ; 0000000aH
  00154	73 24		 jae	 SHORT $LN5@BlRtlForma@3
$LN27@BlRtlForma@3:

; 777  : 
; 778  :                     Output[Index] = (CHAR) ('0' + (Temp % Base));

  00156	8b 4d 18	 mov	 ecx, DWORD PTR _Base$[ebp]
  00159	33 d2		 xor	 edx, edx
  0015b	52		 push	 edx
  0015c	51		 push	 ecx
  0015d	8b 45 ec	 mov	 eax, DWORD PTR _Temp$[ebp+4]
  00160	50		 push	 eax
  00161	8b 4d e8	 mov	 ecx, DWORD PTR _Temp$[ebp]
  00164	51		 push	 ecx
  00165	e8 00 00 00 00	 call	 __aullrem
  0016a	83 c0 30	 add	 eax, 48			; 00000030H
  0016d	83 d2 00	 adc	 edx, 0
  00170	8b 55 e4	 mov	 edx, DWORD PTR _Output$[ebp]
  00173	03 55 fc	 add	 edx, DWORD PTR _Index$[ebp]
  00176	88 02		 mov	 BYTE PTR [edx], al

; 779  : 
; 780  :                 } else {

  00178	eb 28		 jmp	 SHORT $LN4@BlRtlForma@3
$LN5@BlRtlForma@3:

; 781  : 
; 782  :                     Output[Index] = (CHAR) ('A' + (Temp % Base) - 10);

  0017a	8b 45 18	 mov	 eax, DWORD PTR _Base$[ebp]
  0017d	33 c9		 xor	 ecx, ecx
  0017f	51		 push	 ecx
  00180	50		 push	 eax
  00181	8b 55 ec	 mov	 edx, DWORD PTR _Temp$[ebp+4]
  00184	52		 push	 edx
  00185	8b 45 e8	 mov	 eax, DWORD PTR _Temp$[ebp]
  00188	50		 push	 eax
  00189	e8 00 00 00 00	 call	 __aullrem
  0018e	83 c0 41	 add	 eax, 65			; 00000041H
  00191	83 d2 00	 adc	 edx, 0
  00194	83 e8 0a	 sub	 eax, 10			; 0000000aH
  00197	83 da 00	 sbb	 edx, 0
  0019a	8b 4d e4	 mov	 ecx, DWORD PTR _Output$[ebp]
  0019d	03 4d fc	 add	 ecx, DWORD PTR _Index$[ebp]
  001a0	88 01		 mov	 BYTE PTR [ecx], al
$LN4@BlRtlForma@3:

; 783  :                 }
; 784  : 
; 785  :                 break;

  001a2	eb 04		 jmp	 SHORT $LN8@BlRtlForma@3
$LN3@BlRtlForma@3:

; 786  :             }
; 787  : 
; 788  :             default: {
; 789  : 
; 790  :                 return FALSE;

  001a4	32 c0		 xor	 al, al
  001a6	eb 68		 jmp	 SHORT $LN22@BlRtlForma@3
$LN8@BlRtlForma@3:

; 791  :             }
; 792  :         }
; 793  : 
; 794  :         Temp = Temp / Base;

  001a8	8b 55 18	 mov	 edx, DWORD PTR _Base$[ebp]
  001ab	33 c0		 xor	 eax, eax
  001ad	50		 push	 eax
  001ae	52		 push	 edx
  001af	8b 4d ec	 mov	 ecx, DWORD PTR _Temp$[ebp+4]
  001b2	51		 push	 ecx
  001b3	8b 55 e8	 mov	 edx, DWORD PTR _Temp$[ebp]
  001b6	52		 push	 edx
  001b7	e8 00 00 00 00	 call	 __aulldiv
  001bc	89 45 e8	 mov	 DWORD PTR _Temp$[ebp], eax
  001bf	89 55 ec	 mov	 DWORD PTR _Temp$[ebp+4], edx

; 795  : 
; 796  :     } while (Temp > 0);

  001c2	83 7d ec 00	 cmp	 DWORD PTR _Temp$[ebp+4], 0
  001c6	0f 87 1e ff ff
	ff		 ja	 $LN12@BlRtlForma@3
  001cc	72 0a		 jb	 SHORT $LN10@BlRtlForma@3
  001ce	83 7d e8 00	 cmp	 DWORD PTR _Temp$[ebp], 0
  001d2	0f 87 12 ff ff
	ff		 ja	 $LN12@BlRtlForma@3
$LN10@BlRtlForma@3:

; 797  : 
; 798  :     //
; 799  :     // If left alignment was specified, then insert any necessary pads after the number.
; 800  :     //
; 801  : 
; 802  :     Index += NumberWidth;

  001d8	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  001db	03 45 f8	 add	 eax, DWORD PTR _NumberWidth$[ebp]
  001de	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax
$LN2@BlRtlForma@3:

; 803  : 
; 804  :     while (PadWidth > 0) {

  001e1	83 7d f4 00	 cmp	 DWORD PTR _PadWidth$[ebp], 0
  001e5	76 1f		 jbe	 SHORT $LN1@BlRtlForma@3

; 805  : 
; 806  :         Output[Index] = PadCharacter;

  001e7	8b 4d e4	 mov	 ecx, DWORD PTR _Output$[ebp]
  001ea	03 4d fc	 add	 ecx, DWORD PTR _Index$[ebp]
  001ed	8a 55 10	 mov	 dl, BYTE PTR _PadCharacter$[ebp]
  001f0	88 11		 mov	 BYTE PTR [ecx], dl

; 807  :         Index += 1;

  001f2	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  001f5	83 c0 01	 add	 eax, 1
  001f8	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax

; 808  :         PadWidth -= 1;

  001fb	8b 4d f4	 mov	 ecx, DWORD PTR _PadWidth$[ebp]
  001fe	83 e9 01	 sub	 ecx, 1
  00201	89 4d f4	 mov	 DWORD PTR _PadWidth$[ebp], ecx

; 809  :     }

  00204	eb db		 jmp	 SHORT $LN2@BlRtlForma@3
$LN1@BlRtlForma@3:

; 810  : 
; 811  :     //
; 812  :     // Set number of characters consumed in the buffer.
; 813  :     //
; 814  : 
; 815  :     *CharactersConsumed = Index;

  00206	8b 55 1c	 mov	 edx, DWORD PTR _CharactersConsumed$[ebp]
  00209	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  0020c	89 02		 mov	 DWORD PTR [edx], eax

; 816  : 
; 817  :     return TRUE;

  0020e	b0 01		 mov	 al, 1
$LN22@BlRtlForma@3:

; 818  : }

  00210	8b e5		 mov	 esp, ebp
  00212	5d		 pop	 ebp
  00213	c2 18 00	 ret	 24			; 00000018H
?BlRtlFormatUnsignedLongLong@@YIEPADK_KEJKPAK@Z ENDP	; BlRtlFormatUnsignedLongLong
_TEXT	ENDS
PUBLIC	?BlRtlStringLength@@YIKPBD@Z			; BlRtlStringLength
; Function compile flags: /Odtp
;	COMDAT ?BlRtlStringLength@@YIKPBD@Z
_TEXT	SEGMENT
_String$ = -8						; size = 4
_Index$ = -4						; size = 4
?BlRtlStringLength@@YIKPBD@Z PROC			; BlRtlStringLength, COMDAT
; _String$ = ecx

; 841  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _String$[ebp], ecx

; 842  :     UINT32 Index;
; 843  : 
; 844  :     Index = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0
$LN2@BlRtlStrin:

; 845  : 
; 846  :     while (String[Index] != 0) {

  00010	8b 45 f8	 mov	 eax, DWORD PTR _String$[ebp]
  00013	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  00016	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00019	85 c9		 test	 ecx, ecx
  0001b	74 0b		 je	 SHORT $LN1@BlRtlStrin

; 847  : 
; 848  :         Index += 1;

  0001d	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  00020	83 c2 01	 add	 edx, 1
  00023	89 55 fc	 mov	 DWORD PTR _Index$[ebp], edx

; 849  :     }

  00026	eb e8		 jmp	 SHORT $LN2@BlRtlStrin
$LN1@BlRtlStrin:

; 850  : 
; 851  :     return Index;

  00028	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]

; 852  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?BlRtlStringLength@@YIKPBD@Z ENDP			; BlRtlStringLength
_TEXT	ENDS
PUBLIC	?BlRtlStringLengthW@@YIKPB_W@Z			; BlRtlStringLengthW
; Function compile flags: /Odtp
;	COMDAT ?BlRtlStringLengthW@@YIKPB_W@Z
_TEXT	SEGMENT
_String$ = -8						; size = 4
_Index$ = -4						; size = 4
?BlRtlStringLengthW@@YIKPB_W@Z PROC			; BlRtlStringLengthW, COMDAT
; _String$ = ecx

; 875  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _String$[ebp], ecx

; 876  :     UINT32 Index;
; 877  : 
; 878  :     Index = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0
$LN2@BlRtlStrin@2:

; 879  : 
; 880  :     while (String[Index] != 0) {

  00010	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00013	8b 4d f8	 mov	 ecx, DWORD PTR _String$[ebp]
  00016	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0001a	85 d2		 test	 edx, edx
  0001c	74 0b		 je	 SHORT $LN1@BlRtlStrin@2

; 881  : 
; 882  :         Index += 1;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]
  00021	83 c0 01	 add	 eax, 1
  00024	89 45 fc	 mov	 DWORD PTR _Index$[ebp], eax

; 883  :     }

  00027	eb e7		 jmp	 SHORT $LN2@BlRtlStrin@2
$LN1@BlRtlStrin@2:

; 884  : 
; 885  :     return Index;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _Index$[ebp]

; 886  : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?BlRtlStringLengthW@@YIKPB_W@Z ENDP			; BlRtlStringLengthW
_TEXT	ENDS
PUBLIC	?BlRtlFormatStringToken@@YIEPADKPBDJPAK@Z	; BlRtlFormatStringToken
; Function compile flags: /Odtp
;	COMDAT ?BlRtlFormatStringToken@@YIEPADKPBDJPAK@Z
_TEXT	SEGMENT
tv68 = -32						; size = 4
_OutputSize$ = -28					; size = 4
_Output$ = -24						; size = 4
_StringIndex$ = -20					; size = 4
_MinimumWidth$ = -16					; size = 4
_PadWidth$ = -12					; size = 4
_StringLength$ = -8					; size = 4
_Index$ = -4						; size = 4
_String$ = 8						; size = 4
_Width$ = 12						; size = 4
_CharactersConsumed$ = 16				; size = 4
?BlRtlFormatStringToken@@YIEPADKPBDJPAK@Z PROC		; BlRtlFormatStringToken, COMDAT
; _Output$ = ecx
; _OutputSize$ = edx

; 923  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 55 e4	 mov	 DWORD PTR _OutputSize$[ebp], edx
  00009	89 4d e8	 mov	 DWORD PTR _Output$[ebp], ecx

; 924  :     UINT32 Index;
; 925  :     UINT32 MinimumWidth;
; 926  :     UINT32 PadWidth;
; 927  :     UINT32 StringIndex;
; 928  :     UINT32 StringLength;
; 929  : 
; 930  :     //
; 931  :     // Compute string length, minimum width, and pad width.
; 932  :     //
; 933  : 
; 934  :     StringLength = BlRtlStringLength(String);

  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _String$[ebp]
  0000f	e8 00 00 00 00	 call	 ?BlRtlStringLength@@YIKPBD@Z ; BlRtlStringLength
  00014	89 45 f8	 mov	 DWORD PTR _StringLength$[ebp], eax

; 935  : 
; 936  :     MinimumWidth = ABS(Width);

  00017	83 7d 0c 00	 cmp	 DWORD PTR _Width$[ebp], 0
  0001b	7d 0a		 jge	 SHORT $LN13@BlRtlForma@4
  0001d	8b 45 0c	 mov	 eax, DWORD PTR _Width$[ebp]
  00020	f7 d8		 neg	 eax
  00022	89 45 e0	 mov	 DWORD PTR tv68[ebp], eax
  00025	eb 06		 jmp	 SHORT $LN14@BlRtlForma@4
$LN13@BlRtlForma@4:
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _Width$[ebp]
  0002a	89 4d e0	 mov	 DWORD PTR tv68[ebp], ecx
$LN14@BlRtlForma@4:
  0002d	8b 55 e0	 mov	 edx, DWORD PTR tv68[ebp]
  00030	89 55 f0	 mov	 DWORD PTR _MinimumWidth$[ebp], edx

; 937  : 
; 938  :     PadWidth = 0;

  00033	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _PadWidth$[ebp], 0

; 939  : 
; 940  :     if (MinimumWidth > StringLength) {

  0003a	8b 45 f0	 mov	 eax, DWORD PTR _MinimumWidth$[ebp]
  0003d	3b 45 f8	 cmp	 eax, DWORD PTR _StringLength$[ebp]
  00040	76 09		 jbe	 SHORT $LN10@BlRtlForma@4

; 941  : 
; 942  :         PadWidth = MinimumWidth - StringLength;

  00042	8b 4d f0	 mov	 ecx, DWORD PTR _MinimumWidth$[ebp]
  00045	2b 4d f8	 sub	 ecx, DWORD PTR _StringLength$[ebp]
  00048	89 4d f4	 mov	 DWORD PTR _PadWidth$[ebp], ecx
$LN10@BlRtlForma@4:

; 943  :     }
; 944  : 
; 945  :     //
; 946  :     // Check if there is sufficient space in the output buffer.
; 947  :     //
; 948  : 
; 949  :     if ((StringLength + PadWidth) > OutputSize) {

  0004b	8b 55 f8	 mov	 edx, DWORD PTR _StringLength$[ebp]
  0004e	03 55 f4	 add	 edx, DWORD PTR _PadWidth$[ebp]
  00051	3b 55 e4	 cmp	 edx, DWORD PTR _OutputSize$[ebp]
  00054	76 07		 jbe	 SHORT $LN9@BlRtlForma@4

; 950  : 
; 951  :         return FALSE;

  00056	32 c0		 xor	 al, al
  00058	e9 92 00 00 00	 jmp	 $LN11@BlRtlForma@4
$LN9@BlRtlForma@4:

; 952  :     }
; 953  : 
; 954  :     Index = 0;

  0005d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0

; 955  : 
; 956  :     //
; 957  :     // If right alignment is specified, then insert any necessary pads before the string.
; 958  :     //
; 959  : 
; 960  :     if (Width > 0) {

  00064	83 7d 0c 00	 cmp	 DWORD PTR _Width$[ebp], 0
  00068	7e 23		 jle	 SHORT $LN8@BlRtlForma@4
$LN7@BlRtlForma@4:

; 961  : 
; 962  :         while (PadWidth > 0) {

  0006a	83 7d f4 00	 cmp	 DWORD PTR _PadWidth$[ebp], 0
  0006e	76 1d		 jbe	 SHORT $LN8@BlRtlForma@4

; 963  : 
; 964  :             Output[Index] = ' ';

  00070	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  00073	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  00076	c6 00 20	 mov	 BYTE PTR [eax], 32	; 00000020H

; 965  :             Index += 1;

  00079	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  0007c	83 c1 01	 add	 ecx, 1
  0007f	89 4d fc	 mov	 DWORD PTR _Index$[ebp], ecx

; 966  :             PadWidth -= 1;

  00082	8b 55 f4	 mov	 edx, DWORD PTR _PadWidth$[ebp]
  00085	83 ea 01	 sub	 edx, 1
  00088	89 55 f4	 mov	 DWORD PTR _PadWidth$[ebp], edx

; 967  :         }

  0008b	eb dd		 jmp	 SHORT $LN7@BlRtlForma@4
$LN8@BlRtlForma@4:

; 968  :     }
; 969  : 
; 970  :     //
; 971  :     // Copy the string.
; 972  :     //
; 973  : 
; 974  :     for (StringIndex = 0; StringIndex < StringLength; StringIndex += 1) {

  0008d	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _StringIndex$[ebp], 0
  00094	eb 09		 jmp	 SHORT $LN5@BlRtlForma@4
$LN4@BlRtlForma@4:
  00096	8b 45 ec	 mov	 eax, DWORD PTR _StringIndex$[ebp]
  00099	83 c0 01	 add	 eax, 1
  0009c	89 45 ec	 mov	 DWORD PTR _StringIndex$[ebp], eax
$LN5@BlRtlForma@4:
  0009f	8b 4d ec	 mov	 ecx, DWORD PTR _StringIndex$[ebp]
  000a2	3b 4d f8	 cmp	 ecx, DWORD PTR _StringLength$[ebp]
  000a5	73 1b		 jae	 SHORT $LN2@BlRtlForma@4

; 975  : 
; 976  :         Output[Index] = String[StringIndex];

  000a7	8b 55 e8	 mov	 edx, DWORD PTR _Output$[ebp]
  000aa	03 55 fc	 add	 edx, DWORD PTR _Index$[ebp]
  000ad	8b 45 08	 mov	 eax, DWORD PTR _String$[ebp]
  000b0	03 45 ec	 add	 eax, DWORD PTR _StringIndex$[ebp]
  000b3	8a 08		 mov	 cl, BYTE PTR [eax]
  000b5	88 0a		 mov	 BYTE PTR [edx], cl

; 977  :         Index += 1;

  000b7	8b 55 fc	 mov	 edx, DWORD PTR _Index$[ebp]
  000ba	83 c2 01	 add	 edx, 1
  000bd	89 55 fc	 mov	 DWORD PTR _Index$[ebp], edx

; 978  :     }

  000c0	eb d4		 jmp	 SHORT $LN4@BlRtlForma@4
$LN2@BlRtlForma@4:

; 979  : 
; 980  :     //
; 981  :     // If left alignment was specified, then insert any necessary pads after the string.
; 982  :     //
; 983  : 
; 984  :     while (PadWidth > 0) {

  000c2	83 7d f4 00	 cmp	 DWORD PTR _PadWidth$[ebp], 0
  000c6	76 1d		 jbe	 SHORT $LN1@BlRtlForma@4

; 985  : 
; 986  :         Output[Index] = ' ';

  000c8	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  000cb	03 45 fc	 add	 eax, DWORD PTR _Index$[ebp]
  000ce	c6 00 20	 mov	 BYTE PTR [eax], 32	; 00000020H

; 987  :         Index += 1;

  000d1	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  000d4	83 c1 01	 add	 ecx, 1
  000d7	89 4d fc	 mov	 DWORD PTR _Index$[ebp], ecx

; 988  :         PadWidth -= 1;

  000da	8b 55 f4	 mov	 edx, DWORD PTR _PadWidth$[ebp]
  000dd	83 ea 01	 sub	 edx, 1
  000e0	89 55 f4	 mov	 DWORD PTR _PadWidth$[ebp], edx

; 989  :     }

  000e3	eb dd		 jmp	 SHORT $LN2@BlRtlForma@4
$LN1@BlRtlForma@4:

; 990  : 
; 991  :     //
; 992  :     // Set number of characters consumed in the buffer.
; 993  :     //
; 994  : 
; 995  :     *CharactersConsumed = Index;

  000e5	8b 45 10	 mov	 eax, DWORD PTR _CharactersConsumed$[ebp]
  000e8	8b 4d fc	 mov	 ecx, DWORD PTR _Index$[ebp]
  000eb	89 08		 mov	 DWORD PTR [eax], ecx

; 996  : 
; 997  :     return TRUE;

  000ed	b0 01		 mov	 al, 1
$LN11@BlRtlForma@4:

; 998  : }

  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 0c 00	 ret	 12			; 0000000cH
?BlRtlFormatStringToken@@YIEPADKPBDJPAK@Z ENDP		; BlRtlFormatStringToken
_TEXT	ENDS
PUBLIC	?BlRtlFormatChar@@YIEPADKDPAK@Z			; BlRtlFormatChar
; Function compile flags: /Odtp
;	COMDAT ?BlRtlFormatChar@@YIEPADKDPAK@Z
_TEXT	SEGMENT
_OutputSize$ = -8					; size = 4
_Output$ = -4						; size = 4
_Value$ = 8						; size = 1
_CharactersConsumed$ = 12				; size = 4
?BlRtlFormatChar@@YIEPADKDPAK@Z PROC			; BlRtlFormatChar, COMDAT
; _Output$ = ecx
; _OutputSize$ = edx

; 1032 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 55 f8	 mov	 DWORD PTR _OutputSize$[ebp], edx
  00009	89 4d fc	 mov	 DWORD PTR _Output$[ebp], ecx

; 1033 :     //
; 1034 :     // Check if there is sufficient space in the output buffer.
; 1035 :     //
; 1036 : 
; 1037 :     if (1 > OutputSize) {

  0000c	83 7d f8 01	 cmp	 DWORD PTR _OutputSize$[ebp], 1
  00010	73 04		 jae	 SHORT $LN1@BlRtlForma@5

; 1038 : 
; 1039 :         return FALSE;

  00012	32 c0		 xor	 al, al
  00014	eb 13		 jmp	 SHORT $LN2@BlRtlForma@5
$LN1@BlRtlForma@5:

; 1040 :     }
; 1041 : 
; 1042 :     Output[0] = Value;

  00016	8b 45 fc	 mov	 eax, DWORD PTR _Output$[ebp]
  00019	8a 4d 08	 mov	 cl, BYTE PTR _Value$[ebp]
  0001c	88 08		 mov	 BYTE PTR [eax], cl

; 1043 : 
; 1044 :     //
; 1045 :     // Set number of characters consumed in the buffer.
; 1046 :     //
; 1047 : 
; 1048 :     *CharactersConsumed = 1;

  0001e	8b 55 0c	 mov	 edx, DWORD PTR _CharactersConsumed$[ebp]
  00021	c7 02 01 00 00
	00		 mov	 DWORD PTR [edx], 1

; 1049 : 
; 1050 :     return TRUE;

  00027	b0 01		 mov	 al, 1
$LN2@BlRtlForma@5:

; 1051 : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
?BlRtlFormatChar@@YIEPADKDPAK@Z ENDP			; BlRtlFormatChar
_TEXT	ENDS
PUBLIC	?BlRtlFormatString@@YIEPADKPBD0@Z		; BlRtlFormatString
; Function compile flags: /Odtp
;	COMDAT ?BlRtlFormatString@@YIEPADKPBD0@Z
_TEXT	SEGMENT
tv131 = -36						; size = 4
tv75 = -32						; size = 4
_OutputSize$ = -28					; size = 4
_Output$ = -24						; size = 4
_CharactersConsumed$ = -20				; size = 4
_OutputIndex$ = -16					; size = 4
_InputIndex$ = -12					; size = 4
_Width$ = -8						; size = 4
_PadCharacter$ = -2					; size = 1
_TokenType$ = -1					; size = 1
_Format$ = 8						; size = 4
_ArgumentList$ = 12					; size = 4
?BlRtlFormatString@@YIEPADKPBD0@Z PROC			; BlRtlFormatString, COMDAT
; _Output$ = ecx
; _OutputSize$ = edx

; 1084 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 55 e4	 mov	 DWORD PTR _OutputSize$[ebp], edx
  00009	89 4d e8	 mov	 DWORD PTR _Output$[ebp], ecx

; 1085 :     UINT32 CharactersConsumed;
; 1086 :     UINT32 InputIndex;
; 1087 :     UINT32 OutputIndex;
; 1088 :     CHAR PadCharacter;
; 1089 :     UINT8 TokenType;
; 1090 :     INT32 Width;
; 1091 : 
; 1092 :     InputIndex = 0;

  0000c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _InputIndex$[ebp], 0

; 1093 :     OutputIndex = 0;

  00013	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _OutputIndex$[ebp], 0
$LN30@BlRtlForma@6:

; 1094 : 
; 1095 :     for (;;) {
; 1096 : 
; 1097 :         if (OutputIndex == OutputSize) {

  0001a	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  0001d	3b 45 e4	 cmp	 eax, DWORD PTR _OutputSize$[ebp]
  00020	75 07		 jne	 SHORT $LN28@BlRtlForma@6

; 1098 : 
; 1099 :             return FALSE;

  00022	32 c0		 xor	 al, al
  00024	e9 4f 03 00 00	 jmp	 $LN31@BlRtlForma@6
$LN28@BlRtlForma@6:

; 1100 :         }
; 1101 : 
; 1102 :         if (Format[InputIndex] == 0) {

  00029	8b 4d 08	 mov	 ecx, DWORD PTR _Format$[ebp]
  0002c	03 4d f4	 add	 ecx, DWORD PTR _InputIndex$[ebp]
  0002f	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00032	85 d2		 test	 edx, edx
  00034	75 10		 jne	 SHORT $LN27@BlRtlForma@6

; 1103 : 
; 1104 :             Output[OutputIndex] = 0;

  00036	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  00039	03 45 f0	 add	 eax, DWORD PTR _OutputIndex$[ebp]
  0003c	c6 00 00	 mov	 BYTE PTR [eax], 0

; 1105 :             return TRUE;

  0003f	b0 01		 mov	 al, 1
  00041	e9 32 03 00 00	 jmp	 $LN31@BlRtlForma@6
$LN27@BlRtlForma@6:

; 1106 :         }
; 1107 : 
; 1108 :         if (Format[InputIndex] == '\\') {

  00046	8b 4d 08	 mov	 ecx, DWORD PTR _Format$[ebp]
  00049	03 4d f4	 add	 ecx, DWORD PTR _InputIndex$[ebp]
  0004c	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0004f	83 fa 5c	 cmp	 edx, 92			; 0000005cH
  00052	75 71		 jne	 SHORT $LN26@BlRtlForma@6

; 1109 : 
; 1110 :             switch (Format[InputIndex + 1]) {

  00054	8b 45 08	 mov	 eax, DWORD PTR _Format$[ebp]
  00057	03 45 f4	 add	 eax, DWORD PTR _InputIndex$[ebp]
  0005a	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0005d	88 4d e0	 mov	 BYTE PTR tv75[ebp], cl
  00060	80 7d e0 5c	 cmp	 BYTE PTR tv75[ebp], 92	; 0000005cH
  00064	74 0e		 je	 SHORT $LN23@BlRtlForma@6
  00066	80 7d e0 6e	 cmp	 BYTE PTR tv75[ebp], 110	; 0000006eH
  0006a	74 30		 je	 SHORT $LN21@BlRtlForma@6
  0006c	80 7d e0 72	 cmp	 BYTE PTR tv75[ebp], 114	; 00000072H
  00070	74 16		 je	 SHORT $LN22@BlRtlForma@6
  00072	eb 3c		 jmp	 SHORT $LN20@BlRtlForma@6
$LN23@BlRtlForma@6:

; 1111 : 
; 1112 :                 case '\\': {
; 1113 : 
; 1114 :                     Output[OutputIndex] = '\\';

  00074	8b 55 e8	 mov	 edx, DWORD PTR _Output$[ebp]
  00077	03 55 f0	 add	 edx, DWORD PTR _OutputIndex$[ebp]
  0007a	c6 02 5c	 mov	 BYTE PTR [edx], 92	; 0000005cH

; 1115 :                     OutputIndex += 1;

  0007d	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  00080	83 c0 01	 add	 eax, 1
  00083	89 45 f0	 mov	 DWORD PTR _OutputIndex$[ebp], eax

; 1116 :                     break;

  00086	eb 2f		 jmp	 SHORT $LN24@BlRtlForma@6
$LN22@BlRtlForma@6:

; 1117 :                 }
; 1118 : 
; 1119 :                 case 'r': {
; 1120 : 
; 1121 :                     Output[OutputIndex] = '\r';

  00088	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  0008b	03 4d f0	 add	 ecx, DWORD PTR _OutputIndex$[ebp]
  0008e	c6 01 0d	 mov	 BYTE PTR [ecx], 13	; 0000000dH

; 1122 :                     OutputIndex += 1;

  00091	8b 55 f0	 mov	 edx, DWORD PTR _OutputIndex$[ebp]
  00094	83 c2 01	 add	 edx, 1
  00097	89 55 f0	 mov	 DWORD PTR _OutputIndex$[ebp], edx

; 1123 :                     break;

  0009a	eb 1b		 jmp	 SHORT $LN24@BlRtlForma@6
$LN21@BlRtlForma@6:

; 1124 :                 }
; 1125 : 
; 1126 :                 case 'n': {
; 1127 : 
; 1128 :                     Output[OutputIndex] = '\r';

  0009c	8b 45 e8	 mov	 eax, DWORD PTR _Output$[ebp]
  0009f	03 45 f0	 add	 eax, DWORD PTR _OutputIndex$[ebp]
  000a2	c6 00 0d	 mov	 BYTE PTR [eax], 13	; 0000000dH

; 1129 :                     OutputIndex += 1;

  000a5	8b 4d f0	 mov	 ecx, DWORD PTR _OutputIndex$[ebp]
  000a8	83 c1 01	 add	 ecx, 1
  000ab	89 4d f0	 mov	 DWORD PTR _OutputIndex$[ebp], ecx

; 1130 :                     break;

  000ae	eb 07		 jmp	 SHORT $LN24@BlRtlForma@6
$LN20@BlRtlForma@6:

; 1131 :                 }
; 1132 : 
; 1133 :                 default: {
; 1134 : 
; 1135 :                     return FALSE;

  000b0	32 c0		 xor	 al, al
  000b2	e9 c1 02 00 00	 jmp	 $LN31@BlRtlForma@6
$LN24@BlRtlForma@6:

; 1136 :                 }
; 1137 :             }
; 1138 : 
; 1139 :             InputIndex += 2;

  000b7	8b 55 f4	 mov	 edx, DWORD PTR _InputIndex$[ebp]
  000ba	83 c2 02	 add	 edx, 2
  000bd	89 55 f4	 mov	 DWORD PTR _InputIndex$[ebp], edx

; 1140 :             continue;

  000c0	e9 55 ff ff ff	 jmp	 $LN30@BlRtlForma@6
$LN26@BlRtlForma@6:

; 1141 :         }
; 1142 : 
; 1143 :         if (BlRtlParseTypeSpecifier(&Format[InputIndex],
; 1144 :                                     &Width,
; 1145 :                                     &PadCharacter,
; 1146 :                                     &TokenType,
; 1147 :                                     &CharactersConsumed) != FALSE) {

  000c5	8d 45 ec	 lea	 eax, DWORD PTR _CharactersConsumed$[ebp]
  000c8	50		 push	 eax
  000c9	8d 4d ff	 lea	 ecx, DWORD PTR _TokenType$[ebp]
  000cc	51		 push	 ecx
  000cd	8d 55 fe	 lea	 edx, DWORD PTR _PadCharacter$[ebp]
  000d0	52		 push	 edx
  000d1	8b 4d 08	 mov	 ecx, DWORD PTR _Format$[ebp]
  000d4	03 4d f4	 add	 ecx, DWORD PTR _InputIndex$[ebp]
  000d7	8d 55 f8	 lea	 edx, DWORD PTR _Width$[ebp]
  000da	e8 00 00 00 00	 call	 ?BlRtlParseTypeSpecifier@@YIEPBDPAJPADPAEPAK@Z ; BlRtlParseTypeSpecifier
  000df	0f b6 c0	 movzx	 eax, al
  000e2	85 c0		 test	 eax, eax
  000e4	0f 84 67 02 00
	00		 je	 $LN19@BlRtlForma@6

; 1148 : 
; 1149 :             InputIndex += CharactersConsumed;

  000ea	8b 4d f4	 mov	 ecx, DWORD PTR _InputIndex$[ebp]
  000ed	03 4d ec	 add	 ecx, DWORD PTR _CharactersConsumed$[ebp]
  000f0	89 4d f4	 mov	 DWORD PTR _InputIndex$[ebp], ecx

; 1150 : 
; 1151 :             switch (TokenType) {

  000f3	0f b6 55 ff	 movzx	 edx, BYTE PTR _TokenType$[ebp]
  000f7	89 55 dc	 mov	 DWORD PTR tv131[ebp], edx
  000fa	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000fd	83 e8 01	 sub	 eax, 1
  00100	89 45 dc	 mov	 DWORD PTR tv131[ebp], eax
  00103	83 7d dc 08	 cmp	 DWORD PTR tv131[ebp], 8
  00107	0f 87 3f 02 00
	00		 ja	 $LN17@BlRtlForma@6
  0010d	8b 4d dc	 mov	 ecx, DWORD PTR tv131[ebp]
  00110	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN35@BlRtlForma@6[ecx*4]
$LN16@BlRtlForma@6:

; 1152 : 
; 1153 :                 case STRING_TOKEN_LONG: {
; 1154 : 
; 1155 :                     if (BlRtlFormatSignedDecimalLong(&Output[OutputIndex],
; 1156 :                                                      OutputSize - OutputIndex,
; 1157 :                                                      va_arg(ArgumentList, INT32),
; 1158 :                                                      Width,
; 1159 :                                                      &CharactersConsumed) == FALSE) {

  00117	8b 55 0c	 mov	 edx, DWORD PTR _ArgumentList$[ebp]
  0011a	83 c2 04	 add	 edx, 4
  0011d	89 55 0c	 mov	 DWORD PTR _ArgumentList$[ebp], edx
  00120	8d 45 ec	 lea	 eax, DWORD PTR _CharactersConsumed$[ebp]
  00123	50		 push	 eax
  00124	8b 4d f8	 mov	 ecx, DWORD PTR _Width$[ebp]
  00127	51		 push	 ecx
  00128	8b 55 0c	 mov	 edx, DWORD PTR _ArgumentList$[ebp]
  0012b	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0012e	50		 push	 eax
  0012f	8b 55 e4	 mov	 edx, DWORD PTR _OutputSize$[ebp]
  00132	2b 55 f0	 sub	 edx, DWORD PTR _OutputIndex$[ebp]
  00135	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  00138	03 4d f0	 add	 ecx, DWORD PTR _OutputIndex$[ebp]
  0013b	e8 00 00 00 00	 call	 ?BlRtlFormatSignedDecimalLong@@YIEPADKJJPAK@Z ; BlRtlFormatSignedDecimalLong
  00140	0f b6 c8	 movzx	 ecx, al
  00143	85 c9		 test	 ecx, ecx
  00145	75 07		 jne	 SHORT $LN15@BlRtlForma@6

; 1160 : 
; 1161 :                         return FALSE;

  00147	32 c0		 xor	 al, al
  00149	e9 2a 02 00 00	 jmp	 $LN31@BlRtlForma@6
$LN15@BlRtlForma@6:

; 1162 :                     }
; 1163 : 
; 1164 :                     OutputIndex += CharactersConsumed;

  0014e	8b 55 f0	 mov	 edx, DWORD PTR _OutputIndex$[ebp]
  00151	03 55 ec	 add	 edx, DWORD PTR _CharactersConsumed$[ebp]
  00154	89 55 f0	 mov	 DWORD PTR _OutputIndex$[ebp], edx

; 1165 :                     break;

  00157	e9 f0 01 00 00	 jmp	 $LN17@BlRtlForma@6
$LN14@BlRtlForma@6:

; 1166 :                 }
; 1167 : 
; 1168 :                 case STRING_TOKEN_ULONG: {
; 1169 : 
; 1170 :                     if (BlRtlFormatUnsignedLong(&Output[OutputIndex],
; 1171 :                                                 OutputSize - OutputIndex,
; 1172 :                                                 va_arg(ArgumentList, UINT32),
; 1173 :                                                 PadCharacter,
; 1174 :                                                 Width,
; 1175 :                                                 10,
; 1176 :                                                 &CharactersConsumed) == FALSE) {

  0015c	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  0015f	83 c0 04	 add	 eax, 4
  00162	89 45 0c	 mov	 DWORD PTR _ArgumentList$[ebp], eax
  00165	8d 4d ec	 lea	 ecx, DWORD PTR _CharactersConsumed$[ebp]
  00168	51		 push	 ecx
  00169	6a 0a		 push	 10			; 0000000aH
  0016b	8b 55 f8	 mov	 edx, DWORD PTR _Width$[ebp]
  0016e	52		 push	 edx
  0016f	8a 45 fe	 mov	 al, BYTE PTR _PadCharacter$[ebp]
  00172	50		 push	 eax
  00173	8b 4d 0c	 mov	 ecx, DWORD PTR _ArgumentList$[ebp]
  00176	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  00179	52		 push	 edx
  0017a	8b 55 e4	 mov	 edx, DWORD PTR _OutputSize$[ebp]
  0017d	2b 55 f0	 sub	 edx, DWORD PTR _OutputIndex$[ebp]
  00180	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  00183	03 4d f0	 add	 ecx, DWORD PTR _OutputIndex$[ebp]
  00186	e8 00 00 00 00	 call	 ?BlRtlFormatUnsignedLong@@YIEPADKKEJKPAK@Z ; BlRtlFormatUnsignedLong
  0018b	0f b6 c0	 movzx	 eax, al
  0018e	85 c0		 test	 eax, eax
  00190	75 07		 jne	 SHORT $LN13@BlRtlForma@6

; 1177 : 
; 1178 :                         return FALSE;

  00192	32 c0		 xor	 al, al
  00194	e9 df 01 00 00	 jmp	 $LN31@BlRtlForma@6
$LN13@BlRtlForma@6:

; 1179 :                     }
; 1180 : 
; 1181 :                     OutputIndex += CharactersConsumed;

  00199	8b 4d f0	 mov	 ecx, DWORD PTR _OutputIndex$[ebp]
  0019c	03 4d ec	 add	 ecx, DWORD PTR _CharactersConsumed$[ebp]
  0019f	89 4d f0	 mov	 DWORD PTR _OutputIndex$[ebp], ecx

; 1182 :                     break;

  001a2	e9 a5 01 00 00	 jmp	 $LN17@BlRtlForma@6
$LN12@BlRtlForma@6:

; 1183 :                 }
; 1184 : 
; 1185 :                 case STRING_TOKEN_ULONG_HEX: {
; 1186 : 
; 1187 :                     if (BlRtlFormatUnsignedLong(&Output[OutputIndex],
; 1188 :                                                 OutputSize - OutputIndex,
; 1189 :                                                 va_arg(ArgumentList, UINT32),
; 1190 :                                                 PadCharacter,
; 1191 :                                                 Width,
; 1192 :                                                 16,
; 1193 :                                                 &CharactersConsumed) == FALSE) {

  001a7	8b 55 0c	 mov	 edx, DWORD PTR _ArgumentList$[ebp]
  001aa	83 c2 04	 add	 edx, 4
  001ad	89 55 0c	 mov	 DWORD PTR _ArgumentList$[ebp], edx
  001b0	8d 45 ec	 lea	 eax, DWORD PTR _CharactersConsumed$[ebp]
  001b3	50		 push	 eax
  001b4	6a 10		 push	 16			; 00000010H
  001b6	8b 4d f8	 mov	 ecx, DWORD PTR _Width$[ebp]
  001b9	51		 push	 ecx
  001ba	8a 55 fe	 mov	 dl, BYTE PTR _PadCharacter$[ebp]
  001bd	52		 push	 edx
  001be	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  001c1	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  001c4	51		 push	 ecx
  001c5	8b 55 e4	 mov	 edx, DWORD PTR _OutputSize$[ebp]
  001c8	2b 55 f0	 sub	 edx, DWORD PTR _OutputIndex$[ebp]
  001cb	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  001ce	03 4d f0	 add	 ecx, DWORD PTR _OutputIndex$[ebp]
  001d1	e8 00 00 00 00	 call	 ?BlRtlFormatUnsignedLong@@YIEPADKKEJKPAK@Z ; BlRtlFormatUnsignedLong
  001d6	0f b6 d0	 movzx	 edx, al
  001d9	85 d2		 test	 edx, edx
  001db	75 07		 jne	 SHORT $LN11@BlRtlForma@6

; 1194 : 
; 1195 :                         return FALSE;

  001dd	32 c0		 xor	 al, al
  001df	e9 94 01 00 00	 jmp	 $LN31@BlRtlForma@6
$LN11@BlRtlForma@6:

; 1196 :                     }
; 1197 : 
; 1198 :                     OutputIndex += CharactersConsumed;

  001e4	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  001e7	03 45 ec	 add	 eax, DWORD PTR _CharactersConsumed$[ebp]
  001ea	89 45 f0	 mov	 DWORD PTR _OutputIndex$[ebp], eax

; 1199 :                     break;

  001ed	e9 5a 01 00 00	 jmp	 $LN17@BlRtlForma@6
$LN10@BlRtlForma@6:

; 1200 :                 }
; 1201 : 
; 1202 :                 case STRING_TOKEN_ULONGLONG: {
; 1203 : 
; 1204 :                     if (BlRtlFormatUnsignedLongLong(&Output[OutputIndex],
; 1205 :                                                     OutputSize - OutputIndex,
; 1206 :                                                     va_arg(ArgumentList, UINT64),
; 1207 :                                                     PadCharacter,
; 1208 :                                                     Width,
; 1209 :                                                     10,
; 1210 :                                                     &CharactersConsumed) == FALSE) {

  001f2	8b 4d 0c	 mov	 ecx, DWORD PTR _ArgumentList$[ebp]
  001f5	83 c1 08	 add	 ecx, 8
  001f8	89 4d 0c	 mov	 DWORD PTR _ArgumentList$[ebp], ecx
  001fb	8d 55 ec	 lea	 edx, DWORD PTR _CharactersConsumed$[ebp]
  001fe	52		 push	 edx
  001ff	6a 0a		 push	 10			; 0000000aH
  00201	8b 45 f8	 mov	 eax, DWORD PTR _Width$[ebp]
  00204	50		 push	 eax
  00205	8a 4d fe	 mov	 cl, BYTE PTR _PadCharacter$[ebp]
  00208	51		 push	 ecx
  00209	8b 55 0c	 mov	 edx, DWORD PTR _ArgumentList$[ebp]
  0020c	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0020f	50		 push	 eax
  00210	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00213	51		 push	 ecx
  00214	8b 55 e4	 mov	 edx, DWORD PTR _OutputSize$[ebp]
  00217	2b 55 f0	 sub	 edx, DWORD PTR _OutputIndex$[ebp]
  0021a	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  0021d	03 4d f0	 add	 ecx, DWORD PTR _OutputIndex$[ebp]
  00220	e8 00 00 00 00	 call	 ?BlRtlFormatUnsignedLongLong@@YIEPADK_KEJKPAK@Z ; BlRtlFormatUnsignedLongLong
  00225	0f b6 d0	 movzx	 edx, al
  00228	85 d2		 test	 edx, edx
  0022a	75 07		 jne	 SHORT $LN9@BlRtlForma@6

; 1211 : 
; 1212 :                         return FALSE;

  0022c	32 c0		 xor	 al, al
  0022e	e9 45 01 00 00	 jmp	 $LN31@BlRtlForma@6
$LN9@BlRtlForma@6:

; 1213 :                     }
; 1214 : 
; 1215 :                     OutputIndex += CharactersConsumed;

  00233	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  00236	03 45 ec	 add	 eax, DWORD PTR _CharactersConsumed$[ebp]
  00239	89 45 f0	 mov	 DWORD PTR _OutputIndex$[ebp], eax

; 1216 :                     break;

  0023c	e9 0b 01 00 00	 jmp	 $LN17@BlRtlForma@6
$LN8@BlRtlForma@6:

; 1217 :                 }
; 1218 : 
; 1219 :                 case STRING_TOKEN_ULONGLONG_HEX: {
; 1220 : 
; 1221 :                     if (BlRtlFormatUnsignedLongLong(&Output[OutputIndex],
; 1222 :                                                     OutputSize - OutputIndex,
; 1223 :                                                     va_arg(ArgumentList, UINT64),
; 1224 :                                                     PadCharacter,
; 1225 :                                                     Width,
; 1226 :                                                     16,
; 1227 :                                                     &CharactersConsumed) == FALSE) {

  00241	8b 4d 0c	 mov	 ecx, DWORD PTR _ArgumentList$[ebp]
  00244	83 c1 08	 add	 ecx, 8
  00247	89 4d 0c	 mov	 DWORD PTR _ArgumentList$[ebp], ecx
  0024a	8d 55 ec	 lea	 edx, DWORD PTR _CharactersConsumed$[ebp]
  0024d	52		 push	 edx
  0024e	6a 10		 push	 16			; 00000010H
  00250	8b 45 f8	 mov	 eax, DWORD PTR _Width$[ebp]
  00253	50		 push	 eax
  00254	8a 4d fe	 mov	 cl, BYTE PTR _PadCharacter$[ebp]
  00257	51		 push	 ecx
  00258	8b 55 0c	 mov	 edx, DWORD PTR _ArgumentList$[ebp]
  0025b	8b 42 fc	 mov	 eax, DWORD PTR [edx-4]
  0025e	50		 push	 eax
  0025f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00262	51		 push	 ecx
  00263	8b 55 e4	 mov	 edx, DWORD PTR _OutputSize$[ebp]
  00266	2b 55 f0	 sub	 edx, DWORD PTR _OutputIndex$[ebp]
  00269	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  0026c	03 4d f0	 add	 ecx, DWORD PTR _OutputIndex$[ebp]
  0026f	e8 00 00 00 00	 call	 ?BlRtlFormatUnsignedLongLong@@YIEPADK_KEJKPAK@Z ; BlRtlFormatUnsignedLongLong
  00274	0f b6 d0	 movzx	 edx, al
  00277	85 d2		 test	 edx, edx
  00279	75 07		 jne	 SHORT $LN7@BlRtlForma@6

; 1228 : 
; 1229 :                         return FALSE;

  0027b	32 c0		 xor	 al, al
  0027d	e9 f6 00 00 00	 jmp	 $LN31@BlRtlForma@6
$LN7@BlRtlForma@6:

; 1230 :                     }
; 1231 : 
; 1232 :                     OutputIndex += CharactersConsumed;

  00282	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  00285	03 45 ec	 add	 eax, DWORD PTR _CharactersConsumed$[ebp]
  00288	89 45 f0	 mov	 DWORD PTR _OutputIndex$[ebp], eax

; 1233 :                     break;

  0028b	e9 bc 00 00 00	 jmp	 $LN17@BlRtlForma@6
$LN6@BlRtlForma@6:

; 1234 :                 }
; 1235 : 
; 1236 :                 case STRING_TOKEN_PVOID: {
; 1237 : 
; 1238 : #if defined(BOOT_X86)
; 1239 : 
; 1240 :                     if (BlRtlFormatUnsignedLong(&Output[OutputIndex],
; 1241 :                                                 OutputSize - OutputIndex,
; 1242 :                                                 va_arg(ArgumentList, UINT32),
; 1243 :                                                 '0',
; 1244 :                                                 8,
; 1245 :                                                 16,
; 1246 :                                                 &CharactersConsumed) == FALSE) {

  00290	8b 4d 0c	 mov	 ecx, DWORD PTR _ArgumentList$[ebp]
  00293	83 c1 04	 add	 ecx, 4
  00296	89 4d 0c	 mov	 DWORD PTR _ArgumentList$[ebp], ecx
  00299	8d 55 ec	 lea	 edx, DWORD PTR _CharactersConsumed$[ebp]
  0029c	52		 push	 edx
  0029d	6a 10		 push	 16			; 00000010H
  0029f	6a 08		 push	 8
  002a1	6a 30		 push	 48			; 00000030H
  002a3	8b 45 0c	 mov	 eax, DWORD PTR _ArgumentList$[ebp]
  002a6	8b 48 fc	 mov	 ecx, DWORD PTR [eax-4]
  002a9	51		 push	 ecx
  002aa	8b 55 e4	 mov	 edx, DWORD PTR _OutputSize$[ebp]
  002ad	2b 55 f0	 sub	 edx, DWORD PTR _OutputIndex$[ebp]
  002b0	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  002b3	03 4d f0	 add	 ecx, DWORD PTR _OutputIndex$[ebp]
  002b6	e8 00 00 00 00	 call	 ?BlRtlFormatUnsignedLong@@YIEPADKKEJKPAK@Z ; BlRtlFormatUnsignedLong
  002bb	0f b6 d0	 movzx	 edx, al
  002be	85 d2		 test	 edx, edx
  002c0	75 07		 jne	 SHORT $LN5@BlRtlForma@6

; 1247 : 
; 1248 :                         return FALSE;

  002c2	32 c0		 xor	 al, al
  002c4	e9 af 00 00 00	 jmp	 $LN31@BlRtlForma@6
$LN5@BlRtlForma@6:

; 1249 :                     }
; 1250 : 
; 1251 : #elif defined(BOOT_X64)
; 1252 : 
; 1253 :                     if (BlRtlFormatUnsignedLongLong(&Output[OutputIndex],
; 1254 :                                                     OutputSize - OutputIndex,
; 1255 :                                                     va_arg(ArgumentList, UINT64),
; 1256 :                                                     '0',
; 1257 :                                                     16,
; 1258 :                                                     16,
; 1259 :                                                     &CharactersConsumed) == FALSE) {
; 1260 : 
; 1261 :                         return FALSE;
; 1262 :                     }
; 1263 : 
; 1264 : #endif
; 1265 : 
; 1266 :                     OutputIndex += CharactersConsumed;

  002c9	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  002cc	03 45 ec	 add	 eax, DWORD PTR _CharactersConsumed$[ebp]
  002cf	89 45 f0	 mov	 DWORD PTR _OutputIndex$[ebp], eax

; 1267 :                     break;

  002d2	eb 78		 jmp	 SHORT $LN17@BlRtlForma@6
$LN4@BlRtlForma@6:

; 1268 :                 }
; 1269 : 
; 1270 :                 case STRING_TOKEN_PCHAR: {
; 1271 : 
; 1272 :                     if (BlRtlFormatStringToken(&Output[OutputIndex],
; 1273 :                                                OutputSize - OutputIndex,
; 1274 :                                                va_arg(ArgumentList, PCHAR),
; 1275 :                                                Width,
; 1276 :                                                &CharactersConsumed) == FALSE) {

  002d4	8b 4d 0c	 mov	 ecx, DWORD PTR _ArgumentList$[ebp]
  002d7	83 c1 04	 add	 ecx, 4
  002da	89 4d 0c	 mov	 DWORD PTR _ArgumentList$[ebp], ecx
  002dd	8d 55 ec	 lea	 edx, DWORD PTR _CharactersConsumed$[ebp]
  002e0	52		 push	 edx
  002e1	8b 45 f8	 mov	 eax, DWORD PTR _Width$[ebp]
  002e4	50		 push	 eax
  002e5	8b 4d 0c	 mov	 ecx, DWORD PTR _ArgumentList$[ebp]
  002e8	8b 51 fc	 mov	 edx, DWORD PTR [ecx-4]
  002eb	52		 push	 edx
  002ec	8b 55 e4	 mov	 edx, DWORD PTR _OutputSize$[ebp]
  002ef	2b 55 f0	 sub	 edx, DWORD PTR _OutputIndex$[ebp]
  002f2	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  002f5	03 4d f0	 add	 ecx, DWORD PTR _OutputIndex$[ebp]
  002f8	e8 00 00 00 00	 call	 ?BlRtlFormatStringToken@@YIEPADKPBDJPAK@Z ; BlRtlFormatStringToken
  002fd	0f b6 c0	 movzx	 eax, al
  00300	85 c0		 test	 eax, eax
  00302	75 04		 jne	 SHORT $LN3@BlRtlForma@6

; 1277 : 
; 1278 :                         return FALSE;

  00304	32 c0		 xor	 al, al
  00306	eb 70		 jmp	 SHORT $LN31@BlRtlForma@6
$LN3@BlRtlForma@6:

; 1279 :                     }
; 1280 : 
; 1281 :                     OutputIndex += CharactersConsumed;

  00308	8b 4d f0	 mov	 ecx, DWORD PTR _OutputIndex$[ebp]
  0030b	03 4d ec	 add	 ecx, DWORD PTR _CharactersConsumed$[ebp]
  0030e	89 4d f0	 mov	 DWORD PTR _OutputIndex$[ebp], ecx

; 1282 :                     break;

  00311	eb 39		 jmp	 SHORT $LN17@BlRtlForma@6
$LN2@BlRtlForma@6:

; 1283 :                 }
; 1284 : 
; 1285 :                 case STRING_TOKEN_CHAR: {
; 1286 : 
; 1287 :                     if (BlRtlFormatChar(&Output[OutputIndex],
; 1288 :                                         OutputSize - OutputIndex,
; 1289 :                                         va_arg(ArgumentList, CHAR),
; 1290 :                                         &CharactersConsumed) == FALSE) {

  00313	8b 55 0c	 mov	 edx, DWORD PTR _ArgumentList$[ebp]
  00316	83 c2 04	 add	 edx, 4
  00319	89 55 0c	 mov	 DWORD PTR _ArgumentList$[ebp], edx
  0031c	8d 45 ec	 lea	 eax, DWORD PTR _CharactersConsumed$[ebp]
  0031f	50		 push	 eax
  00320	8b 4d 0c	 mov	 ecx, DWORD PTR _ArgumentList$[ebp]
  00323	8a 51 fc	 mov	 dl, BYTE PTR [ecx-4]
  00326	52		 push	 edx
  00327	8b 55 e4	 mov	 edx, DWORD PTR _OutputSize$[ebp]
  0032a	2b 55 f0	 sub	 edx, DWORD PTR _OutputIndex$[ebp]
  0032d	8b 4d e8	 mov	 ecx, DWORD PTR _Output$[ebp]
  00330	03 4d f0	 add	 ecx, DWORD PTR _OutputIndex$[ebp]
  00333	e8 00 00 00 00	 call	 ?BlRtlFormatChar@@YIEPADKDPAK@Z ; BlRtlFormatChar
  00338	0f b6 c0	 movzx	 eax, al
  0033b	85 c0		 test	 eax, eax
  0033d	75 04		 jne	 SHORT $LN1@BlRtlForma@6

; 1291 : 
; 1292 :                         return FALSE;

  0033f	32 c0		 xor	 al, al
  00341	eb 35		 jmp	 SHORT $LN31@BlRtlForma@6
$LN1@BlRtlForma@6:

; 1293 :                     }
; 1294 : 
; 1295 :                     OutputIndex += CharactersConsumed;

  00343	8b 4d f0	 mov	 ecx, DWORD PTR _OutputIndex$[ebp]
  00346	03 4d ec	 add	 ecx, DWORD PTR _CharactersConsumed$[ebp]
  00349	89 4d f0	 mov	 DWORD PTR _OutputIndex$[ebp], ecx
$LN17@BlRtlForma@6:

; 1296 :                     break;
; 1297 :                 }
; 1298 :             }
; 1299 : 
; 1300 :             continue;

  0034c	e9 c9 fc ff ff	 jmp	 $LN30@BlRtlForma@6
$LN19@BlRtlForma@6:

; 1301 :         }
; 1302 : 
; 1303 :         Output[OutputIndex] = Format[InputIndex];

  00351	8b 55 e8	 mov	 edx, DWORD PTR _Output$[ebp]
  00354	03 55 f0	 add	 edx, DWORD PTR _OutputIndex$[ebp]
  00357	8b 45 08	 mov	 eax, DWORD PTR _Format$[ebp]
  0035a	03 45 f4	 add	 eax, DWORD PTR _InputIndex$[ebp]
  0035d	8a 08		 mov	 cl, BYTE PTR [eax]
  0035f	88 0a		 mov	 BYTE PTR [edx], cl

; 1304 :         InputIndex += 1;

  00361	8b 55 f4	 mov	 edx, DWORD PTR _InputIndex$[ebp]
  00364	83 c2 01	 add	 edx, 1
  00367	89 55 f4	 mov	 DWORD PTR _InputIndex$[ebp], edx

; 1305 :         OutputIndex += 1;

  0036a	8b 45 f0	 mov	 eax, DWORD PTR _OutputIndex$[ebp]
  0036d	83 c0 01	 add	 eax, 1
  00370	89 45 f0	 mov	 DWORD PTR _OutputIndex$[ebp], eax

; 1306 :     }

  00373	e9 a2 fc ff ff	 jmp	 $LN30@BlRtlForma@6
$LN31@BlRtlForma@6:

; 1307 : }

  00378	8b e5		 mov	 esp, ebp
  0037a	5d		 pop	 ebp
  0037b	c2 08 00	 ret	 8
  0037e	8b ff		 npad	 2
$LN35@BlRtlForma@6:
  00380	00 00 00 00	 DD	 $LN16@BlRtlForma@6
  00384	00 00 00 00	 DD	 $LN14@BlRtlForma@6
  00388	00 00 00 00	 DD	 $LN12@BlRtlForma@6
  0038c	00 00 00 00	 DD	 $LN17@BlRtlForma@6
  00390	00 00 00 00	 DD	 $LN10@BlRtlForma@6
  00394	00 00 00 00	 DD	 $LN8@BlRtlForma@6
  00398	00 00 00 00	 DD	 $LN6@BlRtlForma@6
  0039c	00 00 00 00	 DD	 $LN4@BlRtlForma@6
  003a0	00 00 00 00	 DD	 $LN2@BlRtlForma@6
?BlRtlFormatString@@YIEPADKPBD0@Z ENDP			; BlRtlFormatString
_TEXT	ENDS
PUBLIC	?BlRtlPrintf@@YAEPBDZZ				; BlRtlPrintf
EXTRN	?BlKdPrintString@@YIEPBD@Z:PROC			; BlKdPrintString
EXTRN	?BlVideoPrintString@@YIXPBD@Z:PROC		; BlVideoPrintString
; Function compile flags: /Odtp
;	COMDAT ?BlRtlPrintf@@YAEPBDZZ
_TEXT	SEGMENT
_Buffer$ = -4104					; size = 4096
_ArgumentList$ = -4					; size = 4
_Format$ = 8						; size = 4
?BlRtlPrintf@@YAEPBDZZ PROC				; BlRtlPrintf, COMDAT

; 1334 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 08 10 00
	00		 sub	 esp, 4104		; 00001008H

; 1335 :     va_list ArgumentList;
; 1336 :     CHAR Buffer[4096];
; 1337 : 
; 1338 :     va_start(ArgumentList, Format);

  00009	8d 45 0c	 lea	 eax, DWORD PTR _Format$[ebp+4]
  0000c	89 45 fc	 mov	 DWORD PTR _ArgumentList$[ebp], eax

; 1339 : 
; 1340 :     if (BlRtlFormatString(Buffer, sizeof(Buffer), Format, ArgumentList) == FALSE) {

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _ArgumentList$[ebp]
  00012	51		 push	 ecx
  00013	8b 55 08	 mov	 edx, DWORD PTR _Format$[ebp]
  00016	52		 push	 edx
  00017	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  0001c	8d 8d f8 ef ff
	ff		 lea	 ecx, DWORD PTR _Buffer$[ebp]
  00022	e8 00 00 00 00	 call	 ?BlRtlFormatString@@YIEPADKPBD0@Z ; BlRtlFormatString
  00027	0f b6 c0	 movzx	 eax, al
  0002a	85 c0		 test	 eax, eax
  0002c	75 04		 jne	 SHORT $LN1@BlRtlPrint

; 1341 : 
; 1342 :         return FALSE;

  0002e	32 c0		 xor	 al, al
  00030	eb 18		 jmp	 SHORT $LN2@BlRtlPrint
$LN1@BlRtlPrint:

; 1343 :     }
; 1344 : 
; 1345 :     BlVideoPrintString(Buffer);

  00032	8d 8d f8 ef ff
	ff		 lea	 ecx, DWORD PTR _Buffer$[ebp]
  00038	e8 00 00 00 00	 call	 ?BlVideoPrintString@@YIXPBD@Z ; BlVideoPrintString

; 1346 : 
; 1347 :     BlKdPrintString(Buffer);

  0003d	8d 8d f8 ef ff
	ff		 lea	 ecx, DWORD PTR _Buffer$[ebp]
  00043	e8 00 00 00 00	 call	 ?BlKdPrintString@@YIEPBD@Z ; BlKdPrintString

; 1348 : 
; 1349 :     return TRUE;

  00048	b0 01		 mov	 al, 1
$LN2@BlRtlPrint:

; 1350 : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?BlRtlPrintf@@YAEPBDZZ ENDP				; BlRtlPrintf
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?BlRtlEqualStringN@@YIEPBD0K@Z
_TEXT	SEGMENT
_String2$ = -8						; size = 4
_String1$ = -4						; size = 4
_Count$ = 8						; size = 4
?BlRtlEqualStringN@@YIEPBD0K@Z PROC			; BlRtlEqualStringN, COMDAT
; _String1$ = ecx
; _String2$ = edx

; 1380 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 55 f8	 mov	 DWORD PTR _String2$[ebp], edx
  00009	89 4d fc	 mov	 DWORD PTR _String1$[ebp], ecx
$LN5@BlRtlEqual:

; 1381 :     while (Count > 0) {

  0000c	83 7d 08 00	 cmp	 DWORD PTR _Count$[ebp], 0
  00010	76 49		 jbe	 SHORT $LN4@BlRtlEqual

; 1382 : 
; 1383 :         if ((*String1 == 0) || (*String2 == 0)) {

  00012	8b 45 fc	 mov	 eax, DWORD PTR _String1$[ebp]
  00015	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00018	85 c9		 test	 ecx, ecx
  0001a	74 0a		 je	 SHORT $LN2@BlRtlEqual
  0001c	8b 55 f8	 mov	 edx, DWORD PTR _String2$[ebp]
  0001f	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00022	85 c0		 test	 eax, eax
  00024	75 04		 jne	 SHORT $LN3@BlRtlEqual
$LN2@BlRtlEqual:

; 1384 : 
; 1385 :             return FALSE;

  00026	32 c0		 xor	 al, al
  00028	eb 33		 jmp	 SHORT $LN6@BlRtlEqual
$LN3@BlRtlEqual:

; 1386 :         }
; 1387 : 
; 1388 :         if (*String1 != *String2) {

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _String1$[ebp]
  0002d	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00030	8b 45 f8	 mov	 eax, DWORD PTR _String2$[ebp]
  00033	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00036	3b d1		 cmp	 edx, ecx
  00038	74 04		 je	 SHORT $LN1@BlRtlEqual

; 1389 : 
; 1390 :             return FALSE;

  0003a	32 c0		 xor	 al, al
  0003c	eb 1f		 jmp	 SHORT $LN6@BlRtlEqual
$LN1@BlRtlEqual:

; 1391 :         }
; 1392 : 
; 1393 :         String1 += 1;

  0003e	8b 55 fc	 mov	 edx, DWORD PTR _String1$[ebp]
  00041	83 c2 01	 add	 edx, 1
  00044	89 55 fc	 mov	 DWORD PTR _String1$[ebp], edx

; 1394 :         String2 += 1;

  00047	8b 45 f8	 mov	 eax, DWORD PTR _String2$[ebp]
  0004a	83 c0 01	 add	 eax, 1
  0004d	89 45 f8	 mov	 DWORD PTR _String2$[ebp], eax

; 1395 :         Count -= 1;

  00050	8b 4d 08	 mov	 ecx, DWORD PTR _Count$[ebp]
  00053	83 e9 01	 sub	 ecx, 1
  00056	89 4d 08	 mov	 DWORD PTR _Count$[ebp], ecx

; 1396 :     }

  00059	eb b1		 jmp	 SHORT $LN5@BlRtlEqual
$LN4@BlRtlEqual:

; 1397 : 
; 1398 :     return TRUE;

  0005b	b0 01		 mov	 al, 1
$LN6@BlRtlEqual:

; 1399 : }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?BlRtlEqualStringN@@YIEPBD0K@Z ENDP			; BlRtlEqualStringN
_TEXT	ENDS
PUBLIC	?BlRtlEqualStringI@@YIEPBD0@Z			; BlRtlEqualStringI
; Function compile flags: /Odtp
;	COMDAT ?BlRtlEqualStringI@@YIEPBD0@Z
_TEXT	SEGMENT
_String2$ = -8						; size = 4
_String1$ = -4						; size = 4
?BlRtlEqualStringI@@YIEPBD0@Z PROC			; BlRtlEqualStringI, COMDAT
; _String1$ = ecx
; _String2$ = edx

; 1426 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 55 f8	 mov	 DWORD PTR _String2$[ebp], edx
  0000a	89 4d fc	 mov	 DWORD PTR _String1$[ebp], ecx
$LN4@BlRtlEqual@2:

; 1427 :     for (;;) {
; 1428 : 
; 1429 :         if (BlRtlConvertCharacterToUpperCase(*String1) != BlRtlConvertCharacterToUpperCase(*String2)) {

  0000d	8b 45 fc	 mov	 eax, DWORD PTR _String1$[ebp]
  00010	8a 08		 mov	 cl, BYTE PTR [eax]
  00012	e8 00 00 00 00	 call	 ?BlRtlConvertCharacterToUpperCase@@YIDD@Z ; BlRtlConvertCharacterToUpperCase
  00017	0f be f0	 movsx	 esi, al
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _String2$[ebp]
  0001d	8a 09		 mov	 cl, BYTE PTR [ecx]
  0001f	e8 00 00 00 00	 call	 ?BlRtlConvertCharacterToUpperCase@@YIDD@Z ; BlRtlConvertCharacterToUpperCase
  00024	0f be d0	 movsx	 edx, al
  00027	3b f2		 cmp	 esi, edx
  00029	74 04		 je	 SHORT $LN2@BlRtlEqual@2

; 1430 : 
; 1431 :             return FALSE;

  0002b	32 c0		 xor	 al, al
  0002d	eb 22		 jmp	 SHORT $LN5@BlRtlEqual@2
$LN2@BlRtlEqual@2:

; 1432 :         }
; 1433 : 
; 1434 :         if (*String1 == 0) {

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _String1$[ebp]
  00032	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00035	85 c9		 test	 ecx, ecx
  00037	75 04		 jne	 SHORT $LN1@BlRtlEqual@2

; 1435 : 
; 1436 :             return TRUE;

  00039	b0 01		 mov	 al, 1
  0003b	eb 14		 jmp	 SHORT $LN5@BlRtlEqual@2
$LN1@BlRtlEqual@2:

; 1437 :         }
; 1438 : 
; 1439 :         String1 += 1;

  0003d	8b 55 fc	 mov	 edx, DWORD PTR _String1$[ebp]
  00040	83 c2 01	 add	 edx, 1
  00043	89 55 fc	 mov	 DWORD PTR _String1$[ebp], edx

; 1440 :         String2 += 1;

  00046	8b 45 f8	 mov	 eax, DWORD PTR _String2$[ebp]
  00049	83 c0 01	 add	 eax, 1
  0004c	89 45 f8	 mov	 DWORD PTR _String2$[ebp], eax

; 1441 :     }

  0004f	eb bc		 jmp	 SHORT $LN4@BlRtlEqual@2
$LN5@BlRtlEqual@2:

; 1442 : }

  00051	5e		 pop	 esi
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
?BlRtlEqualStringI@@YIEPBD0@Z ENDP			; BlRtlEqualStringI
_TEXT	ENDS
PUBLIC	?BlRtlFindSubstring@@YIPBDPBD0@Z		; BlRtlFindSubstring
; Function compile flags: /Odtp
;	COMDAT ?BlRtlFindSubstring@@YIPBDPBD0@Z
_TEXT	SEGMENT
_Substring$ = -12					; size = 4
_String$ = -8						; size = 4
_SubstringLength$ = -4					; size = 4
?BlRtlFindSubstring@@YIPBDPBD0@Z PROC			; BlRtlFindSubstring, COMDAT
; _String$ = ecx
; _Substring$ = edx

; 1469 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 55 f4	 mov	 DWORD PTR _Substring$[ebp], edx
  00009	89 4d f8	 mov	 DWORD PTR _String$[ebp], ecx

; 1470 :     UINT32 SubstringLength;
; 1471 : 
; 1472 :     SubstringLength = BlRtlStringLength(Substring);

  0000c	8b 4d f4	 mov	 ecx, DWORD PTR _Substring$[ebp]
  0000f	e8 00 00 00 00	 call	 ?BlRtlStringLength@@YIKPBD@Z ; BlRtlStringLength
  00014	89 45 fc	 mov	 DWORD PTR _SubstringLength$[ebp], eax
$LN3@BlRtlFindS:

; 1473 : 
; 1474 :     while (*String != 0) {

  00017	8b 45 f8	 mov	 eax, DWORD PTR _String$[ebp]
  0001a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0001d	85 c9		 test	 ecx, ecx
  0001f	74 26		 je	 SHORT $LN2@BlRtlFindS

; 1475 : 
; 1476 :         if (BlRtlEqualStringN(String, Substring, SubstringLength) != FALSE) {

  00021	8b 55 fc	 mov	 edx, DWORD PTR _SubstringLength$[ebp]
  00024	52		 push	 edx
  00025	8b 55 f4	 mov	 edx, DWORD PTR _Substring$[ebp]
  00028	8b 4d f8	 mov	 ecx, DWORD PTR _String$[ebp]
  0002b	e8 00 00 00 00	 call	 ?BlRtlEqualStringN@@YIEPBD0K@Z ; BlRtlEqualStringN
  00030	0f b6 c0	 movzx	 eax, al
  00033	85 c0		 test	 eax, eax
  00035	74 05		 je	 SHORT $LN1@BlRtlFindS

; 1477 : 
; 1478 :             return String;

  00037	8b 45 f8	 mov	 eax, DWORD PTR _String$[ebp]
  0003a	eb 0d		 jmp	 SHORT $LN4@BlRtlFindS
$LN1@BlRtlFindS:

; 1479 :         }
; 1480 : 
; 1481 :         String += 1;

  0003c	8b 4d f8	 mov	 ecx, DWORD PTR _String$[ebp]
  0003f	83 c1 01	 add	 ecx, 1
  00042	89 4d f8	 mov	 DWORD PTR _String$[ebp], ecx

; 1482 :     }

  00045	eb d0		 jmp	 SHORT $LN3@BlRtlFindS
$LN2@BlRtlFindS:

; 1483 : 
; 1484 :     return NULL;

  00047	33 c0		 xor	 eax, eax
$LN4@BlRtlFindS:

; 1485 : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?BlRtlFindSubstring@@YIPBDPBD0@Z ENDP			; BlRtlFindSubstring
_TEXT	ENDS
END
