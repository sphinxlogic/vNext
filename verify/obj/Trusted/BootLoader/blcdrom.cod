; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	D:\OSes\VERVE\verify\src\Trusted\BootLoader\SingLdrPc\blcdrom.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?BlCdTemporaryBlock@@3PAU_ISO9660_LOGICAL_BLOCK@@A ; BlCdTemporaryBlock
PUBLIC	?BlCdDriveParameters@@3U_INT13_DRIVE_PARAMETERS@@A ; BlCdDriveParameters
PUBLIC	?BlCdDriveId@@3EA				; BlCdDriveId
PUBLIC	?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A ; BlCdVolumeDescriptor
PUBLIC	?BlCdTemporaryBlockCount@@3GA			; BlCdTemporaryBlockCount
_BSS	SEGMENT
?BlCdTemporaryBlock@@3PAU_ISO9660_LOGICAL_BLOCK@@A DB 010000H DUP (?) ; BlCdTemporaryBlock
?BlCdDriveParameters@@3U_INT13_DRIVE_PARAMETERS@@A DB 01aH DUP (?) ; BlCdDriveParameters
	ALIGN	4

?BlCdDriveId@@3EA DB 01H DUP (?)			; BlCdDriveId
	ALIGN	4

?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A DB 0800H DUP (?) ; BlCdVolumeDescriptor
_BSS	ENDS
_DATA	SEGMENT
?BlCdTemporaryBlockCount@@3GA DW 020H			; BlCdTemporaryBlockCount
_DATA	ENDS
PUBLIC	??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@		; `string'
PUBLIC	??_C@_0DC@EBKPCJGO@CDROM?3?5I?1O?5Error?3?5DriveID?$DN0x?$CF02x@ ; `string'
PUBLIC	?BlCdReadLogicalBlock@@YIXKKPAU_ISO9660_LOGICAL_BLOCK@@@Z ; BlCdReadLogicalBlock
EXTRN	?BlRtlCopyMemory@@YIXPAXPBXK@Z:PROC		; BlRtlCopyMemory
EXTRN	?BlRtlHaltInternal@@YIXPBDK@Z:PROC		; BlRtlHaltInternal
EXTRN	?BlRtlPrintf@@YAEPBDZZ:PROC			; BlRtlPrintf
EXTRN	?BlRtlReadDrive@@YIEE_KGPAX@Z:PROC		; BlRtlReadDrive
;	COMDAT ??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@
; File d:\oses\verve\verify\src\trusted\bootloader\singldrpc\blcdrom.cpp
CONST	SEGMENT
??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@ DB 'blcdrom.cpp', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@EBKPCJGO@CDROM?3?5I?1O?5Error?3?5DriveID?$DN0x?$CF02x@
CONST	SEGMENT
??_C@_0DC@EBKPCJGO@CDROM?3?5I?1O?5Error?3?5DriveID?$DN0x?$CF02x@ DB 'CDRO'
	DB	'M: I/O Error: DriveID=0x%02x LBN=%u Count=%u', 0aH, 00H ; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlCdReadLogicalBlock@@YIXKKPAU_ISO9660_LOGICAL_BLOCK@@@Z
_TEXT	SEGMENT
_NumberOfBlocks$ = -16					; size = 4
_LogicalBlockNumber$ = -12				; size = 4
_ChunkSize$ = -8					; size = 2
_Result$ = -1						; size = 1
_LogicalBlock$ = 8					; size = 4
?BlCdReadLogicalBlock@@YIXKKPAU_ISO9660_LOGICAL_BLOCK@@@Z PROC ; BlCdReadLogicalBlock, COMDAT
; _LogicalBlockNumber$ = ecx
; _NumberOfBlocks$ = edx

; 191  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 55 f0	 mov	 DWORD PTR _NumberOfBlocks$[ebp], edx
  00009	89 4d f4	 mov	 DWORD PTR _LogicalBlockNumber$[ebp], ecx
$LN5@BlCdReadLo:

; 192  :     UINT16 ChunkSize;
; 193  :     BOOLEAN Result;
; 194  : 
; 195  :     while (NumberOfBlocks > 0) {

  0000c	83 7d f0 00	 cmp	 DWORD PTR _NumberOfBlocks$[ebp], 0
  00010	0f 86 b0 00 00
	00		 jbe	 $LN6@BlCdReadLo

; 196  : 
; 197  :         if (NumberOfBlocks < BlCdTemporaryBlockCount) {

  00016	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?BlCdTemporaryBlockCount@@3GA ; BlCdTemporaryBlockCount
  0001d	39 45 f0	 cmp	 DWORD PTR _NumberOfBlocks$[ebp], eax
  00020	73 0a		 jae	 SHORT $LN3@BlCdReadLo

; 198  : 
; 199  :             ChunkSize = (UINT16) NumberOfBlocks;

  00022	66 8b 4d f0	 mov	 cx, WORD PTR _NumberOfBlocks$[ebp]
  00026	66 89 4d f8	 mov	 WORD PTR _ChunkSize$[ebp], cx

; 200  : 
; 201  :         } else {

  0002a	eb 0b		 jmp	 SHORT $LN2@BlCdReadLo
$LN3@BlCdReadLo:

; 202  : 
; 203  :             ChunkSize = BlCdTemporaryBlockCount;

  0002c	66 8b 15 00 00
	00 00		 mov	 dx, WORD PTR ?BlCdTemporaryBlockCount@@3GA ; BlCdTemporaryBlockCount
  00033	66 89 55 f8	 mov	 WORD PTR _ChunkSize$[ebp], dx
$LN2@BlCdReadLo:

; 204  :         }
; 205  : 
; 206  :         Result = BlRtlReadDrive(BlCdDriveId,
; 207  :                                 LogicalBlockNumber,
; 208  :                                 ChunkSize,
; 209  :                                 BlCdTemporaryBlock);

  00037	68 00 00 00 00	 push	 OFFSET ?BlCdTemporaryBlock@@3PAU_ISO9660_LOGICAL_BLOCK@@A ; BlCdTemporaryBlock
  0003c	8b 45 f4	 mov	 eax, DWORD PTR _LogicalBlockNumber$[ebp]
  0003f	33 c9		 xor	 ecx, ecx
  00041	51		 push	 ecx
  00042	50		 push	 eax
  00043	8b 55 f8	 mov	 edx, DWORD PTR _ChunkSize$[ebp]
  00046	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?BlCdDriveId@@3EA ; BlCdDriveId
  0004c	e8 00 00 00 00	 call	 ?BlRtlReadDrive@@YIEE_KGPAX@Z ; BlRtlReadDrive
  00051	88 45 ff	 mov	 BYTE PTR _Result$[ebp], al

; 210  : 
; 211  :         if (Result == FALSE) {

  00054	0f b6 55 ff	 movzx	 edx, BYTE PTR _Result$[ebp]
  00058	85 d2		 test	 edx, edx
  0005a	75 2d		 jne	 SHORT $LN1@BlCdReadLo

; 212  : 
; 213  :             BlRtlPrintf("CDROM: I/O Error: DriveID=0x%02x LBN=%u Count=%u\n",
; 214  :                         BlCdDriveId,
; 215  :                         LogicalBlockNumber,
; 216  :                         ChunkSize);

  0005c	0f b7 45 f8	 movzx	 eax, WORD PTR _ChunkSize$[ebp]
  00060	50		 push	 eax
  00061	8b 4d f4	 mov	 ecx, DWORD PTR _LogicalBlockNumber$[ebp]
  00064	51		 push	 ecx
  00065	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR ?BlCdDriveId@@3EA ; BlCdDriveId
  0006c	52		 push	 edx
  0006d	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@EBKPCJGO@CDROM?3?5I?1O?5Error?3?5DriveID?$DN0x?$CF02x@
  00072	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00077	83 c4 10	 add	 esp, 16			; 00000010H

; 217  : 
; 218  :             BlRtlHalt();

  0007a	ba da 00 00 00	 mov	 edx, 218		; 000000daH
  0007f	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@
  00084	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN1@BlCdReadLo:

; 219  :         }
; 220  : 
; 221  :         BlRtlCopyMemory(LogicalBlock,
; 222  :                         BlCdTemporaryBlock,
; 223  :                         ChunkSize * sizeof(ISO9660_LOGICAL_BLOCK));

  00089	0f b7 45 f8	 movzx	 eax, WORD PTR _ChunkSize$[ebp]
  0008d	c1 e0 0b	 shl	 eax, 11			; 0000000bH
  00090	50		 push	 eax
  00091	ba 00 00 00 00	 mov	 edx, OFFSET ?BlCdTemporaryBlock@@3PAU_ISO9660_LOGICAL_BLOCK@@A ; BlCdTemporaryBlock
  00096	8b 4d 08	 mov	 ecx, DWORD PTR _LogicalBlock$[ebp]
  00099	e8 00 00 00 00	 call	 ?BlRtlCopyMemory@@YIXPAXPBXK@Z ; BlRtlCopyMemory

; 224  : 
; 225  :         LogicalBlockNumber += ChunkSize;

  0009e	0f b7 4d f8	 movzx	 ecx, WORD PTR _ChunkSize$[ebp]
  000a2	03 4d f4	 add	 ecx, DWORD PTR _LogicalBlockNumber$[ebp]
  000a5	89 4d f4	 mov	 DWORD PTR _LogicalBlockNumber$[ebp], ecx

; 226  :         LogicalBlock += ChunkSize;

  000a8	0f b7 55 f8	 movzx	 edx, WORD PTR _ChunkSize$[ebp]
  000ac	c1 e2 0b	 shl	 edx, 11			; 0000000bH
  000af	03 55 08	 add	 edx, DWORD PTR _LogicalBlock$[ebp]
  000b2	89 55 08	 mov	 DWORD PTR _LogicalBlock$[ebp], edx

; 227  :         NumberOfBlocks -= ChunkSize;

  000b5	0f b7 45 f8	 movzx	 eax, WORD PTR _ChunkSize$[ebp]
  000b9	8b 4d f0	 mov	 ecx, DWORD PTR _NumberOfBlocks$[ebp]
  000bc	2b c8		 sub	 ecx, eax
  000be	89 4d f0	 mov	 DWORD PTR _NumberOfBlocks$[ebp], ecx

; 228  :     }

  000c1	e9 46 ff ff ff	 jmp	 $LN5@BlCdReadLo
$LN6@BlCdReadLo:

; 229  : 
; 230  :     return;
; 231  : }

  000c6	8b e5		 mov	 esp, ebp
  000c8	5d		 pop	 ebp
  000c9	c2 04 00	 ret	 4
?BlCdReadLogicalBlock@@YIXKKPAU_ISO9660_LOGICAL_BLOCK@@@Z ENDP ; BlCdReadLogicalBlock
_TEXT	ENDS
PUBLIC	?BlCdFindDirectoryRecord@@YIEPBDPAU_ISO9660_DIRECTORY_RECORD@@@Z ; BlCdFindDirectoryRecord
EXTRN	?BlPoolFreeBlock@@YIXPAX@Z:PROC			; BlPoolFreeBlock
EXTRN	?BlRtlCompareMemory@@YIEPBX0K@Z:PROC		; BlRtlCompareMemory
EXTRN	?BlPoolAllocateBlock@@YIPAXK@Z:PROC		; BlPoolAllocateBlock
EXTRN	?BlRtlConvertCharacterToUpperCase@@YIDD@Z:PROC	; BlRtlConvertCharacterToUpperCase
EXTRN	?BlRtlAssertFailed@@YIXPBDK@Z:PROC		; BlRtlAssertFailed
; Function compile flags: /Odtp
;	COMDAT ?BlCdFindDirectoryRecord@@YIEPBDPAU_ISO9660_DIRECTORY_RECORD@@@Z
_TEXT	SEGMENT
_DirectoryRecord$ = -568				; size = 4
_Path$ = -564						; size = 4
_DirectoryData$ = -560					; size = 4
_Separator$ = -556					; size = 4
_Token$ = -552						; size = 255
_DirectoryDataExtentSize$ = -292			; size = 4
_Temp$ = -288						; size = 255
_NextToken$ = -28					; size = 4
_DirectoryDataIndex$ = -24				; size = 4
_Entry$ = -20						; size = 4
_DirectoryDataLimit$ = -16				; size = 4
_DirectoryDataExtentStart$ = -12			; size = 4
_Index$ = -8						; size = 4
_TokenSize$ = -4					; size = 4
?BlCdFindDirectoryRecord@@YIEPBDPAU_ISO9660_DIRECTORY_RECORD@@@Z PROC ; BlCdFindDirectoryRecord, COMDAT
; _Path$ = ecx
; _DirectoryRecord$ = edx

; 258  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 38 02 00
	00		 sub	 esp, 568		; 00000238H
  00009	89 95 c8 fd ff
	ff		 mov	 DWORD PTR _DirectoryRecord$[ebp], edx
  0000f	89 8d cc fd ff
	ff		 mov	 DWORD PTR _Path$[ebp], ecx

; 259  :     PISO9660_LOGICAL_BLOCK DirectoryData;
; 260  :     UINT32 DirectoryDataIndex;
; 261  :     ULONG_PTR DirectoryDataLimit;
; 262  :     UINT32 DirectoryDataExtentStart;
; 263  :     UINT32 DirectoryDataExtentSize;
; 264  :     PISO9660_DIRECTORY_RECORD Entry;
; 265  :     UINT32 Index;
; 266  :     PCSTR NextToken;
; 267  :     PCSTR Separator;
; 268  :     CHAR Temp[ISO9660_MAX_PATH];
; 269  :     CHAR Token[ISO9660_MAX_PATH];
; 270  :     UINT32 TokenSize;
; 271  : 
; 272  :     DirectoryDataExtentStart = BlCdVolumeDescriptor.u1.Supplementary.RootDirectory.ExtentLocation;

  00015	a1 9e 00 00 00	 mov	 eax, DWORD PTR ?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A+158
  0001a	89 45 f4	 mov	 DWORD PTR _DirectoryDataExtentStart$[ebp], eax

; 273  :     DirectoryDataExtentSize = ROUND_UP_TO_POWER2(BlCdVolumeDescriptor.u1.Supplementary.RootDirectory.DataLength, ISO9660_LOGICAL_BLOCK_SIZE) / ISO9660_LOGICAL_BLOCK_SIZE;

  0001d	8b 0d a6 00 00
	00		 mov	 ecx, DWORD PTR ?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A+166
  00023	81 c1 ff 07 00
	00		 add	 ecx, 2047		; 000007ffH
  00029	81 e1 00 f8 ff
	ff		 and	 ecx, -2048		; fffff800H
  0002f	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  00032	89 8d dc fe ff
	ff		 mov	 DWORD PTR _DirectoryDataExtentSize$[ebp], ecx

; 274  : 
; 275  :     NextToken = Path;

  00038	8b 95 cc fd ff
	ff		 mov	 edx, DWORD PTR _Path$[ebp]
  0003e	89 55 e4	 mov	 DWORD PTR _NextToken$[ebp], edx
$LN26@BlCdFindDi:

; 276  : 
; 277  :     for (;;) {
; 278  : 
; 279  :         BLASSERT(DirectoryDataExtentStart > ISO9660_VOLUME_SPACE_DATA_AREA_LBN);

  00041	83 7d f4 10	 cmp	 DWORD PTR _DirectoryDataExtentStart$[ebp], 16 ; 00000010H
  00045	77 0f		 ja	 SHORT $LN24@BlCdFindDi
  00047	ba 17 01 00 00	 mov	 edx, 279		; 00000117H
  0004c	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@
  00051	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN24@BlCdFindDi:

; 280  : 
; 281  :         BLASSERT(DirectoryDataExtentSize > 0);

  00056	83 bd dc fe ff
	ff 00		 cmp	 DWORD PTR _DirectoryDataExtentSize$[ebp], 0
  0005d	77 0f		 ja	 SHORT $LN23@BlCdFindDi
  0005f	ba 19 01 00 00	 mov	 edx, 281		; 00000119H
  00064	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@
  00069	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN23@BlCdFindDi:

; 282  : 
; 283  :         BLASSERT((*NextToken != 0) && (*NextToken != '/'));

  0006e	8b 45 e4	 mov	 eax, DWORD PTR _NextToken$[ebp]
  00071	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00074	85 c9		 test	 ecx, ecx
  00076	74 0b		 je	 SHORT $LN21@BlCdFindDi
  00078	8b 55 e4	 mov	 edx, DWORD PTR _NextToken$[ebp]
  0007b	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0007e	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00081	75 0f		 jne	 SHORT $LN22@BlCdFindDi
$LN21@BlCdFindDi:
  00083	ba 1b 01 00 00	 mov	 edx, 283		; 0000011bH
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@
  0008d	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN22@BlCdFindDi:

; 284  : 
; 285  :         Separator = NextToken;

  00092	8b 4d e4	 mov	 ecx, DWORD PTR _NextToken$[ebp]
  00095	89 8d d4 fd ff
	ff		 mov	 DWORD PTR _Separator$[ebp], ecx
$LN20@BlCdFindDi:

; 286  : 
; 287  :         while ((*Separator != '/') && (*Separator != 0)) {

  0009b	8b 95 d4 fd ff
	ff		 mov	 edx, DWORD PTR _Separator$[ebp]
  000a1	0f be 02	 movsx	 eax, BYTE PTR [edx]
  000a4	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  000a7	74 1e		 je	 SHORT $LN19@BlCdFindDi
  000a9	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _Separator$[ebp]
  000af	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  000b2	85 d2		 test	 edx, edx
  000b4	74 11		 je	 SHORT $LN19@BlCdFindDi

; 288  : 
; 289  :             Separator += 1;

  000b6	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _Separator$[ebp]
  000bc	83 c0 01	 add	 eax, 1
  000bf	89 85 d4 fd ff
	ff		 mov	 DWORD PTR _Separator$[ebp], eax

; 290  :         }

  000c5	eb d4		 jmp	 SHORT $LN20@BlCdFindDi
$LN19@BlCdFindDi:

; 291  : 
; 292  :         TokenSize = (UINT32) (Separator - NextToken);

  000c7	8b 8d d4 fd ff
	ff		 mov	 ecx, DWORD PTR _Separator$[ebp]
  000cd	2b 4d e4	 sub	 ecx, DWORD PTR _NextToken$[ebp]
  000d0	89 4d fc	 mov	 DWORD PTR _TokenSize$[ebp], ecx

; 293  : 
; 294  :         for (Index = 0; Index < TokenSize; Index += 1) {

  000d3	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0
  000da	eb 09		 jmp	 SHORT $LN18@BlCdFindDi
$LN17@BlCdFindDi:
  000dc	8b 55 f8	 mov	 edx, DWORD PTR _Index$[ebp]
  000df	83 c2 01	 add	 edx, 1
  000e2	89 55 f8	 mov	 DWORD PTR _Index$[ebp], edx
$LN18@BlCdFindDi:
  000e5	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  000e8	3b 45 fc	 cmp	 eax, DWORD PTR _TokenSize$[ebp]
  000eb	73 19		 jae	 SHORT $LN16@BlCdFindDi

; 295  : 
; 296  :             Token[Index] = BlRtlConvertCharacterToUpperCase(NextToken[Index]);

  000ed	8b 4d e4	 mov	 ecx, DWORD PTR _NextToken$[ebp]
  000f0	03 4d f8	 add	 ecx, DWORD PTR _Index$[ebp]
  000f3	8a 09		 mov	 cl, BYTE PTR [ecx]
  000f5	e8 00 00 00 00	 call	 ?BlRtlConvertCharacterToUpperCase@@YIDD@Z ; BlRtlConvertCharacterToUpperCase
  000fa	8b 55 f8	 mov	 edx, DWORD PTR _Index$[ebp]
  000fd	88 84 15 d8 fd
	ff ff		 mov	 BYTE PTR _Token$[ebp+edx], al

; 297  :         }

  00104	eb d6		 jmp	 SHORT $LN17@BlCdFindDi
$LN16@BlCdFindDi:

; 298  : 
; 299  :         Token[TokenSize] = 0;

  00106	8b 45 fc	 mov	 eax, DWORD PTR _TokenSize$[ebp]
  00109	c6 84 05 d8 fd
	ff ff 00	 mov	 BYTE PTR _Token$[ebp+eax], 0

; 300  : 
; 301  :         DirectoryData = (PISO9660_LOGICAL_BLOCK) BlPoolAllocateBlock(DirectoryDataExtentSize * ISO9660_LOGICAL_BLOCK_SIZE);

  00111	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _DirectoryDataExtentSize$[ebp]
  00117	c1 e1 0b	 shl	 ecx, 11			; 0000000bH
  0011a	e8 00 00 00 00	 call	 ?BlPoolAllocateBlock@@YIPAXK@Z ; BlPoolAllocateBlock
  0011f	89 85 d0 fd ff
	ff		 mov	 DWORD PTR _DirectoryData$[ebp], eax

; 302  :         DirectoryDataLimit = (ULONG_PTR) DirectoryData + (DirectoryDataExtentSize * ISO9660_LOGICAL_BLOCK_SIZE);

  00125	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _DirectoryDataExtentSize$[ebp]
  0012b	c1 e1 0b	 shl	 ecx, 11			; 0000000bH
  0012e	03 8d d0 fd ff
	ff		 add	 ecx, DWORD PTR _DirectoryData$[ebp]
  00134	89 4d f0	 mov	 DWORD PTR _DirectoryDataLimit$[ebp], ecx

; 303  : 
; 304  :         BlCdReadLogicalBlock(DirectoryDataExtentStart,
; 305  :                              DirectoryDataExtentSize,
; 306  :                              DirectoryData);

  00137	8b 95 d0 fd ff
	ff		 mov	 edx, DWORD PTR _DirectoryData$[ebp]
  0013d	52		 push	 edx
  0013e	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR _DirectoryDataExtentSize$[ebp]
  00144	8b 4d f4	 mov	 ecx, DWORD PTR _DirectoryDataExtentStart$[ebp]
  00147	e8 00 00 00 00	 call	 ?BlCdReadLogicalBlock@@YIXKKPAU_ISO9660_LOGICAL_BLOCK@@@Z ; BlCdReadLogicalBlock

; 307  : 
; 308  :         Entry = NULL;

  0014c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _Entry$[ebp], 0

; 309  : 
; 310  :         for (DirectoryDataIndex = 0; (Entry == NULL) && (DirectoryDataIndex < DirectoryDataExtentSize); DirectoryDataIndex += 1) {

  00153	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _DirectoryDataIndex$[ebp], 0
  0015a	eb 09		 jmp	 SHORT $LN15@BlCdFindDi
$LN14@BlCdFindDi:
  0015c	8b 45 e8	 mov	 eax, DWORD PTR _DirectoryDataIndex$[ebp]
  0015f	83 c0 01	 add	 eax, 1
  00162	89 45 e8	 mov	 DWORD PTR _DirectoryDataIndex$[ebp], eax
$LN15@BlCdFindDi:
  00165	83 7d ec 00	 cmp	 DWORD PTR _Entry$[ebp], 0
  00169	0f 85 c5 00 00
	00		 jne	 $LN13@BlCdFindDi
  0016f	8b 4d e8	 mov	 ecx, DWORD PTR _DirectoryDataIndex$[ebp]
  00172	3b 8d dc fe ff
	ff		 cmp	 ecx, DWORD PTR _DirectoryDataExtentSize$[ebp]
  00178	0f 83 b6 00 00
	00		 jae	 $LN13@BlCdFindDi

; 311  : 
; 312  :             Entry = (PISO9660_DIRECTORY_RECORD) &DirectoryData[DirectoryDataIndex];

  0017e	8b 55 e8	 mov	 edx, DWORD PTR _DirectoryDataIndex$[ebp]
  00181	c1 e2 0b	 shl	 edx, 11			; 0000000bH
  00184	03 95 d0 fd ff
	ff		 add	 edx, DWORD PTR _DirectoryData$[ebp]
  0018a	89 55 ec	 mov	 DWORD PTR _Entry$[ebp], edx
$LN12@BlCdFindDi:

; 313  : 
; 314  :             for (;;) {
; 315  : 
; 316  :                 if (Entry->DirectoryRecordLength == 0) {

  0018d	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  00190	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00193	85 c9		 test	 ecx, ecx
  00195	75 0c		 jne	 SHORT $LN10@BlCdFindDi

; 317  : 
; 318  :                     Entry = NULL;

  00197	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _Entry$[ebp], 0

; 319  :                     break;

  0019e	e9 8c 00 00 00	 jmp	 $LN11@BlCdFindDi
$LN10@BlCdFindDi:

; 320  :                 }
; 321  : 
; 322  :                 if (Entry->FileIdentifierLength == (TokenSize * 2)) {

  001a3	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  001a6	0f b6 42 20	 movzx	 eax, BYTE PTR [edx+32]
  001aa	8b 4d fc	 mov	 ecx, DWORD PTR _TokenSize$[ebp]
  001ad	d1 e1		 shl	 ecx, 1
  001af	3b c1		 cmp	 eax, ecx
  001b1	75 53		 jne	 SHORT $LN9@BlCdFindDi

; 323  : 
; 324  :                     for (Index = 0; Index < TokenSize; Index += 1) {

  001b3	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _Index$[ebp], 0
  001ba	eb 09		 jmp	 SHORT $LN8@BlCdFindDi
$LN7@BlCdFindDi:
  001bc	8b 55 f8	 mov	 edx, DWORD PTR _Index$[ebp]
  001bf	83 c2 01	 add	 edx, 1
  001c2	89 55 f8	 mov	 DWORD PTR _Index$[ebp], edx
$LN8@BlCdFindDi:
  001c5	8b 45 f8	 mov	 eax, DWORD PTR _Index$[ebp]
  001c8	3b 45 fc	 cmp	 eax, DWORD PTR _TokenSize$[ebp]
  001cb	73 1b		 jae	 SHORT $LN6@BlCdFindDi

; 325  : 
; 326  :                         Temp[Index] = BlRtlConvertCharacterToUpperCase(Entry->FileIdentifier[(Index * 2) + 1]);

  001cd	8b 4d f8	 mov	 ecx, DWORD PTR _Index$[ebp]
  001d0	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  001d3	8a 4c 4a 22	 mov	 cl, BYTE PTR [edx+ecx*2+34]
  001d7	e8 00 00 00 00	 call	 ?BlRtlConvertCharacterToUpperCase@@YIDD@Z ; BlRtlConvertCharacterToUpperCase
  001dc	8b 4d f8	 mov	 ecx, DWORD PTR _Index$[ebp]
  001df	88 84 0d e0 fe
	ff ff		 mov	 BYTE PTR _Temp$[ebp+ecx], al

; 327  :                     }

  001e6	eb d4		 jmp	 SHORT $LN7@BlCdFindDi
$LN6@BlCdFindDi:

; 328  : 
; 329  :                     if (BlRtlCompareMemory(Temp, Token, TokenSize) != FALSE) {

  001e8	8b 55 fc	 mov	 edx, DWORD PTR _TokenSize$[ebp]
  001eb	52		 push	 edx
  001ec	8d 95 d8 fd ff
	ff		 lea	 edx, DWORD PTR _Token$[ebp]
  001f2	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR _Temp$[ebp]
  001f8	e8 00 00 00 00	 call	 ?BlRtlCompareMemory@@YIEPBX0K@Z ; BlRtlCompareMemory
  001fd	0f b6 c0	 movzx	 eax, al
  00200	85 c0		 test	 eax, eax
  00202	74 02		 je	 SHORT $LN9@BlCdFindDi

; 330  : 
; 331  :                         break;

  00204	eb 29		 jmp	 SHORT $LN11@BlCdFindDi
$LN9@BlCdFindDi:

; 332  :                     }
; 333  :                 }
; 334  : 
; 335  :                 Entry = (PISO9660_DIRECTORY_RECORD) ROUND_UP_TO_POWER2((((ULONG_PTR) Entry) + Entry->DirectoryRecordLength), 2);

  00206	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  00209	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0020c	8b 45 ec	 mov	 eax, DWORD PTR _Entry$[ebp]
  0020f	8d 4c 10 01	 lea	 ecx, DWORD PTR [eax+edx+1]
  00213	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00216	89 4d ec	 mov	 DWORD PTR _Entry$[ebp], ecx

; 336  : 
; 337  :                 if ((ULONG_PTR) Entry >= DirectoryDataLimit) {

  00219	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  0021c	3b 55 f0	 cmp	 edx, DWORD PTR _DirectoryDataLimit$[ebp]
  0021f	72 09		 jb	 SHORT $LN4@BlCdFindDi

; 338  : 
; 339  :                     Entry = NULL;

  00221	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _Entry$[ebp], 0

; 340  :                     break;

  00228	eb 05		 jmp	 SHORT $LN11@BlCdFindDi
$LN4@BlCdFindDi:

; 341  :                 }
; 342  :             }

  0022a	e9 5e ff ff ff	 jmp	 $LN12@BlCdFindDi
$LN11@BlCdFindDi:

; 343  :         }

  0022f	e9 28 ff ff ff	 jmp	 $LN14@BlCdFindDi
$LN13@BlCdFindDi:

; 344  : 
; 345  :         if (Entry == NULL) {

  00234	83 7d ec 00	 cmp	 DWORD PTR _Entry$[ebp], 0
  00238	75 12		 jne	 SHORT $LN3@BlCdFindDi

; 346  : 
; 347  :             BlPoolFreeBlock(DirectoryData);

  0023a	8b 8d d0 fd ff
	ff		 mov	 ecx, DWORD PTR _DirectoryData$[ebp]
  00240	e8 00 00 00 00	 call	 ?BlPoolFreeBlock@@YIXPAX@Z ; BlPoolFreeBlock

; 348  : 
; 349  :             return FALSE;

  00245	32 c0		 xor	 al, al
  00247	e9 8c 00 00 00	 jmp	 $LN27@BlCdFindDi
$LN3@BlCdFindDi:

; 350  :         }
; 351  : 
; 352  :         if (*Separator == 0) {

  0024c	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _Separator$[ebp]
  00252	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00255	85 c9		 test	 ecx, ecx
  00257	75 1f		 jne	 SHORT $LN2@BlCdFindDi

; 353  : 
; 354  :             BlRtlCopyMemory(DirectoryRecord,
; 355  :                             Entry,
; 356  :                             sizeof(ISO9660_DIRECTORY_RECORD));

  00259	6a 22		 push	 34			; 00000022H
  0025b	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  0025e	8b 8d c8 fd ff
	ff		 mov	 ecx, DWORD PTR _DirectoryRecord$[ebp]
  00264	e8 00 00 00 00	 call	 ?BlRtlCopyMemory@@YIXPAXPBXK@Z ; BlRtlCopyMemory

; 357  : 
; 358  :             BlPoolFreeBlock(DirectoryData);

  00269	8b 8d d0 fd ff
	ff		 mov	 ecx, DWORD PTR _DirectoryData$[ebp]
  0026f	e8 00 00 00 00	 call	 ?BlPoolFreeBlock@@YIXPAX@Z ; BlPoolFreeBlock

; 359  : 
; 360  :             return TRUE;

  00274	b0 01		 mov	 al, 1
  00276	eb 60		 jmp	 SHORT $LN27@BlCdFindDi
$LN2@BlCdFindDi:

; 361  :         }
; 362  : 
; 363  :         if (Entry->u1.s1.Directory == FALSE) {

  00278	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  0027b	8a 42 19	 mov	 al, BYTE PTR [edx+25]
  0027e	d0 e8		 shr	 al, 1
  00280	24 01		 and	 al, 1
  00282	0f b6 c8	 movzx	 ecx, al
  00285	85 c9		 test	 ecx, ecx
  00287	75 0f		 jne	 SHORT $LN1@BlCdFindDi

; 364  : 
; 365  :             BlPoolFreeBlock(DirectoryData);

  00289	8b 8d d0 fd ff
	ff		 mov	 ecx, DWORD PTR _DirectoryData$[ebp]
  0028f	e8 00 00 00 00	 call	 ?BlPoolFreeBlock@@YIXPAX@Z ; BlPoolFreeBlock

; 366  : 
; 367  :             return FALSE;

  00294	32 c0		 xor	 al, al
  00296	eb 40		 jmp	 SHORT $LN27@BlCdFindDi
$LN1@BlCdFindDi:

; 368  :         }
; 369  : 
; 370  :         DirectoryDataExtentStart = Entry->ExtentLocation;

  00298	8b 55 ec	 mov	 edx, DWORD PTR _Entry$[ebp]
  0029b	8b 42 02	 mov	 eax, DWORD PTR [edx+2]
  0029e	89 45 f4	 mov	 DWORD PTR _DirectoryDataExtentStart$[ebp], eax

; 371  :         DirectoryDataExtentSize = ROUND_UP_TO_POWER2(Entry->DataLength, ISO9660_LOGICAL_BLOCK_SIZE) / ISO9660_LOGICAL_BLOCK_SIZE;

  002a1	8b 4d ec	 mov	 ecx, DWORD PTR _Entry$[ebp]
  002a4	8b 51 0a	 mov	 edx, DWORD PTR [ecx+10]
  002a7	81 c2 ff 07 00
	00		 add	 edx, 2047		; 000007ffH
  002ad	81 e2 00 f8 ff
	ff		 and	 edx, -2048		; fffff800H
  002b3	c1 ea 0b	 shr	 edx, 11			; 0000000bH
  002b6	89 95 dc fe ff
	ff		 mov	 DWORD PTR _DirectoryDataExtentSize$[ebp], edx

; 372  :         NextToken = Separator + 1;

  002bc	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _Separator$[ebp]
  002c2	83 c0 01	 add	 eax, 1
  002c5	89 45 e4	 mov	 DWORD PTR _NextToken$[ebp], eax

; 373  : 
; 374  :         BlPoolFreeBlock(DirectoryData);

  002c8	8b 8d d0 fd ff
	ff		 mov	 ecx, DWORD PTR _DirectoryData$[ebp]
  002ce	e8 00 00 00 00	 call	 ?BlPoolFreeBlock@@YIXPAX@Z ; BlPoolFreeBlock

; 375  :     }

  002d3	e9 69 fd ff ff	 jmp	 $LN26@BlCdFindDi
$LN27@BlCdFindDi:

; 376  : }

  002d8	8b e5		 mov	 esp, ebp
  002da	5d		 pop	 ebp
  002db	c3		 ret	 0
?BlCdFindDirectoryRecord@@YIEPBDPAU_ISO9660_DIRECTORY_RECORD@@@Z ENDP ; BlCdFindDirectoryRecord
_TEXT	ENDS
PUBLIC	??_C@_0BO@OBEOJDCJ@CdGetFileSize?3?5?$FL?$CFs?$FN?5FAILED?52?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@ODAICNHA@CdGetFileSize?3?5?$FL?$CFs?$FN?5FAILED?51?6?$AA@ ; `string'
PUBLIC	?BlCdGetFileSize@@YIEPBDPAK@Z			; BlCdGetFileSize
;	COMDAT ??_C@_0BO@OBEOJDCJ@CdGetFileSize?3?5?$FL?$CFs?$FN?5FAILED?52?6?$AA@
CONST	SEGMENT
??_C@_0BO@OBEOJDCJ@CdGetFileSize?3?5?$FL?$CFs?$FN?5FAILED?52?6?$AA@ DB 'C'
	DB	'dGetFileSize: [%s] FAILED 2', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ODAICNHA@CdGetFileSize?3?5?$FL?$CFs?$FN?5FAILED?51?6?$AA@
CONST	SEGMENT
??_C@_0BO@ODAICNHA@CdGetFileSize?3?5?$FL?$CFs?$FN?5FAILED?51?6?$AA@ DB 'C'
	DB	'dGetFileSize: [%s] FAILED 1', 0aH, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlCdGetFileSize@@YIEPBDPAK@Z
_TEXT	SEGMENT
_FileSize$ = -44					; size = 4
_Path$ = -40						; size = 4
_DirectoryRecord$ = -36					; size = 34
?BlCdGetFileSize@@YIEPBDPAK@Z PROC			; BlCdGetFileSize, COMDAT
; _Path$ = ecx
; _FileSize$ = edx

; 403  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 55 d4	 mov	 DWORD PTR _FileSize$[ebp], edx
  00009	89 4d d8	 mov	 DWORD PTR _Path$[ebp], ecx

; 404  :     ISO9660_DIRECTORY_RECORD DirectoryRecord;
; 405  : 
; 406  :     if (BlCdFindDirectoryRecord(Path, &DirectoryRecord) == FALSE) {

  0000c	8d 55 dc	 lea	 edx, DWORD PTR _DirectoryRecord$[ebp]
  0000f	8b 4d d8	 mov	 ecx, DWORD PTR _Path$[ebp]
  00012	e8 00 00 00 00	 call	 ?BlCdFindDirectoryRecord@@YIEPBDPAU_ISO9660_DIRECTORY_RECORD@@@Z ; BlCdFindDirectoryRecord
  00017	0f b6 c0	 movzx	 eax, al
  0001a	85 c0		 test	 eax, eax
  0001c	75 15		 jne	 SHORT $LN2@BlCdGetFil

; 407  : 
; 408  :         BlRtlPrintf("CdGetFileSize: [%s] FAILED 1\n", Path);

  0001e	8b 4d d8	 mov	 ecx, DWORD PTR _Path$[ebp]
  00021	51		 push	 ecx
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@ODAICNHA@CdGetFileSize?3?5?$FL?$CFs?$FN?5FAILED?51?6?$AA@
  00027	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  0002c	83 c4 08	 add	 esp, 8

; 409  : 
; 410  :         return FALSE;

  0002f	32 c0		 xor	 al, al
  00031	eb 2e		 jmp	 SHORT $LN3@BlCdGetFil
$LN2@BlCdGetFil:

; 411  :     }
; 412  : 
; 413  :     if (DirectoryRecord.u1.s1.Directory != FALSE) {

  00033	8a 55 f5	 mov	 dl, BYTE PTR _DirectoryRecord$[ebp+25]
  00036	d0 ea		 shr	 dl, 1
  00038	80 e2 01	 and	 dl, 1
  0003b	0f b6 c2	 movzx	 eax, dl
  0003e	85 c0		 test	 eax, eax
  00040	74 15		 je	 SHORT $LN1@BlCdGetFil

; 414  : 
; 415  :         BlRtlPrintf("CdGetFileSize: [%s] FAILED 2\n", Path);

  00042	8b 4d d8	 mov	 ecx, DWORD PTR _Path$[ebp]
  00045	51		 push	 ecx
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@OBEOJDCJ@CdGetFileSize?3?5?$FL?$CFs?$FN?5FAILED?52?6?$AA@
  0004b	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00050	83 c4 08	 add	 esp, 8

; 416  : 
; 417  :         return FALSE;

  00053	32 c0		 xor	 al, al
  00055	eb 0a		 jmp	 SHORT $LN3@BlCdGetFil
$LN1@BlCdGetFil:

; 418  :     }
; 419  : 
; 420  :     *FileSize = DirectoryRecord.DataLength;

  00057	8b 55 d4	 mov	 edx, DWORD PTR _FileSize$[ebp]
  0005a	8b 45 e6	 mov	 eax, DWORD PTR _DirectoryRecord$[ebp+10]
  0005d	89 02		 mov	 DWORD PTR [edx], eax

; 421  :     return TRUE;

  0005f	b0 01		 mov	 al, 1
$LN3@BlCdGetFil:

; 422  : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?BlCdGetFileSize@@YIEPBDPAK@Z ENDP			; BlCdGetFileSize
_TEXT	ENDS
PUBLIC	?BlCdReadFile@@YIEPBDPAXK@Z			; BlCdReadFile
; Function compile flags: /Odtp
;	COMDAT ?BlCdReadFile@@YIEPBDPAXK@Z
_TEXT	SEGMENT
_Buffer$ = -2112					; size = 4
_Path$ = -2108						; size = 4
_Block$ = -2104						; size = 2048
_Next$ = -52						; size = 4
_ChunkSize$ = -44					; size = 4
_DirectoryRecord$ = -40					; size = 34
_Offset$ = -4						; size = 4
_NumberOfBytes$ = 8					; size = 4
?BlCdReadFile@@YIEPBDPAXK@Z PROC			; BlCdReadFile, COMDAT
; _Path$ = ecx
; _Buffer$ = edx

; 452  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 40 08 00
	00		 sub	 esp, 2112		; 00000840H
  00009	89 95 c0 f7 ff
	ff		 mov	 DWORD PTR _Buffer$[ebp], edx
  0000f	89 8d c4 f7 ff
	ff		 mov	 DWORD PTR _Path$[ebp], ecx

; 453  :     ISO9660_LOGICAL_BLOCK Block;
; 454  :     UINT32 ChunkOffset;
; 455  :     UINT32 ChunkSize;
; 456  :     ISO9660_DIRECTORY_RECORD DirectoryRecord;
; 457  :     PUINT8 Next;
; 458  :     UINT32 Offset = 0;

  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _Offset$[ebp], 0

; 459  : 
; 460  :     if (BlCdFindDirectoryRecord(Path, &DirectoryRecord) == FALSE) {

  0001c	8d 55 d8	 lea	 edx, DWORD PTR _DirectoryRecord$[ebp]
  0001f	8b 8d c4 f7 ff
	ff		 mov	 ecx, DWORD PTR _Path$[ebp]
  00025	e8 00 00 00 00	 call	 ?BlCdFindDirectoryRecord@@YIEPBDPAU_ISO9660_DIRECTORY_RECORD@@@Z ; BlCdFindDirectoryRecord
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	75 07		 jne	 SHORT $LN7@BlCdReadFi

; 461  : 
; 462  :         return FALSE;

  00031	32 c0		 xor	 al, al
  00033	e9 d1 00 00 00	 jmp	 $LN8@BlCdReadFi
$LN7@BlCdReadFi:

; 463  :     }
; 464  : 
; 465  :     if (DirectoryRecord.u1.s1.Directory != FALSE) {

  00038	8a 4d f1	 mov	 cl, BYTE PTR _DirectoryRecord$[ebp+25]
  0003b	d0 e9		 shr	 cl, 1
  0003d	80 e1 01	 and	 cl, 1
  00040	0f b6 d1	 movzx	 edx, cl
  00043	85 d2		 test	 edx, edx
  00045	74 07		 je	 SHORT $LN6@BlCdReadFi

; 466  : 
; 467  :         return FALSE;

  00047	32 c0		 xor	 al, al
  00049	e9 bb 00 00 00	 jmp	 $LN8@BlCdReadFi
$LN6@BlCdReadFi:

; 468  :     }
; 469  : 
; 470  :     if (NumberOfBytes > DirectoryRecord.DataLength) {

  0004e	8b 45 08	 mov	 eax, DWORD PTR _NumberOfBytes$[ebp]
  00051	3b 45 e2	 cmp	 eax, DWORD PTR _DirectoryRecord$[ebp+10]
  00054	76 07		 jbe	 SHORT $LN5@BlCdReadFi

; 471  : 
; 472  :         return FALSE;

  00056	32 c0		 xor	 al, al
  00058	e9 ac 00 00 00	 jmp	 $LN8@BlCdReadFi
$LN5@BlCdReadFi:

; 473  :     }
; 474  : 
; 475  :     if (NumberOfBytes == 0) {

  0005d	83 7d 08 00	 cmp	 DWORD PTR _NumberOfBytes$[ebp], 0
  00061	75 07		 jne	 SHORT $LN4@BlCdReadFi

; 476  : 
; 477  :         return TRUE;

  00063	b0 01		 mov	 al, 1
  00065	e9 9f 00 00 00	 jmp	 $LN8@BlCdReadFi
$LN4@BlCdReadFi:

; 478  :     }
; 479  : 
; 480  :     Next = (PUINT8) Buffer;

  0006a	8b 8d c0 f7 ff
	ff		 mov	 ecx, DWORD PTR _Buffer$[ebp]
  00070	89 4d cc	 mov	 DWORD PTR _Next$[ebp], ecx

; 481  : 
; 482  :     //
; 483  :     // Handle full-read blocks in a single step.
; 484  :     //
; 485  : 
; 486  :     if (NumberOfBytes >= ISO9660_LOGICAL_BLOCK_SIZE) {

  00073	81 7d 08 00 08
	00 00		 cmp	 DWORD PTR _NumberOfBytes$[ebp], 2048 ; 00000800H
  0007a	72 41		 jb	 SHORT $LN3@BlCdReadFi

; 487  : 
; 488  :         ChunkSize = NumberOfBytes - (NumberOfBytes % ISO9660_LOGICAL_BLOCK_SIZE);

  0007c	8b 45 08	 mov	 eax, DWORD PTR _NumberOfBytes$[ebp]
  0007f	33 d2		 xor	 edx, edx
  00081	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00086	f7 f1		 div	 ecx
  00088	8b 45 08	 mov	 eax, DWORD PTR _NumberOfBytes$[ebp]
  0008b	2b c2		 sub	 eax, edx
  0008d	89 45 d4	 mov	 DWORD PTR _ChunkSize$[ebp], eax

; 489  : 
; 490  :         BlCdReadLogicalBlock(DirectoryRecord.ExtentLocation,
; 491  :                              ChunkSize / ISO9660_LOGICAL_BLOCK_SIZE,
; 492  :                              (PISO9660_LOGICAL_BLOCK) Next);

  00090	8b 4d cc	 mov	 ecx, DWORD PTR _Next$[ebp]
  00093	51		 push	 ecx
  00094	8b 55 d4	 mov	 edx, DWORD PTR _ChunkSize$[ebp]
  00097	c1 ea 0b	 shr	 edx, 11			; 0000000bH
  0009a	8b 4d da	 mov	 ecx, DWORD PTR _DirectoryRecord$[ebp+2]
  0009d	e8 00 00 00 00	 call	 ?BlCdReadLogicalBlock@@YIXKKPAU_ISO9660_LOGICAL_BLOCK@@@Z ; BlCdReadLogicalBlock

; 493  : 
; 494  :         Next += ChunkSize;

  000a2	8b 55 cc	 mov	 edx, DWORD PTR _Next$[ebp]
  000a5	03 55 d4	 add	 edx, DWORD PTR _ChunkSize$[ebp]
  000a8	89 55 cc	 mov	 DWORD PTR _Next$[ebp], edx

; 495  :         Offset += ChunkSize;

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _Offset$[ebp]
  000ae	03 45 d4	 add	 eax, DWORD PTR _ChunkSize$[ebp]
  000b1	89 45 fc	 mov	 DWORD PTR _Offset$[ebp], eax

; 496  :         NumberOfBytes -= ChunkSize;

  000b4	8b 4d 08	 mov	 ecx, DWORD PTR _NumberOfBytes$[ebp]
  000b7	2b 4d d4	 sub	 ecx, DWORD PTR _ChunkSize$[ebp]
  000ba	89 4d 08	 mov	 DWORD PTR _NumberOfBytes$[ebp], ecx
$LN3@BlCdReadFi:

; 497  :     }
; 498  : 
; 499  :     //
; 500  :     // Check if the ending block is a partial read.
; 501  :     //
; 502  : 
; 503  :     BLASSERT(NumberOfBytes < ISO9660_LOGICAL_BLOCK_SIZE);

  000bd	81 7d 08 00 08
	00 00		 cmp	 DWORD PTR _NumberOfBytes$[ebp], 2048 ; 00000800H
  000c4	72 0f		 jb	 SHORT $LN2@BlCdReadFi
  000c6	ba f7 01 00 00	 mov	 edx, 503		; 000001f7H
  000cb	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@
  000d0	e8 00 00 00 00	 call	 ?BlRtlAssertFailed@@YIXPBDK@Z ; BlRtlAssertFailed
$LN2@BlCdReadFi:

; 504  : 
; 505  :     if (NumberOfBytes > 0) {

  000d5	83 7d 08 00	 cmp	 DWORD PTR _NumberOfBytes$[ebp], 0
  000d9	76 2c		 jbe	 SHORT $LN1@BlCdReadFi

; 506  : 
; 507  :         BlCdReadLogicalBlock(DirectoryRecord.ExtentLocation + (Offset / ISO9660_LOGICAL_BLOCK_SIZE),
; 508  :                              1,
; 509  :                              &Block);

  000db	8d 95 c8 f7 ff
	ff		 lea	 edx, DWORD PTR _Block$[ebp]
  000e1	52		 push	 edx
  000e2	8b 4d fc	 mov	 ecx, DWORD PTR _Offset$[ebp]
  000e5	c1 e9 0b	 shr	 ecx, 11			; 0000000bH
  000e8	03 4d da	 add	 ecx, DWORD PTR _DirectoryRecord$[ebp+2]
  000eb	ba 01 00 00 00	 mov	 edx, 1
  000f0	e8 00 00 00 00	 call	 ?BlCdReadLogicalBlock@@YIXKKPAU_ISO9660_LOGICAL_BLOCK@@@Z ; BlCdReadLogicalBlock

; 510  : 
; 511  :         BlRtlCopyMemory(Next,
; 512  :                         Block.Data,
; 513  :                         NumberOfBytes);

  000f5	8b 45 08	 mov	 eax, DWORD PTR _NumberOfBytes$[ebp]
  000f8	50		 push	 eax
  000f9	8d 95 c8 f7 ff
	ff		 lea	 edx, DWORD PTR _Block$[ebp]
  000ff	8b 4d cc	 mov	 ecx, DWORD PTR _Next$[ebp]
  00102	e8 00 00 00 00	 call	 ?BlRtlCopyMemory@@YIXPAXPBXK@Z ; BlRtlCopyMemory
$LN1@BlCdReadFi:

; 514  :     }
; 515  : 
; 516  :     return TRUE;

  00107	b0 01		 mov	 al, 1
$LN8@BlCdReadFi:

; 517  : }

  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c2 04 00	 ret	 4
?BlCdReadFile@@YIEPBDPAXK@Z ENDP			; BlCdReadFile
_TEXT	ENDS
PUBLIC	??_C@_0DB@HHGHCLEJ@CDROM?3?5Unable?5to?5find?5Joliet?5vol@ ; `string'
PUBLIC	??_C@_0CA@FBNAKALG@CDROM?3?5Unexpected?5sector?5size?$CB?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@PDLGCFII@CDROM?3?5Unable?5to?5get?5drive?5param@ ; `string'
PUBLIC	?BlCdInitialize@@YIXE@Z				; BlCdInitialize
EXTRN	?BlFsReadFile@@3P6IEPBDPAXK@ZA:DWORD		; BlFsReadFile
EXTRN	?BlFsGetFileSize@@3P6IEPBDPAK@ZA:DWORD		; BlFsGetFileSize
EXTRN	?BlRtlGetDriveParameters@@YIEEPAU_INT13_DRIVE_PARAMETERS@@@Z:PROC ; BlRtlGetDriveParameters
;	COMDAT ??_C@_0DB@HHGHCLEJ@CDROM?3?5Unable?5to?5find?5Joliet?5vol@
CONST	SEGMENT
??_C@_0DB@HHGHCLEJ@CDROM?3?5Unable?5to?5find?5Joliet?5vol@ DB 'CDROM: Una'
	DB	'ble to find Joliet volume descriptor.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FBNAKALG@CDROM?3?5Unexpected?5sector?5size?$CB?6?$AA@
CONST	SEGMENT
??_C@_0CA@FBNAKALG@CDROM?3?5Unexpected?5sector?5size?$CB?6?$AA@ DB 'CDROM'
	DB	': Unexpected sector size!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@PDLGCFII@CDROM?3?5Unable?5to?5get?5drive?5param@
CONST	SEGMENT
??_C@_0CI@PDLGCFII@CDROM?3?5Unable?5to?5get?5drive?5param@ DB 'CDROM: Una'
	DB	'ble to get drive parameters!', 0aH, 00H	; `string'
; Function compile flags: /Odtp
CONST	ENDS
;	COMDAT ?BlCdInitialize@@YIXE@Z
_TEXT	SEGMENT
_DriveId$ = -8						; size = 1
_LogicalBlockNumber$ = -4				; size = 4
?BlCdInitialize@@YIXE@Z PROC				; BlCdInitialize, COMDAT
; _DriveId$ = cl

; 536  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	88 4d f8	 mov	 BYTE PTR _DriveId$[ebp], cl

; 537  :     UINT32 LogicalBlockNumber;
; 538  : 
; 539  :     BlCdDriveId = DriveId;

  00009	8a 45 f8	 mov	 al, BYTE PTR _DriveId$[ebp]
  0000c	a2 00 00 00 00	 mov	 BYTE PTR ?BlCdDriveId@@3EA, al ; BlCdDriveId

; 540  : 
; 541  :     if (BlRtlGetDriveParameters(BlCdDriveId, &BlCdDriveParameters) == FALSE) {

  00011	ba 00 00 00 00	 mov	 edx, OFFSET ?BlCdDriveParameters@@3U_INT13_DRIVE_PARAMETERS@@A ; BlCdDriveParameters
  00016	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR ?BlCdDriveId@@3EA ; BlCdDriveId
  0001c	e8 00 00 00 00	 call	 ?BlRtlGetDriveParameters@@YIEEPAU_INT13_DRIVE_PARAMETERS@@@Z ; BlRtlGetDriveParameters
  00021	0f b6 c8	 movzx	 ecx, al
  00024	85 c9		 test	 ecx, ecx
  00026	75 1c		 jne	 SHORT $LN6@BlCdInitia

; 542  : 
; 543  :         BlRtlPrintf("CDROM: Unable to get drive parameters!\n");

  00028	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@PDLGCFII@CDROM?3?5Unable?5to?5get?5drive?5param@
  0002d	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  00032	83 c4 04	 add	 esp, 4

; 544  :         BlRtlHalt();

  00035	ba 20 02 00 00	 mov	 edx, 544		; 00000220H
  0003a	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@
  0003f	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN6@BlCdInitia:

; 545  :     }
; 546  : 
; 547  :     if (BlCdDriveParameters.BytesPerSector != ISO9660_LOGICAL_BLOCK_SIZE) {

  00044	0f b7 15 18 00
	00 00		 movzx	 edx, WORD PTR ?BlCdDriveParameters@@3U_INT13_DRIVE_PARAMETERS@@A+24
  0004b	81 fa 00 08 00
	00		 cmp	 edx, 2048		; 00000800H
  00051	74 1c		 je	 SHORT $LN5@BlCdInitia

; 548  : 
; 549  :         BlRtlPrintf("CDROM: Unexpected sector size!\n");

  00053	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@FBNAKALG@CDROM?3?5Unexpected?5sector?5size?$CB?6?$AA@
  00058	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  0005d	83 c4 04	 add	 esp, 4

; 550  :         BlRtlHalt();

  00060	ba 26 02 00 00	 mov	 edx, 550		; 00000226H
  00065	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@
  0006a	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN5@BlCdInitia:

; 551  :     }
; 552  : 
; 553  :     //
; 554  :     // Locate Joliet volume descriptor.
; 555  :     //
; 556  : 
; 557  :     LogicalBlockNumber = ISO9660_VOLUME_SPACE_DATA_AREA_LBN;

  0006f	c7 45 fc 10 00
	00 00		 mov	 DWORD PTR _LogicalBlockNumber$[ebp], 16 ; 00000010H
$LN4@BlCdInitia:

; 558  : 
; 559  :     for (;;) {
; 560  : 
; 561  :         BlCdReadLogicalBlock(LogicalBlockNumber,
; 562  :                              1,
; 563  :                              (PISO9660_LOGICAL_BLOCK) &BlCdVolumeDescriptor);

  00076	68 00 00 00 00	 push	 OFFSET ?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A ; BlCdVolumeDescriptor
  0007b	ba 01 00 00 00	 mov	 edx, 1
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _LogicalBlockNumber$[ebp]
  00083	e8 00 00 00 00	 call	 ?BlCdReadLogicalBlock@@YIXKKPAU_ISO9660_LOGICAL_BLOCK@@@Z ; BlCdReadLogicalBlock

; 564  : 
; 565  :         if ((BlCdVolumeDescriptor.u1.VolumeDescriptorType == ISO9660_VOLUME_DESCRIPTOR_TYPE_SUPPLEMENTARY) &&
; 566  :             (BlCdVolumeDescriptor.u1.Supplementary.EscapeSequences[0] == 0x25) &&
; 567  :             (BlCdVolumeDescriptor.u1.Supplementary.EscapeSequences[1] == 0x2F) &&
; 568  :             (BlCdVolumeDescriptor.u1.Supplementary.EscapeSequences[2] == 0x45)){

  00088	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A
  0008f	83 f8 02	 cmp	 eax, 2
  00092	75 26		 jne	 SHORT $LN2@BlCdInitia
  00094	0f b6 0d 58 00
	00 00		 movzx	 ecx, BYTE PTR ?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A+88
  0009b	83 f9 25	 cmp	 ecx, 37			; 00000025H
  0009e	75 1a		 jne	 SHORT $LN2@BlCdInitia
  000a0	0f b6 15 59 00
	00 00		 movzx	 edx, BYTE PTR ?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A+89
  000a7	83 fa 2f	 cmp	 edx, 47			; 0000002fH
  000aa	75 0e		 jne	 SHORT $LN2@BlCdInitia
  000ac	0f b6 05 5a 00
	00 00		 movzx	 eax, BYTE PTR ?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A+90
  000b3	83 f8 45	 cmp	 eax, 69			; 00000045H
  000b6	75 02		 jne	 SHORT $LN2@BlCdInitia

; 569  : 
; 570  :             break;

  000b8	eb 36		 jmp	 SHORT $LN3@BlCdInitia
$LN2@BlCdInitia:

; 571  :         }
; 572  : 
; 573  :         if (BlCdVolumeDescriptor.u1.VolumeDescriptorType == ISO9660_VOLUME_DESCRIPTOR_TYPE_TERMINATOR) {

  000ba	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?BlCdVolumeDescriptor@@3U_ISO9660_VOLUME_DESCRIPTOR@@A
  000c1	81 f9 ff 00 00
	00		 cmp	 ecx, 255		; 000000ffH
  000c7	75 1c		 jne	 SHORT $LN1@BlCdInitia

; 574  : 
; 575  :             BlRtlPrintf("CDROM: Unable to find Joliet volume descriptor.\n");

  000c9	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@HHGHCLEJ@CDROM?3?5Unable?5to?5find?5Joliet?5vol@
  000ce	e8 00 00 00 00	 call	 ?BlRtlPrintf@@YAEPBDZZ	; BlRtlPrintf
  000d3	83 c4 04	 add	 esp, 4

; 576  :             BlRtlHalt();

  000d6	ba 40 02 00 00	 mov	 edx, 576		; 00000240H
  000db	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_0M@CKJPMOGI@blcdrom?4cpp?$AA@
  000e0	e8 00 00 00 00	 call	 ?BlRtlHaltInternal@@YIXPBDK@Z ; BlRtlHaltInternal
$LN1@BlCdInitia:

; 577  :         }
; 578  : 
; 579  :         LogicalBlockNumber += 1;

  000e5	8b 55 fc	 mov	 edx, DWORD PTR _LogicalBlockNumber$[ebp]
  000e8	83 c2 01	 add	 edx, 1
  000eb	89 55 fc	 mov	 DWORD PTR _LogicalBlockNumber$[ebp], edx

; 580  :     }

  000ee	eb 86		 jmp	 SHORT $LN4@BlCdInitia
$LN3@BlCdInitia:

; 581  : 
; 582  :     BlFsGetFileSize = BlCdGetFileSize;

  000f0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BlFsGetFileSize@@3P6IEPBDPAK@ZA, OFFSET ?BlCdGetFileSize@@YIEPBDPAK@Z ; BlFsGetFileSize, BlCdGetFileSize

; 583  :     BlFsReadFile = BlCdReadFile;

  000fa	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?BlFsReadFile@@3P6IEPBDPAXK@ZA, OFFSET ?BlCdReadFile@@YIEPBDPAXK@Z ; BlFsReadFile, BlCdReadFile

; 584  : 
; 585  :     return;
; 586  : }

  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
?BlCdInitialize@@YIXE@Z ENDP				; BlCdInitialize
_TEXT	ENDS
END
